[Diagnostics.CodeAnalysis.SuppressMessageAttribute(
    'PSAvoidAssignmentToAutomaticVariable', 'IsWindows',
    Justification = 'IsWindows doesnt exist in PS5.1'
)]
[Diagnostics.CodeAnalysis.SuppressMessageAttribute(
    'PSUseDeclaredVarsMoreThanAssignments', 'IsWindows',
    Justification = 'IsWindows doesnt exist in PS5.1'
)]
#Requires -Modules @{ ModuleName = 'TimeSpan'; RequiredVersion = '3.0.1' }

[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains long links.')]
[CmdletBinding()]
param()

$baseName = [System.IO.Path]::GetFileNameWithoutExtension($PSCommandPath)
$script:PSModuleInfo = Import-PowerShellDataFile -Path "$PSScriptRoot\$baseName.psd1"
$script:PSModuleInfo | Format-List | Out-String -Stream | ForEach-Object { Write-Debug $_ }
$scriptName = $script:PSModuleInfo.Name
Write-Debug "[$scriptName] - Importing module"

if ($PSEdition -eq 'Desktop') {
    $IsWindows = $true
}

#region    [classes] - [public]
Write-Debug "[$scriptName] - [classes] - [public] - Processing folder"
#region    [classes] - [public] - [GitHubBillingInfo]
Write-Debug "[$scriptName] - [classes] - [public] - [GitHubBillingInfo] - Importing"
class GitHubBillingInfo {
    [int]$AllLicensableUsersCount
    [int]$AssetPacks
    [int]$BandwidthQuota
    [int]$BandwidthUsage
    [int]$BandwidthUsagePercentage
    [int]$StorageQuota
    [int]$StorageUsage
    [int]$StorageUsagePercentage
    [int]$TotalAvailableLicenses
    [int]$TotalLicenses

    GitHubBillingInfo() {}

    GitHubBillingInfo([PSCustomObject] $Object) {
        $this.AllLicensableUsersCount = $Object.allLicensableUsersCount
        $this.AssetPacks = $Object.assetPacks
        $this.BandwidthQuota = $Object.bandwidthQuota
        $this.BandwidthUsage = $Object.bandwidthUsage
        $this.BandwidthUsagePercentage = $Object.bandwidthUsagePercentage
        $this.StorageQuota = $Object.storageQuota
        $this.StorageUsage = $Object.storageUsage
        $this.StorageUsagePercentage = $Object.storageUsagePercentage
        $this.TotalAvailableLicenses = $Object.totalAvailableLicenses
        $this.TotalLicenses = $Object.totalLicenses
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [GitHubBillingInfo] - Done"
#endregion [classes] - [public] - [GitHubBillingInfo]
#region    [classes] - [public] - [GitHubFormatter]
Write-Debug "[$scriptName] - [classes] - [public] - [GitHubFormatter] - Importing"
class GitHubFormatter {
    static [string] FormatColorByRatio([double]$Ratio, [string]$Text) {
        $Ratio = [Math]::Min([Math]::Max($Ratio, 0), 1)

        if ($Ratio -ge 1) {
            $r = 0
            $g = 255
        } elseif ($Ratio -le 0) {
            $r = 255
            $g = 0
        } elseif ($Ratio -ge 0.5) {
            $r = [Math]::Round(255 * (2 - 2 * $Ratio))
            $g = 255
        } else {
            $r = 255
            $g = [Math]::Round(255 * (2 * $Ratio))
        }
        $color = "`e[38;2;$r;$g;0m"
        $reset = "`e[0m"
        return "$color$Text$reset"
    }

    static [string] FormatFileSize([long]$size) {
        switch ($size) {
            { $_ -ge 1TB } { return '{0:N2} TB' -f ($size / 1TB) }
            { $_ -ge 1GB } { return '{0:N2} GB' -f ($size / 1GB) }
            { $_ -ge 1MB } { return '{0:N2} MB' -f ($size / 1MB) }
            { $_ -ge 1KB } { return '{0:N2} KB' -f ($size / 1KB) }
        }
        return "$size  B"
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [GitHubFormatter] - Done"
#endregion [classes] - [public] - [GitHubFormatter]
#region    [classes] - [public] - [GitHubJWTComponent]
Write-Debug "[$scriptName] - [classes] - [public] - [GitHubJWTComponent] - Importing"
class GitHubJWTComponent {
    static [string] ToBase64UrlString([hashtable] $Data) {
        return [GitHubJWTComponent]::ConvertToBase64UrlFormat(
            [System.Convert]::ToBase64String(
                [System.Text.Encoding]::UTF8.GetBytes(
                    (ConvertTo-Json -InputObject $Data)
                )
            )
        )
    }

    static [string] ConvertToBase64UrlFormat([string] $Base64String) {
        return $Base64String.TrimEnd('=').Replace('+', '-').Replace('/', '_')
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [GitHubJWTComponent] - Done"
#endregion [classes] - [public] - [GitHubJWTComponent]
#region    [classes] - [public] - [GitHubLicense]
Write-Debug "[$scriptName] - [classes] - [public] - [GitHubLicense] - Importing"
class GitHubLicenseRule {
    # A description of the rule.
    [string] $Description

    # The machine-readable rule key.
    [string] $Key

    # The human-readable rule label.
    [string] $Label

    GitHubLicenseRule() {}

    GitHubLicenseRule([PSCustomObject]$Object) {
        $this.Description = $Object.description
        $this.Key = $Object.key
        $this.Label = $Object.label
    }

    [string] ToString() {
        return $this.Description
    }
}


class GitHubLicense {
    # The license key, used as an identifier.
    # Example: 'mit'
    [string] $Key

    # The full name of the license.
    # Example: 'MIT License'
    [string] $Name

    # Customary short name if applicable (e.g, GPLv3).
    # Example: 'MIT'
    [string] $NickName

    # The SPDX identifier of the license, or $null.
    # Example: 'MIT'
    [string] $SpdxId

    # The node ID of the license.
    # Example: 'MDc6TGljZW5zZW1pdA=='
    [string] $NodeID

    # The HTML URL where the license can be viewed.
    # Example: 'http://choosealicense.com/licenses/mit/'
    [string] $Url

    # A short description of the license.
    # Example: 'A permissive license that is short and to the point...'
    [string] $Description

    # Instructions for implementing the license in a project.
    # Example: 'Create a text file (typically named LICENSE or LICENSE.txt)...'
    [string] $Implementation

    # A list of permissions granted by the license.
    # Example: @('commercial-use', 'modifications', 'distribution', 'sublicense', 'private-use')
    [string[]] $Permissions

    # A list of conditions required by the license.
    # @('include-copyright')
    [string[]] $Conditions

    # A list of limitations of the license.
    # Example: @('no-liability')
    [string[]] $Limitations

    # The full body text of the license.
    # Example: 'The MIT License (MIT)...'
    [string] $Body

    # Indicates if this license is featured.
    # Example: $true
    [System.Nullable[bool]] $Featured

    GitHubLicense() {}

    GitHubLicense([PSCustomObject]$Object) {
        $this.Key = $Object.key
        $this.Name = $Object.name
        $this.NickName = $Object.nickname
        $this.SpdxId = $Object.spdx_id ?? $Object.spdxId
        $this.NodeID = $Object.node_id ?? $Object.id
        $this.Url = $Object.html_url ?? $Object.url
        $this.Description = $Object.description
        $this.Implementation = $Object.implementation
        $this.Permissions = [GitHubLicenseRule]::new($Object.permissions)
        $this.Conditions = [GitHubLicenseRule]::new($Object.conditions)
        $this.Limitations = [GitHubLicenseRule]::new($Object.limitations)
        $this.Body = $Object.body
        $this.Featured = $Object.featured
    }

    [string] ToString() {
        return $this.Name
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [GitHubLicense] - Done"
#endregion [classes] - [public] - [GitHubLicense]
#region    [classes] - [public] - [GitHubNode]
Write-Debug "[$scriptName] - [classes] - [public] - [GitHubNode] - Importing"
class GitHubNode {
    # The database ID of the node. Is aliased to 'DatabaseID'.
    # All function that take ID should also take the alias.
    # Example: 42
    [System.Nullable[UInt64]] $ID

    # The node ID of the node.
    # Example: MDQ6VXNlcjE=
    [string] $NodeID
}
Write-Debug "[$scriptName] - [classes] - [public] - [GitHubNode] - Done"
#endregion [classes] - [public] - [GitHubNode]
#region    [classes] - [public] - [GitHubPlan]
Write-Debug "[$scriptName] - [classes] - [public] - [GitHubPlan] - Importing"
class GitHubPlan {
    # The name of the plan.
    # Example: free, enterprise
    [string] $Name

    # The number of private repositories allowed.
    # Example: 20
    [System.Nullable[uint]] $PrivateRepos

    # The number of collaborators allowed.
    # Example: 3
    [System.Nullable[uint]] $Collaborators

    # The amount of space allocated in bytes.
    # Example: 976562499
    [System.Nullable[uint]] $Space

    # The total number of user seats included in the plan.
    # Example: 10
    [System.Nullable[uint]] $Seats

    # The number of seats currently filled.
    # Example: 7
    [System.Nullable[uint]] $FilledSeats

    GitHubPlan() {}

    GitHubPlan([PSCustomObject]$Object) {
        $this.Name = $Object.name
        $this.PrivateRepos = $Object.private_repos
        $this.Collaborators = $Object.collaborators
        $this.Space = $Object.space
        $this.Seats = $Object.seats
        $this.FilledSeats = $Object.filled_seats
    }

    [string] ToString() {
        return $this.Name
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [GitHubPlan] - Done"
#endregion [classes] - [public] - [GitHubPlan]
#region    [classes] - [public] - [App]
Write-Debug "[$scriptName] - [classes] - [public] - [App] - Processing folder"
#region    [classes] - [public] - [App] - [GitHubApp]
Write-Debug "[$scriptName] - [classes] - [public] - [App] - [GitHubApp] - Importing"
class GitHubApp : GitHubNode {
    # The unique ID of the app
    [System.Nullable[UInt64]] $ID

    # The Client ID of the app
    [string] $ClientID

    # The App ID of the app
    [System.Nullable[UInt64]] $AppID

    # The Slug of the app
    [string] $Slug

    # The node_id of the app
    [string] $NodeID

    # The owner of the app.
    [GitHubOwner] $Owner

    # The name of the app
    [string] $Name

    # The description of the app
    [string] $Description

    # The external URL of the app
    [string] $ExternalUrl

    # The HTML URL of the app
    [string] $Url

    # The creation date of the app
    [System.Nullable[datetime]] $CreatedAt

    # The last update date of the app
    [System.Nullable[datetime]] $UpdatedAt

    # The permissions that the app is requesting.
    [pscustomobject] $Permissions

    # The events that the app is subscribing to on its target.
    [string[]] $Events

    # The number of installations
    [System.Nullable[int]] $Installations

    GitHubApp() {}

    GitHubApp([object]$Object) {
        $this.ID = $Object.id
        $this.ClientID = $Object.client_id
        $this.AppID = $Object.app_id
        $this.Slug = $Object.app_slug ?? $Object.slug
        $this.NodeID = $Object.node_id
        $this.Owner = [GitHubOwner]::new($Object.owner)
        $this.Name = $Object.name
        $this.Description = $Object.description
        $this.ExternalUrl = $Object.external_url
        $this.Url = $Object.html_url
        $this.CreatedAt = $Object.created_at
        $this.UpdatedAt = $Object.updated_at
        $this.Permissions = $Object.permissions
        $this.Events = , ($Object.events)
        $this.Installations = $Object.installations_count
    }

    [string] ToString() {
        return $this.Slug
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [App] - [GitHubApp] - Done"
#endregion [classes] - [public] - [App] - [GitHubApp]
#region    [classes] - [public] - [App] - [GitHubAppInstallation]
Write-Debug "[$scriptName] - [classes] - [public] - [App] - [GitHubAppInstallation] - Importing"
class GitHubAppInstallation {
    # The installation ID on the target.
    [System.Nullable[UInt64]] $ID

    # The app that is installed.
    [GitHubApp] $App

    # The target of the installation.
    [GitHubOwner] $Target

    # The type of target.
    [string] $Type

    # The type of repository selection.
    [string] $RepositorySelection

    # The permissions that the app has on the target.
    [pscustomobject] $Permissions

    # The events that the app is subscribing to.
    [string[]] $Events

    # The file paths that the app has access to.
    [string[]] $FilePaths

    # The creation date of the installation.
    # Example: 2008-01-14T04:33:35Z
    [System.Nullable[datetime]] $CreatedAt

    # The last update date of the installation.
    # Example: 2008-01-14T04:33:35Z
    [System.Nullable[datetime]] $UpdatedAt

    # The date the installation was suspended.
    # Example: 2008-01-14T04:33:35Z
    [System.Nullable[datetime]] $SuspendedAt

    # The account that suspended the installation.
    [GitHubUser] $SuspendedBy

    # The URL to the target's profile based on the target type.
    [string] $Url

    GitHubAppInstallation() {}

    GitHubAppInstallation([PSCustomObject] $Object) {
        $this.ID = $Object.id
        $this.App = [GitHubApp]::new(
            [PSCustomObject]@{
                client_id = $Object.client_id
                app_id    = $Object.app_id
                app_slug  = $Object.app_slug
            }
        )
        $this.Target = [GitHubOwner]::new($Object.account)
        $this.Type = $Object.target_type
        $this.RepositorySelection = $Object.repository_selection
        $this.Permissions = $Object.permissions
        $this.Events = , ($Object.events)
        $this.FilePaths = $Object.single_file_paths
        $this.CreatedAt = $Object.created_at
        $this.UpdatedAt = $Object.updated_at
        $this.SuspendedAt = $Object.suspended_at
        $this.SuspendedBy = [GitHubUser]::new($Object.suspended_by)
        $this.Url = $Object.html_url
    }

    GitHubAppInstallation([PSCustomObject] $Object, [string] $Target, [string] $Type, [GitHubContext] $Context) {
        $this.ID = $Object.id
        $this.App = [GitHubApp]::new(
            [PSCustomObject]@{
                client_id = $Object.client_id
                app_id    = $Object.app_id
                app_slug  = $Object.app_slug
            }
        )
        $this.Target = [GitHubOwner]@{
            Name = $Target
            Type = $Type
            Url  = "https://$($Context.HostName)/$Target"
        }
        $this.Type = $Type
        $this.RepositorySelection = $Object.repository_selection
        $this.Permissions = $Object.permissions
        $this.Events = , ($Object.events)
        $this.FilePaths = $Object.single_file_paths
        $this.CreatedAt = $Object.created_at
        $this.UpdatedAt = $Object.updated_at
        $this.SuspendedAt = $Object.suspended_at
        $this.SuspendedBy = [GitHubUser]::new($Object.suspended_by)
        $this.Url = "https://$($Context.HostName)/$($Type.ToLower())s/$Target/settings/installations/$($Object.id)"
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [App] - [GitHubAppInstallation] - Done"
#endregion [classes] - [public] - [App] - [GitHubAppInstallation]
#region    [classes] - [public] - [App] - [GitHubAppInstallationRequest]
Write-Debug "[$scriptName] - [classes] - [public] - [App] - [GitHubAppInstallationRequest] - Importing"
class GitHubAppInstallationRequest : GitHubNode {
    # The user who requested the installation.
    [GitHubUser] $RequestedBy

    # The target of the installation.
    [GitHubOwner] $Target

    # The creation date of the installation.
    # Example: 2008-01-14T04:33:35Z
    [System.Nullable[datetime]] $CreatedAt

    GitHubAppInstallationRequest() {}

    GitHubAppInstallationRequest([PSCustomObject]$Object) {
        $this.ID = $Object.id
        $this.NodeID = $Object.node_id
        $this.RequestedBy = [GitHubUser]::new($Object.requester)
        $this.Target = [GitHubOwner]::new($Object.account)
        $this.CreatedAt = $Object.created_at
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [App] - [GitHubAppInstallationRequest] - Done"
#endregion [classes] - [public] - [App] - [GitHubAppInstallationRequest]
Write-Debug "[$scriptName] - [classes] - [public] - [App] - Done"
#endregion [classes] - [public] - [App]
#region    [classes] - [public] - [Artifacts]
Write-Debug "[$scriptName] - [classes] - [public] - [Artifacts] - Processing folder"
#region    [classes] - [public] - [Artifacts] - [GitHubArtifact]
Write-Debug "[$scriptName] - [classes] - [public] - [Artifacts] - [GitHubArtifact] - Importing"
class GitHubArtifact : GitHubNode {
    # The name of the artifact.
    [string] $Name

    # The name of the organization or user the variable is associated with.
    [string] $Owner

    # The name of the repository the variable is associated with.
    [string] $Repository

    # The size of the artifact in bytes.
    [int64] $Size

    # The API URL for accessing the artifact.
    [string] $Url

    # The URL for downloading the artifact archive.
    [string] $ArchiveDownloadUrl

    # Indicates if the artifact has expired.
    [bool] $Expired

    # The SHA256 digest of the artifact.
    [string] $Digest

    # The timestamp when the artifact was created.
    [datetime] $CreatedAt

    # The timestamp when the artifact was last updated.
    [datetime] $UpdatedAt

    # The timestamp when the artifact will expire.
    [datetime] $ExpiresAt

    # Information about the associated workflow run.
    [PSCustomObject] $WorkflowRun

    GitHubArtifact() {}

    GitHubArtifact([PSCustomObject]$Object, [string]$Owner, [string]$Repository, [GitHubContext]$Context) {
        $this.ID = $Object.id
        $this.NodeID = $Object.node_id
        $this.Name = $Object.name
        $this.Owner = $Owner
        $this.Repository = $Repository
        $this.Size = $Object.size_in_bytes
        $this.Url = "https://$($Context.HostName)/$Owner/$Repository/actions/runs/$($Object.workflow_run.id)/artifacts/$($Object.id)"
        $this.ArchiveDownloadUrl = $Object.archive_download_url
        $this.Expired = $Object.expired
        $this.Digest = $Object.digest
        $this.CreatedAt = $Object.created_at
        $this.UpdatedAt = $Object.updated_at
        $this.ExpiresAt = $Object.expires_at
        $this.WorkflowRun = $Object.workflow_run
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Artifacts] - [GitHubArtifact] - Done"
#endregion [classes] - [public] - [Artifacts] - [GitHubArtifact]
Write-Debug "[$scriptName] - [classes] - [public] - [Artifacts] - Done"
#endregion [classes] - [public] - [Artifacts]
#region    [classes] - [public] - [Config]
Write-Debug "[$scriptName] - [classes] - [public] - [Config] - Processing folder"
#region    [classes] - [public] - [Config] - [GitHubConfig]
Write-Debug "[$scriptName] - [classes] - [public] - [Config] - [GitHubConfig] - Importing"
class GitHubConfig {
    # The context ID.
    [string] $ID

    # The access token grace period in hours.
    [System.Nullable[double]] $AccessTokenGracePeriodInHours

    # The default context.
    [string] $DefaultContext

    # The default GitHub App client ID.
    [string] $GitHubAppClientID

    # The default host name.
    [string] $HostName

    # The default base URI for the GitHub API, which is used to make API calls.
    [string] $ApiBaseUri

    # The default OAuth app client ID.
    [string] $OAuthAppClientID

    # The default value for the GitHub API version to use.
    [string] $ApiVersion

    # The default value for the HTTP protocol version.
    [string] $HttpVersion

    # The default value for the 'per_page' API parameter used in 'GET' functions that support paging.
    [System.Nullable[int]] $PerPage

    # The default value for retry count.
    [System.Nullable[int]] $RetryCount

    # The default value for retry interval in seconds.
    [System.Nullable[int]] $RetryInterval

    # The tolerance time in seconds for JWT token validation.
    [System.Nullable[int]] $JwtTimeTolerance

    # The environment type, which is used to determine the context of the GitHub API calls.
    [string] $EnvironmentType

    # Simple parameterless constructor
    GitHubConfig() {}

    # Creates a context object from a hashtable of key-vaule pairs.
    GitHubConfig([hashtable]$Properties) {
        foreach ($Property in $Properties.Keys) {
            $this.$Property = $Properties.$Property
        }
    }

    # Creates a context object from a PSCustomObject.
    GitHubConfig([PSCustomObject]$Object) {
        $Object.PSObject.Properties | ForEach-Object {
            $this.($_.Name) = $_.Value
        }
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Config] - [GitHubConfig] - Done"
#endregion [classes] - [public] - [Config] - [GitHubConfig]
Write-Debug "[$scriptName] - [classes] - [public] - [Config] - Done"
#endregion [classes] - [public] - [Config]
#region    [classes] - [public] - [Context]
Write-Debug "[$scriptName] - [classes] - [public] - [Context] - Processing folder"
#region    [classes] - [public] - [Context] - [GitHubContext]
Write-Debug "[$scriptName] - [classes] - [public] - [Context] - [GitHubContext] - Importing"
class GitHubContext {
    # The context ID.
    [string] $ID

    # The GitHub Context Name.
    # HostName/Username or HostName/AppSlug
    # github.com/Octocat
    [string] $Name

    # The display name of the context.
    # Octocat
    [string] $DisplayName

    # The context type
    # User / App / Installation
    [string] $Type

    # The API hostname.
    # github.com / msx.ghe.com / github.local
    [string] $HostName

    # The API base URI.
    # https://api.github.com
    [string] $ApiBaseUri

    # The GitHub API version.
    # 2022-11-28
    [string] $ApiVersion

    # The authentication type.
    # UAT / PAT / App / IAT
    [string] $AuthType

    # User ID / App ID as GraphQL Node ID
    [string] $NodeID

    # The Database ID of the context.
    [string] $DatabaseID

    # The user name.
    [string] $UserName

    # The access token.
    [securestring] $Token

    # The token type.
    # ghu / gho / ghp / github_pat / JWT / ghs /
    [string] $TokenType

    # The token expiration date.
    # 2024-01-01-00:00:00
    [System.Nullable[datetime]] $TokenExpiresAt

    # The default value for the Enterprise parameter.
    [string] $Enterprise

    # The default value for the Owner parameter.
    [string] $Owner

    # The default value for the Repository parameter.
    [string] $Repository

    # The default value for the HTTP protocol version.
    [string] $HttpVersion

    # The default value for the 'per_page' API parameter used in 'GET' functions that support paging.
    [int] $PerPage

    GitHubContext() {}

    GitHubContext([pscustomobject]$Object) {
        $this.ID = $Object.ID
        $this.Name = $Object.Name
        $this.DisplayName = $Object.DisplayName
        $this.Type = $Object.Type
        $this.HostName = $Object.HostName
        $this.ApiBaseUri = $Object.ApiBaseUri
        $this.ApiVersion = $Object.ApiVersion
        $this.AuthType = $Object.AuthType
        $this.NodeID = $Object.NodeID
        $this.DatabaseID = $Object.DatabaseID
        $this.UserName = $Object.UserName
        $this.Token = $Object.Token
        $this.TokenType = $Object.TokenType
        $this.Enterprise = $Object.Enterprise
        $this.Owner = $Object.Owner
        $this.Repository = $Object.Repository
        $this.HttpVersion = $Object.HttpVersion
        $this.PerPage = $Object.PerPage
    }

    [string] ToString() {
        return $this.Name
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Context] - [GitHubContext] - Done"
#endregion [classes] - [public] - [Context] - [GitHubContext]
#region    [classes] - [public] - [Context] - [GitHubContext]
Write-Debug "[$scriptName] - [classes] - [public] - [Context] - [GitHubContext] - Processing folder"
#region    [classes] - [public] - [Context] - [GitHubContext] - [GitHubAppContext]
Write-Debug "[$scriptName] - [classes] - [public] - [Context] - [GitHubContext] - [GitHubAppContext] - Importing"
class GitHubAppContext : GitHubContext {
    # Client ID for GitHub Apps
    [string] $ClientID

    # The private key for the app.
    [securestring] $PrivateKey

    # Azure Key Vault key reference for JWT signing (alternative to PrivateKey).
    [string] $KeyVaultKeyReference

    # Owner of the GitHub App
    [string] $OwnerName

    # Type of the owner of the GitHub App
    [string] $OwnerType

    # The permissions that the app is requesting on the target
    [pscustomobject] $Permissions

    # The events that the app is subscribing to once installed
    [string[]] $Events

    GitHubAppContext() {}

    GitHubAppContext([pscustomobject]$Object) {
        $this.ID = $Object.ID
        $this.Name = $Object.Name
        $this.DisplayName = $Object.DisplayName
        $this.Type = $Object.Type
        $this.HostName = $Object.HostName
        $this.ApiBaseUri = $Object.ApiBaseUri
        $this.ApiVersion = $Object.ApiVersion
        $this.AuthType = $Object.AuthType
        $this.NodeID = $Object.NodeID
        $this.DatabaseID = $Object.DatabaseID
        $this.UserName = $Object.UserName
        $this.Token = $Object.Token
        $this.TokenType = $Object.TokenType
        $this.TokenExpiresAt = $Object.TokenExpiresAt
        $this.Enterprise = $Object.Enterprise
        $this.Owner = $Object.Owner
        $this.Repository = $Object.Repository
        $this.HttpVersion = $Object.HttpVersion
        $this.PerPage = $Object.PerPage
        $this.ClientID = $Object.ClientID
        $this.PrivateKey = $Object.PrivateKey
        $this.KeyVaultKeyReference = $Object.KeyVaultKeyReference
        $this.OwnerName = $Object.OwnerName
        $this.OwnerType = $Object.OwnerType
        $this.Permissions = $Object.Permissions
        $this.Events = $Object.Events
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Context] - [GitHubContext] - [GitHubAppContext] - Done"
#endregion [classes] - [public] - [Context] - [GitHubContext] - [GitHubAppContext]
#region    [classes] - [public] - [Context] - [GitHubContext] - [GitHubAppInstallationContext]
Write-Debug "[$scriptName] - [classes] - [public] - [Context] - [GitHubContext] - [GitHubAppInstallationContext] - Importing"
class GitHubAppInstallationContext : GitHubContext {
    # Client ID for GitHub Apps
    [string] $ClientID

    # The installation ID.
    [System.Nullable[uint64]] $InstallationID

    # The permissions that the app is requesting on the target
    [pscustomobject] $Permissions

    # The events that the app is subscribing to once installed
    [string[]] $Events

    # The target type of the installation.
    [string] $InstallationType

    # The target login or slug of the installation.
    [string] $InstallationName

    GitHubAppInstallationContext() {}

    GitHubAppInstallationContext([pscustomobject]$Object) {
        $this.ID = $Object.ID
        $this.Name = $Object.Name
        $this.DisplayName = $Object.DisplayName
        $this.Type = $Object.Type
        $this.HostName = $Object.HostName
        $this.ApiBaseUri = $Object.ApiBaseUri
        $this.ApiVersion = $Object.ApiVersion
        $this.AuthType = $Object.AuthType
        $this.NodeID = $Object.NodeID
        $this.DatabaseID = $Object.DatabaseID
        $this.UserName = $Object.UserName
        $this.Token = $Object.Token
        $this.TokenType = $Object.TokenType
        $this.TokenExpiresAt = $Object.TokenExpiresAt
        $this.Enterprise = $Object.Enterprise
        $this.Owner = $Object.Owner
        $this.Repository = $Object.Repository
        $this.HttpVersion = $Object.HttpVersion
        $this.PerPage = $Object.PerPage
        $this.ClientID = $Object.ClientID
        $this.InstallationID = $Object.InstallationID
        $this.Permissions = $Object.Permissions
        $this.Events = $Object.Events
        $this.InstallationType = $Object.InstallationType
        $this.InstallationName = $Object.InstallationName
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Context] - [GitHubContext] - [GitHubAppInstallationContext] - Done"
#endregion [classes] - [public] - [Context] - [GitHubContext] - [GitHubAppInstallationContext]
#region    [classes] - [public] - [Context] - [GitHubContext] - [GitHubUserContext]
Write-Debug "[$scriptName] - [classes] - [public] - [Context] - [GitHubContext] - [GitHubUserContext] - Importing"
class GitHubUserContext : GitHubContext {
    # The authentication client ID.
    # Client ID for UAT
    [string] $AuthClientID

    # The device flow type.
    # GitHubApp / OAuthApp
    [string] $DeviceFlowType

    # The scope when authenticating with OAuth.
    # 'gist read:org repo workflow'
    [string] $Scope

    # The refresh token.
    [securestring] $RefreshToken

    # The refresh token expiration date.
    # 2024-01-01-00:00:00
    [System.Nullable[datetime]] $RefreshTokenExpiresAt

    GitHubUserContext() {}

    GitHubUserContext([PSCustomObject]$Object) {
        $this.ID = $Object.ID
        $this.Name = $Object.Name
        $this.DisplayName = $Object.DisplayName
        $this.Type = $Object.Type
        $this.HostName = $Object.HostName
        $this.ApiBaseUri = $Object.ApiBaseUri
        $this.ApiVersion = $Object.ApiVersion
        $this.AuthType = $Object.AuthType
        $this.NodeID = $Object.NodeID
        $this.DatabaseID = $Object.DatabaseID
        $this.UserName = $Object.UserName
        $this.Token = $Object.Token
        $this.TokenType = $Object.TokenType
        $this.TokenExpiresAt = $Object.TokenExpiresAt
        $this.Enterprise = $Object.Enterprise
        $this.Owner = $Object.Owner
        $this.Repository = $Object.Repository
        $this.HttpVersion = $Object.HttpVersion
        $this.PerPage = $Object.PerPage
        $this.AuthClientID = $Object.AuthClientID
        $this.DeviceFlowType = $Object.DeviceFlowType
        $this.Scope = $Object.Scope
        $this.RefreshToken = $Object.RefreshToken
        $this.RefreshTokenExpiresAt = $Object.RefreshTokenExpiresAt
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Context] - [GitHubContext] - [GitHubUserContext] - Done"
#endregion [classes] - [public] - [Context] - [GitHubContext] - [GitHubUserContext]
Write-Debug "[$scriptName] - [classes] - [public] - [Context] - [GitHubContext] - Done"
#endregion [classes] - [public] - [Context] - [GitHubContext]
Write-Debug "[$scriptName] - [classes] - [public] - [Context] - Done"
#endregion [classes] - [public] - [Context]
#region    [classes] - [public] - [Environment]
Write-Debug "[$scriptName] - [classes] - [public] - [Environment] - Processing folder"
#region    [classes] - [public] - [Environment] - [GitHubEnvironment]
Write-Debug "[$scriptName] - [classes] - [public] - [Environment] - [GitHubEnvironment] - Importing"
class GitHubEnvironment : GitHubNode {
    # The name of the environment.
    [string] $Name

    # The repository where the environment is.
    [string] $Repository

    # The owner of the environment.
    [string] $Owner

    # URL of the environment.
    [string] $Url

    # The date and time the environment was created.
    [System.Nullable[datetime]] $CreatedAt

    # The date and time the environment was last updated.
    [System.Nullable[datetime]] $UpdatedAt

    # Whether admins can bypass protection rules.
    [System.Nullable[bool]] $AdminsCanBypass

    # Protection rules associated with the environment.
    [object[]] $ProtectionRules

    # Deployment branch policy details.
    [object] $DeploymentBranchPolicy

    GitHubEnvironment() {}

    GitHubEnvironment([PSCustomObject]$Object, [string]$Owner, [string]$Repository, [GitHubContext]$Context) {
        $this.ID = $Object.id
        $this.NodeID = $Object.node_id
        $this.Name = $Object.name
        $this.Owner = $Owner
        $this.Repository = $Repository
        $this.Url = "https://$($Context.HostName)/$Owner/$Repository/settings/environments/$($Object.id)/edit"
        $this.CreatedAt = $Object.created_at
        $this.UpdatedAt = $Object.updated_at
        $this.AdminsCanBypass = $Object.can_admins_bypass
        $this.ProtectionRules = $Object.protection_rules
        $this.DeploymentBranchPolicy = $Object.deployment_branch_policy
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Environment] - [GitHubEnvironment] - Done"
#endregion [classes] - [public] - [Environment] - [GitHubEnvironment]
Write-Debug "[$scriptName] - [classes] - [public] - [Environment] - Done"
#endregion [classes] - [public] - [Environment]
#region    [classes] - [public] - [Owner]
Write-Debug "[$scriptName] - [classes] - [public] - [Owner] - Processing folder"
#region    [classes] - [public] - [Owner] - [GitHubOwner]
Write-Debug "[$scriptName] - [classes] - [public] - [Owner] - [GitHubOwner] - Importing"
class GitHubOwner : GitHubNode {
    # The username/login of the owner.
    # Example: octocat
    [string] $Name

    # The name of the organization.
    # Example: github
    [string] $DisplayName

    # The avatar URL of the owner.
    # Example: https://github.com/images/error/octocat_happy.gif
    [string] $AvatarUrl

    # The URL to the owner's profile.
    # Example: https://github.com/octocat
    [string] $Url

    # The type of the owner: 'User', 'Organization' or 'Enterprise'.
    # Example: User
    [string] $Type

    # The location of the account.
    # Example: San Francisco
    [string] $Location

    # The description of the organization.
    # Example: A great organization
    [string] $Description

    # The website URL of the account.
    # Example: https://github.com/blog
    [string] $Website

    # The creation date of the account.
    # Example: 2008-01-14T04:33:35Z
    [System.Nullable[datetime]] $CreatedAt

    # The last update date of the account.
    # Example: 2008-01-14T04:33:35Z
    [System.Nullable[datetime]] $UpdatedAt

    GitHubOwner() {}

    GitHubOwner([PSCustomObject]$Object) {
        # From GitHubNode
        $this.ID = $Object.id
        $this.NodeID = $Object.node_id

        # From GitHubOwner
        $this.Name = $Object.slug ?? $Object.login
        $this.DisplayName = $Object.name
        $this.AvatarUrl = $Object.avatar_url
        $this.Url = $Object.html_url ?? $Object.url
        $this.Type = $Object.type
        $this.Location = $Object.location
        $this.Description = $Object.description ?? $Object.bio
        $this.Website = $Object.websiteUrl ?? $Object.blog
        $this.CreatedAt = $Object.created_at
        $this.UpdatedAt = $Object.updated_at
    }

    [string] ToString() {
        return $this.Name
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Owner] - [GitHubOwner] - Done"
#endregion [classes] - [public] - [Owner] - [GitHubOwner]
#region    [classes] - [public] - [Owner] - [GitHubOwner]
Write-Debug "[$scriptName] - [classes] - [public] - [Owner] - [GitHubOwner] - Processing folder"
#region    [classes] - [public] - [Owner] - [GitHubOwner] - [GitHubEnterprise]
Write-Debug "[$scriptName] - [classes] - [public] - [Owner] - [GitHubOwner] - [GitHubEnterprise] - Importing"
class GitHubEnterprise : GitHubOwner {
    # The readme of the enterprise.
    # Example: This is the readme for the enterprise
    [string] $Readme

    # The readme of the enterprise, as HTML.
    # Example: <p>This is the readme for the enterprise</p>
    [string] $ReadmeHTML

    static [hashtable] $PropertyToGraphQLMap = @{
        ID          = 'databaseId'
        NodeID      = 'id'
        Name        = 'slug'
        DisplayName = 'name'
        AvatarUrl   = 'avatarUrl'
        Url         = 'url'
        Website     = 'websiteUrl'
        Location    = 'location'
        CreatedAt   = 'createdAt'
        UpdatedAt   = 'updatedAt'
        Description = 'description'
        Readme      = 'readme'
        ReadmeHTML  = 'readmeHTML'
    }

    GitHubEnterprise() {}

    GitHubEnterprise([PSCustomObject] $Object) {
        # From GitHubNode
        $this.ID = $Object.databaseId
        $this.NodeID = $Object.id

        # From GitHubOwner
        $this.Name = $Object.slug
        $this.DisplayName = $Object.name
        $this.AvatarUrl = $Object.avatarUrl
        $this.Url = $Object.url
        $this.Type = $Object.type ?? 'Enterprise'
        $this.Location = $Object.location
        $this.Description = $Object.description
        $this.Website = $Object.websiteUrl
        $this.CreatedAt = $Object.createdAt
        $this.UpdatedAt = $Object.updatedAt

        # From GitHubEnterprise
        $this.Readme = $Object.readme
        $this.ReadmeHTML = $Object.readmeHTML
    }

    [string] ToString() {
        return $this.Name
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Owner] - [GitHubOwner] - [GitHubEnterprise] - Done"
#endregion [classes] - [public] - [Owner] - [GitHubOwner] - [GitHubEnterprise]
#region    [classes] - [public] - [Owner] - [GitHubOwner] - [GitHubOrganization]
Write-Debug "[$scriptName] - [classes] - [public] - [Owner] - [GitHubOwner] - [GitHubOrganization] - Importing"
class GitHubOrganization : GitHubOwner {
    # The email of the account.
    # Example: octocat@github.com
    [string] $Email

    # The Twitter username.
    # Example: monalisa
    [string] $TwitterUsername

    # The user's plan.
    # Includes: Name, Collaborators, PrivateRepos, Space
    [GitHubPlan] $Plan

    # The number of public repositories.
    # Example: 2
    [System.Nullable[uint]] $PublicRepos

    # The number of public gists.
    # Example: 1
    [System.Nullable[uint]] $PublicGists

    # The number of followers.
    # Example: 20
    [System.Nullable[uint]] $Followers

    # The number of accounts this account is following.
    # Example: 0
    [System.Nullable[uint]] $Following

    # The number of private gists.
    # Example: 81
    [System.Nullable[uint]] $PrivateGists

    # The number of total private repositories.
    # Example: 100
    [System.Nullable[uint]] $TotalPrivateRepos

    # The number of owned private repositories.
    # Example: 100
    [System.Nullable[uint]] $OwnedPrivateRepos

    # The disk usage in kilobytes.
    # Example: 10000
    [System.Nullable[uint]] $DiskUsage

    # The number of collaborators on private repositories.
    # Example: 8
    [System.Nullable[uint]] $Collaborators

    # Whether the organization is verified.
    # Example: $true
    [System.Nullable[bool]] $IsVerified

    # Whether organization projects are enabled.
    # Example: $true
    [System.Nullable[bool]] $HasOrganizationProjects

    # Whether repository projects are enabled.
    # Example: $true
    [System.Nullable[bool]] $HasRepositoryProjects

    # The billing email address for the organization.
    # Example: org@example.com
    [string] $BillingEmail

    # The default permission level members have for organization repositories.
    # Example: read
    [string] $DefaultRepositoryPermission

    # Whether members can create repositories.
    # Example: $true
    [System.Nullable[bool]] $MembersCanCreateRepositories

    # Whether two-factor authentication is required for members.
    # Example: $true
    [System.Nullable[bool]] $RequiresTwoFactorAuthentication

    # The type of repositories members can create.
    # Example: all
    [string] $MembersAllowedRepositoryCreationType

    # Whether members can create public repositories.
    # Example: $true
    [System.Nullable[bool]] $MembersCanCreatePublicRepositories

    # Whether members can create private repositories.
    # Example: $true
    [System.Nullable[bool]] $MembersCanCreatePrivateRepositories

    # Whether members can create internal repositories.
    # Example: $true
    [System.Nullable[bool]] $MembersCanCreateInternalRepositories

    # Whether members can invite collaborators to repositories.
    # Example: $true
    [System.Nullable[bool]] $MembersCanInviteCollaborators

    # Whether members can create GitHub Pages sites.
    # Example: $true
    [System.Nullable[bool]] $MembersCanCreatePages

    # Whether members can fork private repositories.
    # Example: $false
    [System.Nullable[bool]] $MembersCanForkPrivateRepositories

    # Whether commit signoff is required on the web.
    # Example: $true
    [System.Nullable[bool]] $RequireWebCommitSignoff

    # Whether deploy keys are enabled for all repositories.
    # Example: $true
    [System.Nullable[bool]] $DeployKeysEnabledForRepositories

    # Whether members can create public GitHub Pages sites.
    # Example: $true
    [System.Nullable[bool]] $MembersCanCreatePublicPages

    # Whether members can create private GitHub Pages sites.
    # Example: $true
    [System.Nullable[bool]] $MembersCanCreatePrivatePages

    # Whether advanced security is enabled by default for new repositories.
    # Example: $true
    [System.Nullable[bool]] $AdvancedSecurityEnabledForNewRepositories

    # Whether Dependabot alerts are enabled by default for new repositories.
    # Example: $true
    [System.Nullable[bool]] $DependabotAlertsEnabledForNewRepositories

    # Whether Dependabot security updates are enabled by default for new repositories.
    # Example: $true
    [System.Nullable[bool]] $DependabotSecurityUpdatesEnabledForNewRepositories

    # Whether the dependency graph is enabled by default for new repositories.
    # Example: $true
    [System.Nullable[bool]] $DependencyGraphEnabledForNewRepositories

    # Whether secret scanning is enabled by default for new repositories.
    # Example: $true
    [System.Nullable[bool]] $SecretScanningEnabledForNewRepositories

    # Whether push protection for secret scanning is enabled by default for new repositories.
    # Example: $true
    [System.Nullable[bool]] $SecretScanningPushProtectionEnabledForNewRepositories

    # Whether a custom link is enabled for push protection in secret scanning.
    # Example: $true
    [System.Nullable[bool]] $SecretScanningPushProtectionCustomLinkEnabled

    # The custom link used for push protection in secret scanning.
    # Example: https://docs.example.com/secrets
    [string] $SecretScanningPushProtectionCustomLink

    # Whether secret scanning validity checks are enabled.
    # Example: $true
    [System.Nullable[bool]] $SecretScanningValidityChecksEnabled

    # The date and time when the organization was archived, if applicable.
    [System.Nullable[datetime]] $ArchivedAt

    static [hashtable] $PropertyToGraphQLMap = @{
        ArchivedAt      = 'archivedAt'
        AvatarUrl       = 'avatarUrl'
        CreatedAt       = 'createdAt'
        Description     = 'description'
        DisplayName     = 'name'
        Email           = 'email'
        ID              = 'databaseId'
        Location        = 'location'
        Name            = 'login'
        NodeID          = 'id'
        IsVerified      = 'isVerified'
        # MembersCanForkPrivateRepositories = 'membersCanForkPrivateRepositories'
        # RequiresTwoFactorAuthentication   = 'requiresTwoFactorAuthentication'
        TwitterUsername = 'twitterUsername'
        UpdatedAt       = 'updatedAt'
        Url             = 'url'
        # RequireWebCommitSignoff = 'webCommitSignoffRequired'
        Website         = 'websiteUrl'
    }

    GitHubOrganization() {}

    GitHubOrganization([PSCustomObject] $Object, [GitHubContext] $Context) {
        # From GitHubNode
        $this.ID = $Object.databaseId ?? $Object.id
        $this.NodeID = $Object.node_id ?? $Object.id

        # From GitHubOwner
        $this.Name = $Object.login
        $this.DisplayName = $Object.name
        $this.AvatarUrl = $Object.avatar_url ?? $Object.avatarUrl
        $this.Url = $Object.html_url ?? $Object.url ?? "https://$($Context.HostName)/$($Object.login)"
        $this.Type = $Object.type ?? 'Organization'
        $this.Location = $Object.location
        $this.Description = $Object.description
        $this.Website = $Object.website ?? $Object.blog
        $this.CreatedAt = $Object.created_at ?? $Object.createdAt
        $this.UpdatedAt = $Object.updated_at ?? $Object.updatedAt

        # From GitHubOrganization
        $this.Email = $Object.email
        $this.TwitterUsername = $Object.twitter_username ?? $Object.twitterUsername
        $this.Plan = [GitHubPlan]::New($Object.plan)
        $this.PublicRepos = $Object.public_repos
        $this.PublicGists = $Object.public_gists
        $this.Followers = $Object.followers
        $this.Following = $Object.following
        $this.PrivateGists = $Object.total_private_gists
        $this.TotalPrivateRepos = $Object.total_private_repos
        $this.OwnedPrivateRepos = $Object.owned_private_repos
        $this.DiskUsage = $Object.disk_usage
        $this.Collaborators = $Object.collaborators
        $this.IsVerified = $Object.is_verified ?? $Object.isVerified
        $this.HasOrganizationProjects = $Object.has_organization_projects
        $this.HasRepositoryProjects = $Object.has_repository_projects
        $this.BillingEmail = $Object.billing_email
        $this.DefaultRepositoryPermission = $Object.default_repository_permission
        $this.MembersCanCreateRepositories = $Object.members_can_create_repositories
        $this.RequiresTwoFactorAuthentication = $Object.two_factor_requirement_enabled ?? $Object.requiresTwoFactorAuthentication
        $this.MembersAllowedRepositoryCreationType = $Object.members_allowed_repository_creation_type
        $this.MembersCanCreatePublicRepositories = $Object.members_can_create_public_repositories
        $this.MembersCanCreatePrivateRepositories = $Object.members_can_create_private_repositories
        $this.MembersCanCreateInternalRepositories = $Object.members_can_create_internal_repositories
        $this.MembersCanInviteCollaborators = $Object.members_can_invite_collaborators
        $this.MembersCanCreatePages = $Object.members_can_create_pages
        $this.MembersCanForkPrivateRepositories = $Object.members_can_fork_private_repositories ?? $Object.membersCanForkPrivateRepositories
        $this.RequireWebCommitSignoff = $Object.web_commit_signoff_required ?? $Object.webCommitSignoffRequired
        $this.DeployKeysEnabledForRepositories = $Object.deploy_keys_enabled_for_repositories
        $this.MembersCanCreatePublicPages = $Object.members_can_create_public_pages
        $this.MembersCanCreatePrivatePages = $Object.members_can_create_private_pages
        $this.AdvancedSecurityEnabledForNewRepositories = $Object.advanced_security_enabled_for_new_repositories
        $this.DependabotAlertsEnabledForNewRepositories = $Object.dependabot_alerts_enabled_for_new_repositories
        $this.DependabotSecurityUpdatesEnabledForNewRepositories = $Object.dependabot_security_updates_enabled_for_new_repositories
        $this.DependencyGraphEnabledForNewRepositories = $Object.dependency_graph_enabled_for_new_repositories
        $this.SecretScanningEnabledForNewRepositories = $Object.secret_scanning_enabled_for_new_repositories
        $this.SecretScanningPushProtectionEnabledForNewRepositories = $Object.secret_scanning_push_protection_enabled_for_new_repositories
        $this.SecretScanningPushProtectionCustomLinkEnabled = $Object.secret_scanning_push_protection_custom_link_enabled
        $this.SecretScanningPushProtectionCustomLink = $Object.secret_scanning_push_protection_custom_link
        $this.SecretScanningValidityChecksEnabled = $Object.secret_scanning_validity_checks_enabled
        $this.ArchivedAt = $Object.archived_at ?? $Object.archivedAt
    }

    [string] ToString() {
        return $this.Name
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Owner] - [GitHubOwner] - [GitHubOrganization] - Done"
#endregion [classes] - [public] - [Owner] - [GitHubOwner] - [GitHubOrganization]
#region    [classes] - [public] - [Owner] - [GitHubOwner] - [GitHubUser]
Write-Debug "[$scriptName] - [classes] - [public] - [Owner] - [GitHubOwner] - [GitHubUser] - Importing"
class GitHubUser : GitHubOwner {
    # The email of the account.
    # Example: octocat@github.com
    [string] $Email

    # Whether the user is hireable.
    [System.Nullable[bool]] $Hireable

    # The company the account is affiliated with.
    # Example: GitHub
    [string] $Company

    # The Twitter username.
    # Example: monalisa
    [string] $TwitterUsername

    # The number of public repositories.
    # Example: 2
    [System.Nullable[uint]] $PublicRepos

    # The number of public gists.
    # Example: 1
    [System.Nullable[uint]] $PublicGists

    # The number of followers.
    # Example: 20
    [System.Nullable[uint]] $Followers

    # The number of accounts this account is following.
    # Example: 0
    [System.Nullable[uint]] $Following

    # The notification email address of the user.
    # Example: octocat@github.com
    [string] $NotificationEmail

    # The user's plan.
    # Includes: Name, Collaborators, PrivateRepos, Space
    [GitHubPlan] $Plan

    GitHubUser() {}

    GitHubUser([PSCustomObject]$Object) {
        # From GitHubNode
        $this.ID = $Object.id
        $this.NodeID = $Object.node_id

        # From GitHubOwner
        $this.Name = $Object.login
        $this.DisplayName = $Object.name
        $this.AvatarUrl = $Object.avatar_url
        $this.Url = $Object.html_url
        $this.Type = $Object.type
        $this.Location = $Object.location
        $this.Description = $Object.bio
        $this.Website = $Object.blog
        $this.CreatedAt = $Object.created_at
        $this.UpdatedAt = $Object.updated_at

        # From GitHubUser
        $this.Email = $Object.email
        $this.Hireable = $Object.hireable
        $this.Company = $Object.company
        $this.TwitterUsername = $Object.twitter_username
        $this.PublicRepos = $Object.public_repos
        $this.PublicGists = $Object.public_gists
        $this.Followers = $Object.followers
        $this.Following = $Object.following
        $this.NotificationEmail = $Object.notification_email
        $this.Plan = [GitHubPlan]::New($Object.plan)
    }

    [string] ToString() {
        return $this.Name
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Owner] - [GitHubOwner] - [GitHubUser] - Done"
#endregion [classes] - [public] - [Owner] - [GitHubOwner] - [GitHubUser]
Write-Debug "[$scriptName] - [classes] - [public] - [Owner] - [GitHubOwner] - Done"
#endregion [classes] - [public] - [Owner] - [GitHubOwner]
Write-Debug "[$scriptName] - [classes] - [public] - [Owner] - Done"
#endregion [classes] - [public] - [Owner]
#region    [classes] - [public] - [RateLimit]
Write-Debug "[$scriptName] - [classes] - [public] - [RateLimit] - Processing folder"
#region    [classes] - [public] - [RateLimit] - [GithubRateLimitResource]
Write-Debug "[$scriptName] - [classes] - [public] - [RateLimit] - [GithubRateLimitResource] - Importing"
class GitHubRateLimitResource {
    # The name of the resource.
    [string] $Name

    # The limit for the resource.
    [UInt64] $Limit

    # The number of requests used for the resource.
    [UInt64] $Used

    # The number of requests remaining for the resource.
    [UInt64] $Remaining

    # The time when the rate limit will reset.
    [DateTime] $ResetsAt

    # Simple parameterless constructor
    GitHubRateLimitResource() {}

    # Constructor that initializes the class from a PSCustomObject
    GitHubRateLimitResource([pscustomobject]$Object) {
        $this.Name = $Object.name
        $this.Limit = $Object.limit
        $this.Used = $Object.used
        $this.Remaining = $Object.remaining
        $this.ResetsAt = [DateTime]::UnixEpoch.AddSeconds($Object.reset).ToLocalTime()
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [RateLimit] - [GithubRateLimitResource] - Done"
#endregion [classes] - [public] - [RateLimit] - [GithubRateLimitResource]
Write-Debug "[$scriptName] - [classes] - [public] - [RateLimit] - Done"
#endregion [classes] - [public] - [RateLimit]
#region    [classes] - [public] - [Releases]
Write-Debug "[$scriptName] - [classes] - [public] - [Releases] - Processing folder"
#region    [classes] - [public] - [Releases] - [GitHubRelease]
Write-Debug "[$scriptName] - [classes] - [public] - [Releases] - [GitHubRelease] - Importing"
class GitHubRelease : GitHubNode {
    # Name of the release, can be null
    # Example: "v0.22.1"
    [string] $Name

    # The repository where the environment is.
    [string] $Repository

    # The owner of the environment.
    [string] $Owner

    # The name of the tag
    # Example: "v0.22.1"
    [string] $Tag

    # Release notes or changelog, can be null
    # Example: "## What's Changed\n### Other Changes\n* Fix: Enhance repository deletion feedback and fix typo..."
    [string] $Notes

    # Specifies the commitish value that determines where the Git tag is created from
    # Example: "main"
    [string] $Target

    # True if the release is the latest release on the repo.
    # Example: true
    [bool] $IsLatest

    # True to create a draft (unpublished) release, false to create a published one
    # Example: false
    [bool] $IsDraft

    # Whether to identify the release as a prerelease or a full release
    # Example: false
    [bool] $IsPrerelease

    # GitHub URL for the release
    # Example: "https://github.com/PSModule/GitHub/releases/tag/v0.22.1"
    [string] $Url

    # User who authored the release
    [GitHubUser] $Author

    # Timestamp when the release was created
    # Example: "2025-04-11T09:03:38Z"
    [System.Nullable[datetime]] $CreatedAt

    # Timestamp when the release was published
    # Example: "2025-04-11T13:41:34Z"
    [System.Nullable[datetime]] $PublishedAt

    # Timestamp when the release was updated
    # Example: "2025-04-11T13:41:34Z"
    [System.Nullable[datetime]] $UpdatedAt

    GitHubRelease() {}

    GitHubRelease([PSCustomObject] $Object, [string] $Owner, [string] $Repository, [System.Nullable[bool]] $Latest) {
        if ($null -ne $Object.node_id) {
            $this.ID = $Object.id
            $this.NodeID = $Object.node_id
            $this.Tag = $Object.tag_name
            $this.Name = $Object.name
            $this.Notes = $Object.body
            $this.IsLatest = $Latest
            $this.IsDraft = $Object.draft
            $this.IsPrerelease = $Object.prerelease
            $this.Url = $Object.html_url
            $this.Owner = $Owner
            $this.Repository = $Repository
            $this.Target = $Object.target_commitish
            $this.CreatedAt = $Object.created_at
            $this.PublishedAt = $Object.published_at
            $this.Author = [GitHubUser]::new($Object.author)
        } else {
            $this.ID = $Object.databaseId
            $this.NodeID = $Object.id
            $this.Tag = $Object.tagName
            $this.Name = $Object.name
            $this.Notes = $Object.description
            $this.IsLatest = $Object.isLatest
            $this.IsDraft = $Object.isDraft
            $this.IsPrerelease = $Object.isPrerelease
            $this.Url = $Object.url
            $this.Owner = $Owner
            $this.Repository = $Repository
            # $this.Target = $Object.target_commitish
            $this.CreatedAt = $Object.createdAt
            $this.PublishedAt = $Object.publishedAt
            $this.UpdatedAt = $Object.updatedAt
            $this.Author = [GitHubUser]::new($Object.author)
        }
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Releases] - [GitHubRelease] - Done"
#endregion [classes] - [public] - [Releases] - [GitHubRelease]
#region    [classes] - [public] - [Releases] - [GitHubReleaseAsset]
Write-Debug "[$scriptName] - [classes] - [public] - [Releases] - [GitHubReleaseAsset] - Importing"
class GitHubReleaseAsset : GitHubNode {
    # Description: URL for downloading the asset
    # Example: "https://github.com/PSModule/GitHub/releases/download/v0.22.1/asset.zip"
    [string] $Url

    # Description: The file name of the asset
    # Example: "Team Environment"
    [string] $Name

    # Description: Label for the asset, can be null
    # Example: null
    [string] $Label

    # Description: State of the release asset (e.g., uploaded, open)
    # Example: "uploaded"
    [string] $State

    # Description: MIME type of the asset
    # Example: "application/zip"
    [string] $ContentType

    # Description: Size of the asset in bytes
    # Example: 1024
    [int] $Size

    # Description: Number of times the asset was downloaded
    # Example: 100
    [int] $Downloads

    # Description: Timestamp when the asset was created
    # Example: "2025-04-11T09:03:38Z"
    [System.Nullable[datetime]] $CreatedAt

    # Description: Timestamp when the asset was last updated
    # Example: "2025-04-11T09:03:38Z"
    [System.Nullable[datetime]] $UpdatedAt

    # Description: User who uploaded the asset, can be null
    # Example: GitHubUser object or null
    [GitHubUser] $UploadedBy

    GitHubReleaseAsset() {}

    GitHubReleaseAsset([PSCustomObject]$Object) {
        if ($null -ne $Object.node_id) {
            $this.ID = $Object.id
            $this.NodeID = $Object.node_id
            $this.Url = $Object.browser_download_url
            $this.Name = $Object.name
            $this.Label = $Object.label
            $this.State = $Object.state
            $this.ContentType = $Object.content_type
            $this.Size = $Object.size
            $this.Downloads = $Object.download_count
            $this.CreatedAt = $Object.created_at
            $this.UpdatedAt = $Object.updated_at
            $this.UploadedBy = [GitHubUser]::new($Object.uploader)
        } else {
            $this.NodeID = $Object.id
            $this.Url = $Object.downloadUrl
            $this.Name = $Object.name
            $this.ContentType = $Object.contentType
            $this.Size = $Object.size
            $this.Downloads = $Object.downloadCount
            $this.CreatedAt = $Object.createdAt
            $this.UpdatedAt = $Object.updatedAt
            $this.UploadedBy = [GitHubUser]::new($Object.uploadedBy)
        }
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Releases] - [GitHubReleaseAsset] - Done"
#endregion [classes] - [public] - [Releases] - [GitHubReleaseAsset]
Write-Debug "[$scriptName] - [classes] - [public] - [Releases] - Done"
#endregion [classes] - [public] - [Releases]
#region    [classes] - [public] - [Repositories]
Write-Debug "[$scriptName] - [classes] - [public] - [Repositories] - Processing folder"
#region    [classes] - [public] - [Repositories] - [GitHubRepository]
Write-Debug "[$scriptName] - [classes] - [public] - [Repositories] - [GitHubRepository] - Importing"
class GitHubRepository : GitHubNode {
    # The name of the repository.
    # Example: Team Environment
    [string] $Name

    # The owner of the repository.
    # Example: octocat
    [GitHubOwner] $Owner

    # The full name of the repository, including the owner.
    # Example: octocat/Hello-World
    [string] $FullName

    # The HTML URL of the repository.
    # Example: https://github.com/octocat/Hello-World
    [string] $Url

    # The description of the repository.
    # Example: This your first repo!
    [string] $Description

    # The date and time the repository was created.
    # Example: 2011-01-26T19:01:12Z
    [System.Nullable[datetime]] $CreatedAt

    # The date and time the repository was last updated.
    # Example: 2011-01-26T19:14:43Z
    [System.Nullable[datetime]] $UpdatedAt

    # The date and time of the last push.
    # Example: 2011-01-26T19:06:43Z
    [System.Nullable[datetime]] $PushedAt

    # The date and time when the repository was archived.
    # Example: 2011-01-26T19:01:12Z
    [System.Nullable[datetime]] $ArchivedAt

    # The homepage URL.
    # Example: https://github.com
    [string] $Homepage

    # The size of the repository, in kilobytes.
    # Example: 108
    [System.Nullable[uint]] $Size

    # The primary language of the repository.
    # Example: null
    [GitHubRepositoryLanguage] $Language

    # Whether issues are enabled.
    # Example: true
    [System.Nullable[bool]] $HasIssues

    # Whether projects are enabled.
    # Example: true
    [System.Nullable[bool]] $HasProjects

    # Whether the wiki is enabled.
    # Example: true
    [System.Nullable[bool]] $HasWiki

    # Whether pages are enabled.
    # Example: false
    [System.Nullable[bool]] $HasPages

    # Whether discussions are enabled.
    # Example: true
    [System.Nullable[bool]] $HasDiscussions

    # Whether sponsorships are enabled.
    # Example: false
    [System.Nullable[bool]] $HasSponsorships

    # Indicates whether the repository is archived.
    # Example: false
    [System.Nullable[bool]] $IsArchived

    # Indicates whether the repository acts as a template.
    # Example: true
    [System.Nullable[bool]] $IsTemplate

    # Indicates whether the repository is a fork.
    # Example: false
    [System.Nullable[bool]] $IsFork

    # License information for the repository.
    # Example: 'MIT License', 'Mozilla Public License 2.0'
    [GitHubLicense] $License

    # Whether to allow forking this repository.
    # Example: true
    [System.Nullable[bool]] $AllowForking

    # Whether to require contributors to sign off on web-based commits
    # Example: false
    [System.Nullable[bool]] $RequireWebCommitSignoff

    # The topics associated with the repository.
    # Example: @()
    [string[]] $Topics

    # The visibility of the repository (public, private, or internal).
    # Example: public
    [string] $Visibility

    # The number of open issues.
    # Example: 15
    [System.Nullable[uint]] $OpenIssues

    # The number of open pull requests.
    # Example: 15
    [System.Nullable[uint]] $OpenPullRequests

    # The number of stargazers.
    # Example: 80
    [System.Nullable[uint]] $Stargazers

    # The number of watchers.
    # Example: 80
    [System.Nullable[uint]] $Watchers

    # The number of forks.
    # Example: 9
    [System.Nullable[uint]] $Forks

    # The default branch of the repository.
    # Example: main
    [string] $DefaultBranch

    # Permission on the repository.
    # Example: 'Admin'
    [string] $Permission

    # Whether to allow squash merges for pull requests.
    # Example: true
    [System.Nullable[bool]] $AllowSquashMerge

    # Whether to allow merge commits for pull requests.
    # Example: true
    [System.Nullable[bool]] $AllowMergeCommit

    # Whether to allow rebase merges for pull requests.
    # Example: true
    [System.Nullable[bool]] $AllowRebaseMerge

    # Whether to allow auto-merge on pull requests.
    # Example: false
    [System.Nullable[bool]] $AllowAutoMerge

    # Whether to delete head branches when pull requests are merged.
    # Example: false
    [System.Nullable[bool]] $DeleteBranchOnMerge

    # Whether a pull request head branch is suggested to be updated if behind its base branch.
    # Example: false
    [System.Nullable[bool]] $SuggestUpdateBranch

    # The default value for a squash merge commit title.
    # Enum: PR_TITLE, COMMIT_OR_PR_TITLE
    # Example: PR_TITLE
    [string] $SquashMergeCommitTitle

    # The default value for a squash merge commit message.
    # Enum: PR_BODY, COMMIT_MESSAGES, BLANK
    # Example: PR_BODY
    [string] $SquashMergeCommitMessage

    # The default value for a merge commit title.
    # Enum: PR_TITLE, MERGE_MESSAGE
    # Example: PR_TITLE
    [string] $MergeCommitTitle

    # The default value for a merge commit message.
    # Enum: PR_BODY, PR_TITLE, BLANK
    # Example: PR_TITLE
    [string] $MergeCommitMessage

    # The template repository that this repository was created from
    [GithubRepository] $TemplateRepository

    # The repository this repository was forked from.
    [GithubRepository] $ForkRepository

    # Custom properties for the repository.
    [PSCustomObject] $CustomProperties

    # The clone URL of the repository.
    # Example: git://github.com/octocat/Hello-World.git
    [string] $CloneUrl

    # The SSH URL of the repository.
    # Example: git@github.com:octocat/Hello-World.git
    [string] $SshUrl

    # The Git URL of the repository.
    # Example: https://github.com/octocat/Hello-World.git
    [string] $GitUrl

    # Mapping of property names to GitHub GraphQL query syntax
    static [hashtable] $PropertyToGraphQLMap = @{
        Name                     = 'name'
        Owner                    = 'owner { login }'
        FullName                 = 'name', 'owner { login }'
        Url                      = 'url'
        Description              = 'description'
        CreatedAt                = 'createdAt'
        UpdatedAt                = 'updatedAt'
        PushedAt                 = 'pushedAt'
        ArchivedAt               = 'archivedAt'
        Homepage                 = 'homepageUrl'
        Size                     = 'diskUsage'
        Language                 = 'primaryLanguage { name id color }'
        HasIssues                = 'hasIssuesEnabled'
        HasProjects              = 'hasProjectsEnabled'
        HasWiki                  = 'hasWikiEnabled'
        HasDiscussions           = 'hasDiscussionsEnabled'
        HasSponsorships          = 'hasSponsorshipsEnabled'
        IsArchived               = 'isArchived'
        IsTemplate               = 'isTemplate'
        IsFork                   = 'isFork'
        License                  = 'licenseInfo { name }'
        AllowForking             = 'forkingAllowed'
        RequireWebCommitSignoff  = 'webCommitSignoffRequired'
        Topics                   = 'repositoryTopics(first: 20) { nodes { topic { name } } }'
        Visibility               = 'visibility'
        OpenIssues               = 'issues { totalCount }'
        OpenPullRequests         = 'pullRequests { totalCount }'
        Stargazers               = 'stargazers { totalCount }'
        Watchers                 = 'watchers { totalCount }'
        Forks                    = 'forks { totalCount }'
        DefaultBranch            = 'defaultBranchRef { name }'
        Permission               = 'viewerPermission'
        AllowSquashMerge         = 'squashMergeAllowed'
        AllowMergeCommit         = 'mergeCommitAllowed'
        AllowRebaseMerge         = 'rebaseMergeAllowed'
        AllowAutoMerge           = 'autoMergeAllowed'
        DeleteBranchOnMerge      = 'deleteBranchOnMerge'
        SuggestUpdateBranch      = 'allowUpdateBranch'
        SquashMergeCommitTitle   = 'squashMergeCommitTitle'
        SquashMergeCommitMessage = 'squashMergeCommitMessage'
        MergeCommitTitle         = 'mergeCommitTitle'
        MergeCommitMessage       = 'mergeCommitMessage'
        TemplateRepository       = 'templateRepository { id databaseId name owner { login } }'
        ForkRepository           = 'parent { id databaseId name owner { login }  }'
        CustomProperties         = ''
        CloneUrl                 = 'url'
        SshUrl                   = 'sshUrl'
        GitUrl                   = 'url'
        NodeID                   = 'id'
        ID                       = 'databaseId'
    }

    GitHubRepository() {}

    GitHubRepository([PSCustomObject]$Object) {
        if ($null -ne $Object.node_id) {
            $this.ID = $Object.id
            $this.NodeID = $Object.node_id
            $this.Name = $Object.name
            $this.Owner = [GitHubOwner]::New($Object.owner)
            $this.FullName = $Object.full_name
            $this.Visibility = $Object.visibility ? (Get-Culture).TextInfo.ToTitleCase($Object.visibility.ToLower()) : $null
            $this.Description = $Object.description
            $this.Homepage = $Object.homepage
            $this.Url = $Object.html_url
            $this.Size = $Object.size
            $this.Language = [GitHubRepositoryLanguage]::new($Object.language)
            $this.IsFork = $Object.fork
            $this.IsArchived = $Object.archived
            $this.IsTemplate = $Object.is_template
            $this.HasIssues = $Object.has_issues
            $this.HasProjects = $Object.has_projects
            $this.HasWiki = $Object.has_wiki
            $this.HasDiscussions = $Object.has_discussions
            $this.HasPages = $Object.has_pages
            $this.AllowForking = $Object.allow_forking
            $this.License = [GitHubLicense]::New($Object.license)
            $this.RequireWebCommitSignoff = $Object.web_commit_signoff_required
            $this.CreatedAt = $Object.created_at
            $this.UpdatedAt = $Object.created_at
            $this.PushedAt = $Object.pushed_at
            $this.Topics = $Object.topics
            $this.Forks = $Object.forks_count
            $this.OpenIssues = $Object.open_issues_count
            $this.Watchers = $Object.watchers_count
            $this.Stargazers = $Object.stargazers_count
            $this.DefaultBranch = $Object.default_branch
            $this.Permission = [GitHubRepositoryPermission]::GetPermissionString($Object.permissions)
            $this.AllowSquashMerge = $Object.allow_squash_merge
            $this.AllowMergeCommit = $Object.allow_merge_commit
            $this.AllowRebaseMerge = $Object.allow_rebase_merge
            $this.AllowAutoMerge = $Object.allow_auto_merge
            $this.DeleteBranchOnMerge = $Object.delete_branch_on_merge
            $this.SuggestUpdateBranch = $Object.allow_update_branch
            $this.SquashMergeCommitMessage = $Object.squash_merge_commit_message
            $this.SquashMergeCommitTitle = $Object.squash_merge_commit_title
            $this.MergeCommitMessage = $Object.merge_commit_message
            $this.MergeCommitTitle = $Object.merge_commit_title
            $this.CustomProperties = $Object.custom_properties
            $this.TemplateRepository = $null -ne $Object.template_repository ? [GitHubRepository]::New($Object.template_repository) : $null
            $this.ForkRepository = $null -ne $Object.parent ? [GitHubRepository]::New($Object.parent) : $null
            $this.CloneUrl = $Object.clone_url
            $this.SshUrl = $Object.ssh_url
            $this.GitUrl = $Object.git_url
        } else {
            $this.ID = $Object.databaseId
            $this.NodeID = $Object.id
            $this.Name = $Object.name
            $this.Owner = [GitHubOwner]::New($Object.owner)
            if (-not ([string]::IsNullOrEmpty($this.Owner) -or [string]::IsNullOrEmpty($this.Name))) {
                $this.FullName = "$($this.Owner)/$($this.Name)"
            }
            $this.Url = $Object.url
            $this.Description = $Object.description
            $this.CreatedAt = $Object.createdAt
            $this.UpdatedAt = $Object.updatedAt
            $this.PushedAt = $Object.pushedAt
            $this.ArchivedAt = $Object.archivedAt
            $this.Homepage = $Object.homepageUrl
            $this.Size = $Object.diskUsage
            $this.Language = [GitHubRepositoryLanguage]::new($Object.primaryLanguage)
            $this.HasIssues = $Object.hasIssuesEnabled
            $this.HasProjects = $Object.hasProjectsEnabled
            $this.HasWiki = $Object.hasWikiEnabled
            $this.HasDiscussions = $Object.hasDiscussionsEnabled
            $this.HasSponsorships = $Object.hasSponsorshipsEnabled
            $this.IsArchived = $Object.isArchived
            $this.IsTemplate = $Object.isTemplate
            $this.IsFork = $Object.isFork
            $this.License = [GitHubLicense]::new($Object.licenseInfo)
            $this.AllowForking = $Object.forkingAllowed
            $this.RequireWebCommitSignoff = $Object.webCommitSignoffRequired
            $this.Topics = $Object.repositoryTopics.nodes.topic.name
            $this.Visibility = $Object.visibility ? (Get-Culture).TextInfo.ToTitleCase($Object.visibility.ToLower()) : $null
            $this.OpenIssues = $Object.issues.totalCount
            $this.OpenPullRequests = $Object.pullRequests.totalCount
            $this.Stargazers = $Object.stargazers.totalCount
            $this.Watchers = $Object.watchers.totalCount
            $this.Forks = $Object.forks.totalCount
            $this.DefaultBranch = $Object.defaultBranchRef.name
            $this.Permission = [GitHubRepositoryPermission]::GetPermissionString($Object.viewerPermission)
            $this.AllowSquashMerge = $Object.squashMergeAllowed
            $this.AllowMergeCommit = $Object.mergeCommitAllowed
            $this.AllowRebaseMerge = $Object.rebaseMergeAllowed
            $this.AllowAutoMerge = $Object.autoMergeAllowed
            $this.DeleteBranchOnMerge = $Object.deleteBranchOnMerge
            $this.SuggestUpdateBranch = $Object.allowUpdateBranch
            $this.SquashMergeCommitTitle = $Object.squashMergeCommitTitle
            $this.SquashMergeCommitMessage = $Object.squashMergeCommitMessage
            $this.MergeCommitTitle = $Object.mergeCommitTitle
            $this.MergeCommitMessage = $Object.mergeCommitMessage
            $this.TemplateRepository = $null -ne $Object.templateRepository ? [GitHubRepository]::New($Object.templateRepository) : $null
            $this.ForkRepository = $null -ne $Object.parent ? [GitHubRepository]::New($Object.parent) : $null
            $this.CloneUrl = -not [string]::IsNullOrEmpty($Object.url) ? $Object.url + '.git' : $null
            $this.SshUrl = $Object.sshUrl
            $this.GitUrl = -not [string]::IsNullOrEmpty($Object.url) ? ($Object.Url + '.git').Replace('https://', 'git://') : $null
        }
    }

    [string] ToString() {
        return $this.Name
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Repositories] - [GitHubRepository] - Done"
#endregion [classes] - [public] - [Repositories] - [GitHubRepository]
#region    [classes] - [public] - [Repositories] - [GitHubRepositoryLanguage]
Write-Debug "[$scriptName] - [classes] - [public] - [Repositories] - [GitHubRepositoryLanguage] - Importing"
class GitHubRepositoryLanguage {
    # The name of the language.
    [string] $Name

    # The Node ID of the Language object.
    [string] $ID

    # The color defined for the current language.
    [string] $Color

    GitHubRepositoryLanguage() {}

    GitHubRepositoryLanguage([pscustomobject] $Object) {
        $this.Name = $Object.name
        $this.ID = $Object.id
        $this.Color = $Object.color
    }

    GitHubRepositoryLanguage([string] $Name) {
        $this.Name = $Name
    }

    [string] ToString() {
        return $this.Name
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Repositories] - [GitHubRepositoryLanguage] - Done"
#endregion [classes] - [public] - [Repositories] - [GitHubRepositoryLanguage]
#region    [classes] - [public] - [Repositories] - [GitHubRepositoryPermission]
Write-Debug "[$scriptName] - [classes] - [public] - [Repositories] - [GitHubRepositoryPermission] - Importing"
class GitHubRepositoryPermission {
    # Full control over the repository, including managing settings and access. Can delete the repository and change roles for others.
    [System.Nullable[bool]] $Admin

    # Has elevated permissions to manage repository settings (e.g., branches, webhooks). Cannot delete the repository or manage its access.
    [System.Nullable[bool]] $Maintain

    # Can push code and manage issues and pull requests. Cannot manage repository settings or permissions.
    # Alias "Write"
    [System.Nullable[bool]] $Push

    # Can manage issues and pull requests (label, assign, close, etc.). Cannot push code or change repository settings.
    [System.Nullable[bool]] $Triage

    # Can view and clone the repository. Cannot push code or manage issues and pull requests.
    # Alias "Read"
    [System.Nullable[bool]] $Pull

    GitHubRepositoryPermission() {}

    GitHubRepositoryPermission([PSCustomObject]$Object) {
        $this.Admin = $Object.admin
        $this.Maintain = $Object.maintain
        $this.Push = $Object.push
        $this.Triage = $Object.triage
        $this.Pull = $Object.pull
    }

    GitHubRepositoryPermission([string]$Permission) {
        $Permission = $Permission.ToLower()
        if ($Permission -eq 'admin') {
            $this.Admin = $true
        } elseif ($Permission -eq 'maintain') {
            $this.Maintain = $true
        } elseif ($Permission -in ('push', 'write')) {
            $this.Push = $true
        } elseif ($Permission -eq 'triage') {
            $this.Triage = $true
        } elseif ($Permission -in ('pull', 'read')) {
            $this.Pull = $true
        }
    }

    # Output the highest permission level as a string.
    # The order of permissions is: Admin > Maintain > Push > Triage > Pull
    [string] ToString() {
        if ($this.Admin) {
            return 'Admin'
        } elseif ($this.Maintain) {
            return 'Maintain'
        } elseif ($this.Push) {
            return 'Push'
        } elseif ($this.Triage) {
            return 'Triage'
        } elseif ($this.Pull) {
            return 'Pull'
        }
        return $null
    }

    static [string] GetPermissionString([PSCustomObject]$Permission) {
        if ($Permission.Admin) {
            return 'Admin'
        } elseif ($Permission.Maintain) {
            return 'Maintain'
        } elseif ($Permission.Push) {
            return 'Push'
        } elseif ($Permission.Triage) {
            return 'Triage'
        } elseif ($Permission.Pull) {
            return 'Pull'
        }
        return $null
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Repositories] - [GitHubRepositoryPermission] - Done"
#endregion [classes] - [public] - [Repositories] - [GitHubRepositoryPermission]
Write-Debug "[$scriptName] - [classes] - [public] - [Repositories] - Done"
#endregion [classes] - [public] - [Repositories]
#region    [classes] - [public] - [Secrets]
Write-Debug "[$scriptName] - [classes] - [public] - [Secrets] - Processing folder"
#region    [classes] - [public] - [Secrets] - [GitHubPublicKey]
Write-Debug "[$scriptName] - [classes] - [public] - [Secrets] - [GitHubPublicKey] - Importing"
class GitHubPublicKey {
    # The key ID of the public key.
    [string] $ID

    # The public key used to encrypt secrets.
    [string] $Key

    # The type of Public Key.
    [string] $Type

    # The name of the organization or user the Public Key is associated with.
    [string] $Owner

    # The name of the repository the Public Key is associated with.
    [string] $Repository

    # The name of the environment the Public Key is associated with.
    [string] $Environment

    GitHubPublicKey() {}

    GitHubPublicKey([PSCustomObject]$Object, [string]$Type, [string]$Owner, [string]$Repository, [string]$Environment) {
        $this.ID = $Object.key_id
        $this.Key = $Object.key
        $this.Type = $Type
        $this.Owner = $Owner
        $this.Repository = $Repository
        $this.Environment = $Environment
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Secrets] - [GitHubPublicKey] - Done"
#endregion [classes] - [public] - [Secrets] - [GitHubPublicKey]
#region    [classes] - [public] - [Secrets] - [GitHubSecret]
Write-Debug "[$scriptName] - [classes] - [public] - [Secrets] - [GitHubSecret] - Importing"
class GitHubSecret {
    # The key ID of the public key.
    [string] $Name

    # The scope of the variable, organization, repository, or environment.
    [string] $Scope

    # The name of the organization or user the Public Key is associated with.
    [string] $Owner

    # The name of the repository the Public Key is associated with.
    [string] $Repository

    # The name of the environment the Public Key is associated with.
    [string] $Environment

    # The date and time the variable was created.
    [datetime] $CreatedAt

    # The date and time the variable was last updated.
    [datetime] $UpdatedAt

    # The visibility of the variable.
    [string] $Visibility

    # The ids of the repositories that the variable is visible to.
    [GitHubRepository[]] $SelectedRepositories

    GitHubSecret() {}

    GitHubSecret([PSCustomObject]$Object, [string]$Owner, [string]$Repository, [string]$Environment, [GitHubRepository[]]$SelectedRepositories) {
        $this.Name = $Object.name
        $this.Owner = $Owner
        $this.Repository = $Repository
        $this.Environment = $Environment
        $this.CreatedAt = $Object.created_at
        $this.UpdatedAt = $Object.updated_at
        $this.Visibility = $Object.visibility
        $this.SelectedRepositories = $SelectedRepositories

        #Set scope based on provided values in Owner, Repository, Environment
        $this.Scope = if ($Owner -and $Repository -and $Environment) {
            'Environment'
        } elseif ($Owner -and $Repository) {
            'Repository'
        } elseif ($Owner) {
            'Organization'
        } else {
            'Unknown'
        }
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Secrets] - [GitHubSecret] - Done"
#endregion [classes] - [public] - [Secrets] - [GitHubSecret]
Write-Debug "[$scriptName] - [classes] - [public] - [Secrets] - Done"
#endregion [classes] - [public] - [Secrets]
#region    [classes] - [public] - [Teams]
Write-Debug "[$scriptName] - [classes] - [public] - [Teams] - Processing folder"
#region    [classes] - [public] - [Teams] - [GitHubTeam]
Write-Debug "[$scriptName] - [classes] - [public] - [Teams] - [GitHubTeam] - Importing"
class GitHubTeam : GitHubNode {
    # The name of the team.
    [string] $Name

    # The slug of the team.
    [string] $Slug

    # The organization the team belongs to.
    [string] $Organization

    # The description of the team.
    [string] $Description

    # The HTML URL of the team.
    # Example: https://github.com/orgs/github/teams/justice-league
    [string] $Url

    # The notification setting the team has chosen.
    # $true = notifications_enabled - team members receive notifications when the team is @mentioned.
    # $false = notifications_disabled - no one receives notifications.
    [System.Nullable[bool]] $Notifications

    # The privacy setting of the team.
    # $true = closed - visible to all members of this organization.
    # $false = secret - only visible to organization owners and members of this team.
    [System.Nullable[bool]] $Visible

    # The permission level of the team on a repository.
    # Example: 'Push'
    [string] $Permission

    GitHubTeam() {}

    GitHubTeam([PSCustomObject]$Object, [string]$Organization) {
        $this.ID = $Object.id
        $this.NodeID = $Object.node_id
        $this.Name = $Object.name
        $this.Slug = $Object.slug
        $this.Organization = $Organization
        $this.Description = $Object.description
        $this.Url = $Object.html_url
        $this.Notifications = $Object.notification_setting -eq 'notifications_enabled' ? $true : $false
        $this.Visible = $Object.privacy -eq 'closed' ? $true : $false
        $this.Permission = [GitHubRepositoryPermission]::GetPermissionString($Object.permissions)
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Teams] - [GitHubTeam] - Done"
#endregion [classes] - [public] - [Teams] - [GitHubTeam]
Write-Debug "[$scriptName] - [classes] - [public] - [Teams] - Done"
#endregion [classes] - [public] - [Teams]
#region    [classes] - [public] - [Variables]
Write-Debug "[$scriptName] - [classes] - [public] - [Variables] - Processing folder"
#region    [classes] - [public] - [Variables] - [GitHubVariable]
Write-Debug "[$scriptName] - [classes] - [public] - [Variables] - [GitHubVariable] - Importing"
class GitHubVariable {
    # The name of the variable.
    [string] $Name

    # The value of the variable.
    [string] $Value

    # The scope of the variable, organization, repository, or environment.
    [string] $Scope

    # The name of the organization or user the variable is associated with.
    [string] $Owner

    # The name of the repository the variable is associated with.
    [string] $Repository

    # The name of the environment the variable is associated with.
    [string] $Environment

    # The date and time the variable was created.
    [datetime] $CreatedAt

    # The date and time the variable was last updated.
    [datetime] $UpdatedAt

    # The visibility of the variable.
    [string] $Visibility

    # The ids of the repositories that the variable is visible to.
    [GitHubRepository[]] $SelectedRepositories

    GitHubVariable() {}

    GitHubVariable([PSCustomObject]$Object, [string]$Owner, [string]$Repository, [string]$Environment, [GitHubRepository[]]$SelectedRepositories) {
        $this.Name = $Object.name
        $this.Value = $Object.value
        $this.Owner = $Owner
        $this.Repository = $Repository
        $this.Environment = $Environment
        $this.CreatedAt = $Object.created_at
        $this.UpdatedAt = $Object.updated_at
        $this.Visibility = $Object.visibility
        $this.SelectedRepositories = $SelectedRepositories

        #Set scope based on provided values in Owner, Repository, Environment
        $this.Scope = if ($Owner -and $Repository -and $Environment) {
            'Environment'
        } elseif ($Owner -and $Repository) {
            'Repository'
        } elseif ($Owner) {
            'Organization'
        } else {
            'Unknown'
        }
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Variables] - [GitHubVariable] - Done"
#endregion [classes] - [public] - [Variables] - [GitHubVariable]
Write-Debug "[$scriptName] - [classes] - [public] - [Variables] - Done"
#endregion [classes] - [public] - [Variables]
#region    [classes] - [public] - [Webhooks]
Write-Debug "[$scriptName] - [classes] - [public] - [Webhooks] - Processing folder"
#region    [classes] - [public] - [Webhooks] - [GitHubWebhookConfiguration]
Write-Debug "[$scriptName] - [classes] - [public] - [Webhooks] - [GitHubWebhookConfiguration] - Importing"
class GitHubWebhookConfiguration {
    # The content type of the webhook
    [string]$ContentType

    # Indicates whether the webhook uses SSL
    [System.Nullable[bool]]$UseSsl

    # The secret token for the webhook
    [string]$Secret

    # The URL of the webhook
    [string]$Url

    GitHubWebhookConfiguration([PSCustomObject] $Object) {
        $this.ContentType = $Object.content_type
        $this.UseSsl = -not [bool]$Object.insecure_ssl
        $this.Secret = $Object.secret
        $this.Url = $Object.url
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Webhooks] - [GitHubWebhookConfiguration] - Done"
#endregion [classes] - [public] - [Webhooks] - [GitHubWebhookConfiguration]
#region    [classes] - [public] - [Webhooks] - [GitHubWebhookDelivery]
Write-Debug "[$scriptName] - [classes] - [public] - [Webhooks] - [GitHubWebhookDelivery] - Importing"
class GitHubWebhookDelivery {
    # Unique identifier of the delivery.
    [uint64] $ID

    # Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
    [string] $GUID

    # Time when the delivery was delivered.
    [System.Nullable[datetime]] $DeliveredAt

    # Whether the delivery is a redelivery.
    [System.Nullable[boolean]] $Redelivery

    # Time spent delivering, in seconds.
    [System.Nullable[double]] $Duration

    # Description of the status of the attempted delivery
    [string] $Status

    # Status code received when delivery was made.
    [uint16] $StatusCode

    # The event that triggered the delivery.
    [string] $Event

    # The type of activity for the event that triggered the delivery.
    [string] $Action

    # The id of the GitHub App installation associated with this event.
    [System.Nullable[uint64]] $InstallationID

    # The id of the repository associated with this event.
    [System.Nullable[uint64]] $RepositoryID

    # Time when the webhook delivery was throttled.
    [System.Nullable[datetime]] $ThrottledAt

    # The URL target of the delivery.
    [string] $Url

    # The request for the delivery.
    [object] $Request

    # The response from the delivery.
    [object] $Response

    # Number of attempts to deliver the webhook.
    [System.Nullable[int]] $Attempts

    GitHubWebhookDelivery() {}

    GitHubWebhookDelivery([PSCustomObject]$Object) {
        $this.ID = $Object.id
        $this.GUID = $Object.guid
        $this.DeliveredAt = $Object.delivered_at
        $this.Redelivery = $Object.redelivery
        $this.Duration = $Object.duration
        $this.Status = $Object.status
        $this.StatusCode = $Object.status_code
        $this.Event = $Object.event
        $this.Action = $Object.action
        $this.InstallationID = $Object.installation.id
        $this.RepositoryID = $Object.repository.id
        $this.ThrottledAt = $Object.throttled_at
        $this.Url = $Object.url
        $this.Request = $Object.request
        $this.Response = $Object.response

    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Webhooks] - [GitHubWebhookDelivery] - Done"
#endregion [classes] - [public] - [Webhooks] - [GitHubWebhookDelivery]
Write-Debug "[$scriptName] - [classes] - [public] - [Webhooks] - Done"
#endregion [classes] - [public] - [Webhooks]
#region    [classes] - [public] - [Workflows]
Write-Debug "[$scriptName] - [classes] - [public] - [Workflows] - Processing folder"
#region    [classes] - [public] - [Workflows] - [GitHubWorkflow]
Write-Debug "[$scriptName] - [classes] - [public] - [Workflows] - [GitHubWorkflow] - Importing"
class GitHubWorkflow : GitHubNode {
    # The name of the workflow.
    [string] $Name

    # The name of the organization or user the variable is associated with.
    [string] $Owner

    # The name of the repository the variable is associated with.
    [string] $Repository

    # The path to the workflow file.
    [string] $Path

    # The current state of the workflow (e.g., active/inactive).
    [string] $State

    # The timestamp when the workflow was created.
    [System.Nullable[datetime]] $CreatedAt

    # The timestamp when the workflow was last updated.
    [System.Nullable[datetime]] $UpdatedAt

    # The timestamp when the workflow was last updated.
    [System.Nullable[datetime]] $DeletedAt

    # The GitHub URL for viewing the workflow.
    [string] $Url

    # The badge URL for this workflow's status.
    [string] $BadgeUrl

    GitHubWorkflow() {}

    GitHubWorkflow([PSCustomObject] $Object, [string] $Owner, [string] $Repository) {
        $this.ID = $Object.id
        $this.NodeID = $Object.node_id
        $this.Name = $Object.name
        $this.Owner = $Owner
        $this.Repository = $Repository
        $this.Path = $Object.path
        $this.State = $Object.state
        $this.CreatedAt = $Object.created_at
        $this.UpdatedAt = $Object.updated_at
        $this.DeletedAt = $Object.deleted_at
        $this.Url = $Object.html_url
        $this.BadgeUrl = $Object.badge_url
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Workflows] - [GitHubWorkflow] - Done"
#endregion [classes] - [public] - [Workflows] - [GitHubWorkflow]
#region    [classes] - [public] - [Workflows] - [GitHubWorkflowRun]
Write-Debug "[$scriptName] - [classes] - [public] - [Workflows] - [GitHubWorkflowRun] - Importing"
class GitHubWorkflowRun : GitHubNode {
    # The name of the workflow run.
    # Example: "Build"
    [string] $Name

    # The name of the organization or user the variable is associated with.
    # Example: "octocat"
    [string] $Owner

    # The name of the repository the variable is associated with.
    # Example: "hello-world"
    [string] $Repository

    # The ID of the associated check suite.
    # Example: 42
    [System.Nullable[UInt64]] $CheckSuiteID

    # The node ID of the associated check suite.
    # Example: "MDEwOkNoZWNrU3VpdGU0Mg=="
    [string] $CheckSuiteNodeID

    # The branch name of the head commit.
    # Example: "master"
    [string] $HeadBranch

    # The SHA of the head commit that points to the version of the workflow being run.
    # Example: "009b8a3a9ccbb128af87f9b1c0f4c62e8a304f6d"
    [string] $HeadSha

    # The full path of the workflow.
    # Example: "octocat/octo-repo/.github/workflows/ci.yml@main"
    [string] $Path

    # The auto incrementing run number for the workflow run.
    # Example: 106
    [UInt64] $RunNumber

    # Attempt number of the run, 1 for first attempt and higher if the workflow was re-run.
    # Example: 1
    [uint] $RunAttempt

    # Array of referenced workflows.
    # Example: (array of objects, nullable)
    [PSCustomObject[]] $ReferencedWorkflows

    # The event that triggered the workflow run.
    # Example: "push"
    [string] $Event

    # The current status of the workflow run.
    # Example: "completed"
    [string] $Status

    # The conclusion of the workflow run.
    # Example: "neutral"
    [string] $Conclusion

    # The ID of the parent workflow.
    # Example: 5
    [UInt64] $WorkflowID

    # The HTML URL to view the workflow run.
    # Example: "https://github.com/github/hello-world/suites/4"
    [string] $Url

    # Pull requests associated with the workflow run.
    # Example: (array of pull request objects, nullable)
    [PSCustomObject[]] $PullRequests

    # The creation timestamp of the workflow run.
    # Example: "2023-01-01T12:00:00Z"
    [System.Nullable[datetime]] $CreatedAt

    # The last updated timestamp of the workflow run.
    # Example: "2023-01-01T12:05:00Z"
    [System.Nullable[datetime]] $UpdatedAt

    # The user who triggered the workflow run.
    # Example: (simple-user object)
    [GitHubUser] $Actor

    # The user who actually triggered the workflow run (may differ from Actor).
    # Example: (simple-user object)
    [GitHubUser] $TriggeringActor

    # The start time of the latest run. Resets on re-run.
    # Example: "2023-01-01T12:01:00Z"
    [System.Nullable[datetime]] $StartedAt

    # The head commit details.
    # Example: (nullable-simple-commit object)
    [PSCustomObject] $HeadCommit

    # The head repository of the workflow run.
    # Example: (minimal-repository object)
    [GitHubRepository] $HeadRepository

    # The event-specific title associated with the run or the run-name if set.
    # Example: "Simple Workflow"
    [string] $DisplayTitle

    GitHubWorkflowRun() {}

    GitHubWorkflowRun([PSCustomObject] $Object) {
        # From GitHubNode
        $this.ID = $_.id
        $this.NodeID = $_.node_id

        # From GitHubWorkflowRun
        $this.Name = $_.name
        $this.Owner = [GitHubOwner]::new($Object.repository.owner)
        $this.Repository = [GitHubRepository]::new($Object.repository)
        $this.CheckSuiteID = $_.check_suite_id
        $this.CheckSuiteNodeID = $_.check_suite_node_id
        $this.HeadBranch = $_.head_branch
        $this.HeadSha = $_.head_sha
        $this.Path = $_.path
        $this.RunNumber = $_.run_number
        $this.RunAttempt = $_.run_attempt
        $this.ReferencedWorkflows = $_.referenced_workflows
        $this.Event = $_.event
        $this.Status = $_.status
        $this.Conclusion = $_.conclusion
        $this.WorkflowID = $_.workflow_id
        $this.Url = $_.html_url
        $this.PullRequests = $_.pull_requests
        $this.CreatedAt = $_.created_at
        $this.UpdatedAt = $_.updated_at
        $this.StartedAt = $_.run_started_at
        $this.Actor = [GitHubUser]::new($_.actor)
        $this.TriggeringActor = [GitHubUser]::new($_.triggering_actor)
        $this.HeadCommit = $_.head_commit
        $this.HeadRepository = [GitHubRepository]::new($_.head_repository)
        $this.DisplayTitle = $_.display_title
    }
}
Write-Debug "[$scriptName] - [classes] - [public] - [Workflows] - [GitHubWorkflowRun] - Done"
#endregion [classes] - [public] - [Workflows] - [GitHubWorkflowRun]
Write-Debug "[$scriptName] - [classes] - [public] - [Workflows] - Done"
#endregion [classes] - [public] - [Workflows]
Write-Debug "[$scriptName] - [classes] - [public] - Done"
#endregion [classes] - [public]
#region    [functions] - [private]
Write-Debug "[$scriptName] - [functions] - [private] - Processing folder"
#region    [functions] - [private] - [Actions]
Write-Debug "[$scriptName] - [functions] - [private] - [Actions] - Processing folder"
#region    [functions] - [private] - [Actions] - [Import-GitHubEventData]
Write-Debug "[$scriptName] - [functions] - [private] - [Actions] - [Import-GitHubEventData] - Importing"
#Requires -Modules @{ ModuleName = 'CasingStyle'; RequiredVersion = '1.0.2' }

function Import-GitHubEventData {
    <#
        .SYNOPSIS
        Import data from the event that triggered the workflow.

        .DESCRIPTION
        Import data from the event that triggered the workflow.

        .EXAMPLE
        Import-GitHubEventData
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseShouldProcessForStateChangingFunctions', '',
        Justification = 'Just setting a value in a variable.'
    )]
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param()

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $gitHubEventJson = Get-Content -Path $env:GITHUB_EVENT_PATH
        $gitHubEvent = $gitHubEventJson | ConvertFrom-Json

        $eventAction = $gitHubEvent.action
        $eventSender = $gitHubEvent.sender | Select-Object -Property login, type, id, node_id, html_url
        $eventEnterprise = $gitHubEvent.enterprise | Select-Object -Property name, slug, id, node_id, html_url
        $eventOrganization = $gitHubEvent.organization | Select-Object -Property login, id, node_id
        $eventOwner = $gitHubEvent.repository.owner | Select-Object -Property login, type, id, node_id, html_url
        $eventRepository = $gitHubEvent.repository | Select-Object -Property name, full_name, html_url, id, node_id, default_branch

        $gitHubEvent = $gitHubEvent | Select-Object -ExcludeProperty action, sender, enterprise, organization, repository

        $hashtable = @{}
        $gitHubEvent.PSObject.Properties | ForEach-Object {
            $name = $_.Name
            $name = $name | ConvertTo-CasingStyle -To PascalCase
            $hashtable[$name] = $_.Value
        }
        $gitHubEvent = [pscustomobject]$hashtable

        $gitHubEvent | Add-Member -MemberType NoteProperty -Name Type -Value $env:GITHUB_EVENT_NAME -Force
        if ($eventAction) {
            $gitHubEvent | Add-Member -MemberType NoteProperty -Name Action -Value $eventAction -Force
        }
        if ($eventSender) {
            $gitHubEvent | Add-Member -MemberType NoteProperty -Name Sender -Value $eventSender -Force
        }
        if ($eventEnterprise) {
            $gitHubEvent | Add-Member -MemberType NoteProperty -Name Enterprise -Value $eventEnterprise -Force
        }
        if ($eventOrganization) {
            $gitHubEvent | Add-Member -MemberType NoteProperty -Name Organization -Value $eventOrganization -Force
        }
        if ($eventOwner) {
            $gitHubEvent | Add-Member -MemberType NoteProperty -Name Owner -Value $eventOwner -Force
        }
        if ($eventRepository) {
            $gitHubEvent | Add-Member -MemberType NoteProperty -Name Repository -Value $eventRepository -Force
        }
        $script:GitHub.Event = $gitHubEvent
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Actions] - [Import-GitHubEventData] - Done"
#endregion [functions] - [private] - [Actions] - [Import-GitHubEventData]
#region    [functions] - [private] - [Actions] - [Import-GitHubRunnerData]
Write-Debug "[$scriptName] - [functions] - [private] - [Actions] - [Import-GitHubRunnerData] - Importing"
function Import-GitHubRunnerData {
    <#
        .SYNOPSIS
        Import data about the runner that is running the workflow.

        .DESCRIPTION
        Import data about the runner that is running the workflow.

        .EXAMPLE
        Import-GitHubRunnerData
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseShouldProcessForStateChangingFunctions', '',
        Justification = 'Just setting a value in a variable.'
    )]
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param()

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $script:GitHub.Runner = [pscustomobject]@{
            Name        = $env:RUNNER_NAME
            OS          = $env:RUNNER_OS
            Arch        = $env:RUNNER_ARCH
            Environment = $env:RUNNER_ENVIRONMENT
            Temp        = $env:RUNNER_TEMP
            Perflog     = $env:RUNNER_PERFLOG
            ToolCache   = $env:RUNNER_TOOL_CACHE
            TrackingID  = $env:RUNNER_TRACKING_ID
            Workspace   = $env:RUNNER_WORKSPACE
            Processors  = [System.Environment]::ProcessorCount
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Actions] - [Import-GitHubRunnerData] - Done"
#endregion [functions] - [private] - [Actions] - [Import-GitHubRunnerData]
#region    [functions] - [private] - [Actions] - [Workflow Run]
Write-Debug "[$scriptName] - [functions] - [private] - [Actions] - [Workflow Run] - Processing folder"
#region    [functions] - [private] - [Actions] - [Workflow Run] - [Get-GitHubWorkflowRunByRepo]
Write-Debug "[$scriptName] - [functions] - [private] - [Actions] - [Workflow Run] - [Get-GitHubWorkflowRunByRepo] - Importing"
filter Get-GitHubWorkflowRunByRepo {
    <#
        .SYNOPSIS
        List workflow runs for a repository.

        .DESCRIPTION
        Lists all workflow runs for a repository. You can use parameters to narrow the list of results. For more information about using parameters,
        see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).
        Anyone with read access to the repository can use this endpoint.
        OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
        This endpoint will return up to 1,000 results for each search when using the following parameters: `actor`, `branch`, `check_suite_id`,
        `created`, `event`, `head_sha`, `status`.

        .EXAMPLE
        Get-GitHubWorkflowRunByRepo -Owner 'owner' -Repository 'repo'

        Lists all workflow runs for a repository.

        .EXAMPLE
        Get-GitHubWorkflowRunByRepo -Owner 'owner' -Repository 'repo' -Actor 'octocat' -Branch 'main' -Event 'push' -Status 'success'

        Lists all workflow runs for a repository with the specified actor, branch, event, and status.

        .OUTPUTS
        GitHubWorkflowRun

        .NOTES
        [List workflow runs for a repository](https://docs.github.com/rest/actions/workflow-runs#list-workflow-runs-for-a-repository)
    #>
    [OutputType([GitHubWorkflowRun])]
    [CmdletBinding()]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidAssignmentToAutomaticVariable', 'Event',
        Justification = 'A parameter that is used in the api call.')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # Returns someone's workflow runs. Use the login for the user who created the push associated with the check suite or workflow run.
        [Parameter()]
        [string] $Actor,

        # Returns workflow runs associated with a branch. Use the name of the branch of the `push`.
        [Parameter()]
        [string] $Branch,

        # Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see
        # "[Events that trigger workflows])(https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
        [Parameter()]
        [string] $Event,

        # Returns workflow runs with the check run status or conclusion that you specify. For example, a conclusion can be success or a status can be
        # `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.
        # Can be one of: `completed`, `action_required`, `cancelled`, `failure`, `neutral`, `skipped`, `stale`, `success`, `timed_out`, `in_progress`,
        # `queued`, `requested`, `waiting`, `pending`.
        [Parameter()]
        [ValidateSet('completed', 'action_required', 'cancelled', 'failure', 'neutral', 'skipped', 'stale', 'success', 'timed_out', 'in_progress',
            'queued', 'requested', 'waiting', 'pending')]
        [string] $Status,

        # Returns workflow runs created within the given date-time range. For more information on the syntax, see
        # "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
        [Parameter()]
        [datetime] $Created,

        # If `true` pull requests are omitted from the response (empty array).
        [Parameter()]
        [switch] $ExcludePullRequests,

        # Returns workflow runs with the check_suite_id that you specify.
        [Parameter()]
        [System.Nullable[UInt64]] $CheckSuiteID,

        # Only returns workflow runs that are associated with the specified head_sha.
        [Parameter()]
        [string] $HeadSHA,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            actor                 = $Actor
            branch                = $Branch
            event                 = $Event
            status                = $Status
            created               = $Created
            exclude_pull_requests = [bool]$ExcludePullRequests
            check_suite_id        = $CheckSuiteID
            head_sha              = $HeadSHA
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/actions/runs"
            Body        = $body
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response.workflow_runs | ForEach-Object {
                [GitHubWorkflowRun]::new($_)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Actions] - [Workflow Run] - [Get-GitHubWorkflowRunByRepo] - Done"
#endregion [functions] - [private] - [Actions] - [Workflow Run] - [Get-GitHubWorkflowRunByRepo]
#region    [functions] - [private] - [Actions] - [Workflow Run] - [Get-GitHubWorkflowRunByWorkflow]
Write-Debug "[$scriptName] - [functions] - [private] - [Actions] - [Workflow Run] - [Get-GitHubWorkflowRunByWorkflow] - Importing"
filter Get-GitHubWorkflowRunByWorkflow {
    <#
        .SYNOPSIS
        List workflow runs for a workflow

        .DESCRIPTION
        List all workflow runs for a workflow. You can replace `workflow_id` with the workflow filename. For example, you could use `main.yaml`.
        You can use parameters to narrow the list of results. For more information about using parameters, see
        [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).
        Anyone with read access to the repository can use this endpoint
        OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
        This endpoint will return up to 1,000 results for each search when using the following parameters: `actor`, `branch`, `check_suite_id`,
        `created`, `event`, `head_sha`, `status`.

        .EXAMPLE
        Get-GitHubWorkflowRunByWorkflow -Owner 'octocat' -Repository 'Hello-World' -ID '42'

        Gets all workflow runs for the workflow with the ID `42` in the repository `Hello-World` owned by `octocat`.

        .EXAMPLE
        Get-GitHubWorkflowRunByWorkflow -Owner 'octocat' -Repository 'Hello-World' -ID '42' -Actor 'octocat' -Branch 'main' -Event 'push' -Status 'success'

        Gets all workflow runs for the workflow with the ID `42` in the repository `Hello-World` owned by `octocat` that were triggered by the user
        `octocat` on the branch `main` and have the status `success`.

        .OUTPUTS
        GitHubWorkflowRun

        .NOTES
        [List workflow runs for a workflow](https://docs.github.com/rest/actions/workflow-runs#list-workflow-runs-for-a-workflow)
    #>
    [CmdletBinding()]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidAssignmentToAutomaticVariable', 'Event',
        Justification = 'A parameter that is used in the api call.')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The ID of the workflow. You can also pass the workflow filename as a string.
        [Parameter(Mandatory)]
        [string] $ID,

        # Returns someone's workflow runs. Use the login for the user who created the push associated with the check suite or workflow run.
        [Parameter()]
        [string] $Actor,

        # Returns workflow runs associated with a branch. Use the name of the branch of the `push`.
        [Parameter()]
        [string] $Branch,

        # Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see
        # "[Events that trigger workflows])(https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
        [Parameter()]
        [string] $Event,

        # Returns workflow runs with the check run status or conclusion that you specify. For example, a conclusion can be success or a status can be
        # `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.
        # Can be one of: `completed`, `action_required`, `cancelled`, `failure`, `neutral`, `skipped`, `stale`, `success`, `timed_out`, `in_progress`,
        # `queued`, `requested`, `waiting`, `pending`.
        [Parameter()]
        [ValidateSet('completed', 'action_required', 'cancelled', 'failure', 'neutral', 'skipped', 'stale', 'success', 'timed_out', 'in_progress',
            'queued', 'requested', 'waiting', 'pending')]
        [string] $Status,

        # Returns workflow runs created within the given date-time range. For more information on the syntax, see
        # "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
        [Parameter()]
        [datetime] $Created,

        # If `true` pull requests are omitted from the response (empty array).
        [Parameter()]
        [switch] $ExcludePullRequests,

        # Returns workflow runs with the check_suite_id that you specify.
        [Parameter()]
        [System.Nullable[UInt64]] $CheckSuiteID,

        # Only returns workflow runs that are associated with the specified head_sha.
        [Parameter()]
        [string] $HeadSHA,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            actor                 = $Actor
            branch                = $Branch
            event                 = $Event
            status                = $Status
            created               = $Created
            exclude_pull_requests = [bool]$ExcludePullRequests
            check_suite_id        = $CheckSuiteID
            head_sha              = $HeadSHA
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Context     = $Context
            APIEndpoint = "/repos/$Owner/$Repository/actions/workflows/$ID/runs"
            Method      = 'GET'
            PerPage     = $PerPage
            Body        = $body
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response.workflow_runs | ForEach-Object {
                [GitHubWorkflowRun]::new($_)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Actions] - [Workflow Run] - [Get-GitHubWorkflowRunByWorkflow] - Done"
#endregion [functions] - [private] - [Actions] - [Workflow Run] - [Get-GitHubWorkflowRunByWorkflow]
Write-Debug "[$scriptName] - [functions] - [private] - [Actions] - [Workflow Run] - Done"
#endregion [functions] - [private] - [Actions] - [Workflow Run]
Write-Debug "[$scriptName] - [functions] - [private] - [Actions] - Done"
#endregion [functions] - [private] - [Actions]
#region    [functions] - [private] - [Apps]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - Processing folder"
#region    [functions] - [private] - [Apps] - [GitHub Apps]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - Processing folder"
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [Add-GitHubKeyVaultJWTSignature]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Add-GitHubKeyVaultJWTSignature] - Importing"
function Add-GitHubKeyVaultJWTSignature {
    <#
        .SYNOPSIS
        Adds a JWT signature using Azure Key Vault.

        .DESCRIPTION
        Signs an unsigned JWT (header.payload) using a key stored in Azure Key Vault.
        The function supports authentication via Azure CLI or Az PowerShell module and returns the signed JWT as a secure string.

        .EXAMPLE
        Add-GitHubKeyVaultJWTSignature -UnsignedJWT 'header.payload' -KeyVaultKeyReference 'https://myvault.vault.azure.net/keys/mykey'

        Output:
        ```powershell
        System.Security.SecureString
        ```

        Signs the provided JWT (`header.payload`) using the specified Azure Key Vault key, returning a secure string containing the signed JWT.

        .OUTPUTS
        System.Security.SecureString

        .NOTES
        The function returns a secure string containing the fully signed JWT (header.payload.signature).
        Ensure Azure CLI or Az PowerShell is installed and authenticated before running this function.
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingConvertToSecureStringWithPlainText', '',
        Justification = 'Used to handle secure string private keys.'
    )]
    [CmdletBinding()]
    param (
        # The unsigned JWT (header.payload) to sign.
        [Parameter(Mandatory)]
        [string] $UnsignedJWT,

        # The Azure Key Vault key URL used for signing.
        [Parameter(Mandatory)]
        [string] $KeyVaultKeyReference
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if (Test-GitHubAzureCLI) {
            try {
                $accessToken = (az account get-access-token --resource 'https://vault.azure.net/' --output json | ConvertFrom-Json).accessToken
            } catch {
                Write-Error "Failed to get access token from Azure CLI: $_"
                return
            }
        } elseif (Test-GitHubAzPowerShell) {
            try {
                $accessToken = (Get-AzAccessToken -ResourceUrl 'https://vault.azure.net/').Token
            } catch {
                Write-Error "Failed to get access token from Az PowerShell: $_"
                return
            }
        } else {
            Write-Error 'Azure authentication is required. Please ensure you are logged in using either Azure CLI or Az PowerShell.'
            return
        }

        if ($accessToken -isnot [securestring]) {
            $accessToken = ConvertTo-SecureString -String $accessToken -AsPlainText
        }

        $hash64url = [GitHubJWTComponent]::ConvertToBase64UrlFormat(
            [System.Convert]::ToBase64String(
                [System.Security.Cryptography.SHA256]::Create().ComputeHash(
                    [System.Text.Encoding]::UTF8.GetBytes($UnsignedJWT)
                )
            )
        )

        $KeyVaultKeyReference = $KeyVaultKeyReference.TrimEnd('/')

        $params = @{
            Method         = 'POST'
            URI            = "$KeyVaultKeyReference/sign?api-version=7.4"
            Body           = @{
                alg   = 'RS256'
                value = $hash64url
            } | ConvertTo-Json
            ContentType    = 'application/json'
            Authentication = 'Bearer'
            Token          = $accessToken
        }

        $result = Invoke-RestMethod @params
        $signature = $result.value
        return (ConvertTo-SecureString -String "$UnsignedJWT.$signature" -AsPlainText)
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Add-GitHubKeyVaultJWTSignature] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [Add-GitHubKeyVaultJWTSignature]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [Add-GitHubLocalJWTSignature]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Add-GitHubLocalJWTSignature] - Importing"
function Add-GitHubLocalJWTSignature {
    <#
        .SYNOPSIS
        Signs a JSON Web Token (JWT) using a local RSA private key.

        .DESCRIPTION
        Takes an unsigned JWT (header.payload) and adds a signature using the provided RSA private key.
        This function handles the RSA signing process and returns the complete signed JWT.

        .EXAMPLE
        Add-GitHubLocalJWTSignature -UnsignedJWT 'eyJ0eXAiOi...' -PrivateKey '--- BEGIN RSA PRIVATE KEY --- ... --- END RSA PRIVATE KEY ---'

        Adds a signature to the unsigned JWT using the provided private key.

        .OUTPUTS
        securestring

        .NOTES
        This function isolates the signing logic to enable support for multiple signing methods.

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App/Add-GitHubLocalJWTSignature
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingConvertToSecureStringWithPlainText', '',
        Justification = 'Used to handle secure string private keys.'
    )]
    [CmdletBinding()]
    [OutputType([securestring])]
    param(
        # The unsigned JWT (header.payload) to sign.
        [Parameter(Mandatory)]
        [string] $UnsignedJWT,

        # The private key of the GitHub App.
        [Parameter(Mandatory)]
        [object] $PrivateKey
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if ($PrivateKey -is [securestring]) {
            $PrivateKey = $PrivateKey | ConvertFrom-SecureString -AsPlainText
        }

        $rsa = [System.Security.Cryptography.RSA]::Create()
        $rsa.ImportFromPem($PrivateKey)

        try {
            $signature = [GitHubJWTComponent]::ConvertToBase64UrlFormat(
                [System.Convert]::ToBase64String(
                    $rsa.SignData(
                        [System.Text.Encoding]::UTF8.GetBytes($UnsignedJWT),
                        [System.Security.Cryptography.HashAlgorithmName]::SHA256,
                        [System.Security.Cryptography.RSASignaturePadding]::Pkcs1
                    )
                )
            )
            return (ConvertTo-SecureString -String "$UnsignedJWT.$signature" -AsPlainText)
        } finally {
            if ($rsa) {
                $rsa.Dispose()
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Add-GitHubLocalJWTSignature] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [Add-GitHubLocalJWTSignature]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAppBySlug]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAppBySlug] - Importing"
function Get-GitHubAppBySlug {
    <#
        .SYNOPSIS
        Get an app

        .DESCRIPTION
        Gets a single GitHub App using the app's slug.

        .EXAMPLE
        Get-GitHubAppByName -AppSlug 'github-actions'

        Gets the GitHub App with the slug 'github-actions'.

        .NOTES
        [Get an app](https://docs.github.com/rest/apps/apps#get-an-app)
    #>
    [OutputType([GitHubApp])]
    [CmdletBinding()]
    param(
        # The AppSlug is just the URL-friendly name of a GitHub App.
        # You can find this on the settings page for your GitHub App (e.g., https://github.com/settings/apps/<app_slug>).
        # Example: 'github-actions'
        [Parameter(Mandatory)]
        [string] $Slug,

        # The context to run the command in. Used to get the details for the API call.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/apps/$Slug"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubApp]::new($_.Response)
        }
    }
    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAppBySlug] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAppBySlug]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAppInstallableOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAppInstallableOrganization] - Importing"
function Get-GitHubAppInstallableOrganization {
    <#
        .SYNOPSIS
        Get enterprise-owned organizations that can have GitHub Apps installed

        .DESCRIPTION
        List of organizations owned by the enterprise on which the authenticated GitHub App installation may install other GitHub Apps.

        .NOTES
        Permissions required:
        - enterprise_organization_installations: read

        .EXAMPLE
        Get-GitHubAppInstallableOrganization -Enterprise 'msx'

        .OUTPUTS
        GitHubOrganization[]

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App/Get-GitHubAppInstallableOrganization
    #>
    [OutputType([GitHubOrganization[]])]
    [CmdletBinding()]
    param(
        # The enterprise slug or ID.
        [Parameter(Mandatory)]
        [string] $Enterprise,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, UAT
        # enterprise_organization_installations=read
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/enterprises/$Enterprise/apps/installable_organizations"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($organization in $_.Response) {
                [GitHubOrganization]::new($organization, $Context)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAppInstallableOrganization] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAppInstallableOrganization]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAppInstallationForAuthenticatedApp]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAppInstallationForAuthenticatedApp] - Importing"
function Get-GitHubAppInstallationForAuthenticatedApp {
    <#
        .SYNOPSIS
        List installations for the authenticated app.

        .DESCRIPTION
        The permissions the installation has are included under the `permissions` key.

        You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
        to access this endpoint.

        .EXAMPLE
        Get-GitHubAppInstallationForAuthenticatedApp

        List installations for the authenticated app.

        .OUTPUTS
        GitHubAppInstallation[]

        .NOTES
        [List installations for the authenticated app](https://docs.github.com/rest/apps/apps#list-installations-for-the-authenticated-app)
    #>
    [OutputType([GitHubAppInstallation])]
    [CmdletBinding()]
    param(
        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType APP
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/app/installations'
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($installation in $_.Response) {
                [GitHubAppInstallation]::new($installation)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAppInstallationForAuthenticatedApp] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAppInstallationForAuthenticatedApp]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAuthenticatedApp]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAuthenticatedApp] - Importing"
filter Get-GitHubAuthenticatedApp {
    <#
        .SYNOPSIS
        Get the authenticated app

        .DESCRIPTION
        Returns the GitHub App associated with the authentication credentials used. To see how many app installations are associated with this
        GitHub App, see the `installations_count` in the response. For more details about your app's installations, see the
        "[List installations for the authenticated app](https://docs.github.com/rest/apps/apps#list-installations-for-the-authenticated-app)"
        endpoint.

        You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
        to access this endpoint.

        .EXAMPLE
        Get-GitHubAuthenticatedApp

        Get the authenticated app.

        .NOTES
        [Get the authenticated app](https://docs.github.com/rest/apps/apps#get-an-app)
    #>
    [OutputType([GitHubApp])]
    [CmdletBinding()]
    param(
        # The context to run the command in. Used to get the details for the API call.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType App
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/app'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubApp]::new($_.Response)
        }
    }
    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAuthenticatedApp] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubAuthenticatedApp]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubEnterpriseOrganizationAppInstallation]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubEnterpriseOrganizationAppInstallation] - Importing"
function Get-GitHubEnterpriseOrganizationAppInstallation {
    <#
        .SYNOPSIS
        List GitHub Apps installed on an enterprise-owned organization

        .DESCRIPTION
        Lists the GitHub App installations associated with the given enterprise-owned organization.

        The authenticated GitHub App must be installed on the enterprise and be granted the Enterprise/organization_installations (read) permission.

        .EXAMPLE
        Get-GitHubEnterpriseOrganizationAppInstallation -ENterprise 'msx' -Organization 'github'

        Gets all GitHub Apps in the organization `github` in the enterprise `msx`.

        .OUTPUTS
        GitHubAppInstallation

        .NOTES
        [List GitHub Apps installed on an enterprise-owned organization]()
    #>
    [OutputType([GitHubAppInstallation])]
    [CmdletBinding()]
    param(
        # The enterprise slug or ID.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Enterprise,

        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Organization,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, UAT
        # Enterprise_organization_installations=read
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/enterprises/$Enterprise/apps/organizations/$Organization/installations"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($installation in $_.Response) {
                [GitHubAppInstallation]::new($installation, $Organization, 'Organization', $Context)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubEnterpriseOrganizationAppInstallation] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubEnterpriseOrganizationAppInstallation]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubOrganizationAppInstallation]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubOrganizationAppInstallation] - Importing"
function Get-GitHubOrganizationAppInstallation {
    <#
        .SYNOPSIS
        List app installations for an organization

        .DESCRIPTION
        Lists all GitHub Apps in an organization. The installation count includes all GitHub Apps installed on repositories in the organization.
        You must be an organization owner with `admin:read` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubOrganizationAppInstallation -Organization 'github'

        Gets all GitHub Apps in the organization `github`.

        .OUTPUTS
        GitHubAppInstallation

        .NOTES
        [List app installations for an organization](https://docs.github.com/rest/orgs/orgs#list-app-installations-for-an-organization)
    #>
    [OutputType([GitHubAppInstallation])]
    [CmdletBinding()]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Organization,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Organization/installations"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($installation in $_.Response.installations) {
                [GitHubAppInstallation]::new($installation)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubOrganizationAppInstallation] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [Get-GitHubOrganizationAppInstallation]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [Install-GitHubAppOnEnterpriseOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Install-GitHubAppOnEnterpriseOrganization] - Importing"
function Install-GitHubAppOnEnterpriseOrganization {
    <#
        .SYNOPSIS
        Install an app on an Enterprise-owned organization

        .DESCRIPTION
        Installs the provided GitHub App on the specified organization owned by the enterprise.

        The authenticated GitHub App must be installed on the enterprise and be granted the Enterprise/organization_installations (write) permission.

        .EXAMPLE
        Install-GitHubAppOnEnterpriseOrganization -Enterprise 'msx' -Organization 'org' -ClientID '123456'
    #>
    [OutputType([GitHubAppInstallation])]
    [CmdletBinding()]
    param(
        # The enterprise slug or ID.
        [Parameter(Mandatory)]
        [string] $Enterprise,

        # The organization name. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Organization,

        # The client ID of the GitHub App to install.
        [Parameter(Mandatory)]
        [string] $ClientID,

        # The repository selection for the GitHub App. Can be one of:
        # - all - all repositories that the authenticated GitHub App installation can access.
        # - selected - select specific repositories.
        [Parameter(Mandatory)]
        [ValidateSet('All', 'Selected')]
        [string] $RepositorySelection,

        # The names of the repositories to which the installation will be granted access.
        [Parameter()]
        [string[]] $Repositories,

        # The context to run the command in. Used to get the details for the API call.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, UAT
        # enterprise_organization_installations=write
    }

    process {
        if ($RepositorySelection) {
            $RepositorySelection = $RepositorySelection.ToLower()
        }
        $body = @{
            client_id            = $ClientID
            repository_selection = $RepositorySelection
            repositories         = $Repositories
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/enterprises/$Enterprise/apps/organizations/$Organization/installations"
            Body        = $body
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubAppInstallation]::new($_.Response)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Install-GitHubAppOnEnterpriseOrganization] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [Install-GitHubAppOnEnterpriseOrganization]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [New-GitHubAppInstallationAccessToken]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [New-GitHubAppInstallationAccessToken] - Importing"
filter New-GitHubAppInstallationAccessToken {
    <#
        .SYNOPSIS
        Create an installation access token for an app

        .DESCRIPTION
        Creates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an
        organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a
        status code of `401 - Unauthorized`, and requires creating a new installation token. By default the installation token has access to all
        repositories that the installation can access.

        Optionally, you can use the `repositories` or `repository_ids` body parameters to specify individual repositories that the installation access
        token can access. If you don't use `repositories` or `repository_ids` to grant access to specific repositories, the installation access token
        will have access to all repositories that the installation was granted access to. The installation access token cannot be granted access to
        repositories that the installation was not granted access to. Up to 500 repositories can be listed in this manner.

        Optionally, use the `permissions` body parameter to specify the permissions that the installation access token should have. If `permissions`
        is not specified, the installation access token will have all of the permissions that were granted to the app. The installation access token
        cannot be granted permissions that the app was not granted.

        When using the repository or permission parameters to reduce the access of the token, the complexity of the token is increased due to both the
        number of permissions in the request and the number of repositories the token will have access to. If the complexity is too large, the token
        will fail to be issued. If this occurs, the error message will indicate the maximum number of repositories that should be requested. For the
        average application requesting 8 permissions, this limit is around 5000 repositories. With fewer permissions requested, more repositories are
        supported.

        You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
        to access this endpoint.

        .EXAMPLE
        New-GitHubAppInstallationAccessToken -InstallationID 12345678

        Creates an installation access token for the installation with the ID `12345678`.

        .EXAMPLE
        Connect-GitHub -ClientID $ClientID -PrivateKey $PrivateKey
        Get-GitHubAppInstallation | New-GitHubAppInstallationAccessToken

        Gets the GitHub App installations and creates an installation access token for each installation.

        .NOTES
        [Create an installation access token for an app](https://docs.github.com/rest/apps/apps#create-an-installation-access-token-for-an-app)

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App/New-GitHubAppInstallationAccessToken
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseShouldProcessForStateChangingFunctions', '',
        Justification = 'No state is changed.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingConvertToSecureStringWithPlainText', '',
        Justification = 'The tokens are received as clear text. Mitigating exposure by removing variables and performing garbage collection.'
    )]
    [CmdletBinding()]
    param(
        # The unique identifier of the installation.
        # Example: '12345678'
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [int] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType APP
    }

    process {
        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/app/installations/$ID/access_tokens"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [pscustomobject]@{
                Token               = $_.Response.token | ConvertTo-SecureString -AsPlainText -Force
                ExpiresAt           = $_.Response.expires_at.ToLocalTime()
                Permissions         = $_.Response.permissions
                RepositorySelection = $_.Response.repository_selection
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [New-GitHubAppInstallationAccessToken] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [New-GitHubAppInstallationAccessToken]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [New-GitHubUnsignedJWT]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [New-GitHubUnsignedJWT] - Importing"
function New-GitHubUnsignedJWT {
    <#
        .SYNOPSIS
        Creates an unsigned JSON Web Token (JWT) for a GitHub App.

        .DESCRIPTION
        Creates the header and payload portions of a JSON Web Token (JWT) for a GitHub App.
        This function does not sign the JWT - it returns the unsigned token (header.payload)
        that can be passed to a signing function.

        .EXAMPLE
        New-GitHubUnsignedJWT -ClientId 'Iv987654321'

        Creates an unsigned JWT for a GitHub App using the specified client ID.

        .OUTPUTS
        String

        .NOTES
        This function generates a JWT for a GitHub App that can be signed using a private key.
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseShouldProcessForStateChangingFunctions', '',
        Justification = 'Function creates an unsigned JWT without modifying system state'
    )]
    [CmdletBinding()]
    [OutputType([pscustomobject])]
    param(
        # The client ID of the GitHub App.
        # Can use the GitHub App ID or the client ID.
        [Parameter(Mandatory)]
        [string] $ClientID
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $header = [GitHubJWTComponent]::ToBase64UrlString(
            @{
                alg = 'RS256'
                typ = 'JWT'
            }
        )
        $now = [System.DateTimeOffset]::UtcNow
        $iat = $now.AddSeconds(-$script:GitHub.Config.JwtTimeTolerance)
        $exp = $now.AddSeconds($script:GitHub.Config.JwtTimeTolerance)
        $payload = [GitHubJWTComponent]::ToBase64UrlString(
            @{
                iat = $iat.ToUnixTimeSeconds()
                exp = $exp.ToUnixTimeSeconds()
                iss = $ClientID
            }
        )
        [pscustomobject]@{
            Base      = "$header.$payload"
            IssuedAt  = $iat.DateTime
            ExpiresAt = $exp.DateTime
            Issuer    = $ClientID
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [New-GitHubUnsignedJWT] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [New-GitHubUnsignedJWT]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [Revoke-GitHubAppInstallationAccessToken]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Revoke-GitHubAppInstallationAccessToken] - Importing"
function Revoke-GitHubAppInstallationAccessToken {
    <#
        .SYNOPSIS
        Revoke an installation access token.

        .DESCRIPTION
        Revokes the installation token you're using to authenticate as an installation and access this endpoint.
        Once an installation token is revoked, the token is invalidated and cannot be used. Other endpoints that require the revoked installation
        token must have a new installation token to work. You can create a new token using the `Connect-GitHubApp` function.

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App/Revoke-GitHubAppInstallationAccessToken

        .NOTES
        [Revoke an installation access token](https://docs.github.com/rest/apps/installations#revoke-an-installation-access-token)
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT
    }

    process {
        $InputObject = @{
            Method      = 'DELETE'
            APIEndpoint = '/installation/token'
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess('GitHub App installation access token', 'Revoke')) {
            $null = Invoke-GitHubAPI @InputObject
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Revoke-GitHubAppInstallationAccessToken] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [Revoke-GitHubAppInstallationAccessToken]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [Test-GitHubJWTRefreshRequired]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Test-GitHubJWTRefreshRequired] - Importing"
function Test-GitHubJWTRefreshRequired {
    <#
        .SYNOPSIS
        Test if the GitHub JWT should be refreshed.

        .DESCRIPTION
        Test if the GitHub JWT should be refreshed. JWTs are refreshed when they have 150 seconds or less remaining before expiration.

        .EXAMPLE
        Test-GitHubJWTRefreshRequired -Context $Context

        This will test if the GitHub JWT should be refreshed for the specified context.

        .NOTES
        JWTs are short-lived tokens (typically 10 minutes) and need to be refreshed more frequently than user access tokens.
        The refresh threshold is set to 150 seconds (2.5 minutes) to ensure the JWT doesn't expire during API operations.
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param(
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        try {
            ($Context.TokenExpiresAt - [datetime]::Now).TotalSeconds -le ($script:GitHub.Config.JwtTimeTolerance / 2)
        } catch {
            return $true
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Test-GitHubJWTRefreshRequired] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [Test-GitHubJWTRefreshRequired]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [Uninstall-GitHubAppOnEnterpriseOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Uninstall-GitHubAppOnEnterpriseOrganization] - Importing"
function Uninstall-GitHubAppOnEnterpriseOrganization {
    <#
        .SYNOPSIS
        Uninstall a GitHub App from an organization.

        .DESCRIPTION
        Uninstall a GitHub App from an organization.

        The authenticated GitHub App must be installed on the enterprise and be granted the Enterprise/organization_installations (write) permission.

        .EXAMPLE
        Uninstall-GitHubAppOnEnterpriseOrganization -Enterprise 'github' -Organization 'octokit' -InstallationID '123456'

        Uninstall the GitHub App with the installation ID `123456` from the organization `octokit` in the enterprise `github`.
    #>
    [CmdletBinding()]
    param(
        # The enterprise slug or ID.
        [Parameter(Mandatory)]
        [string] $Enterprise,

        # The organization name. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Organization,

        # The client ID of the GitHub App to install.
        [Parameter(Mandatory)]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, UAT
        #enterprise_organization_installations=write
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/enterprises/$Enterprise/apps/organizations/$Organization/installations/$ID"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Uninstall-GitHubAppOnEnterpriseOrganization] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [Uninstall-GitHubAppOnEnterpriseOrganization]
#region    [functions] - [private] - [Apps] - [GitHub Apps] - [Update-GitHubAppJWT]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Update-GitHubAppJWT] - Importing"
function Update-GitHubAppJWT {
    <#
        .SYNOPSIS
        Updates a JSON Web Token (JWT) for a GitHub App context.

        .DESCRIPTION
        Updates a JSON Web Token (JWT) for a GitHub App context. If the JWT has half or less of its remaining duration before expiration,
        it will be refreshed. This function implements mutex-based locking to prevent concurrent refreshes.

        .EXAMPLE
        Update-GitHubAppJWT -Context $Context

        Updates the JSON Web Token (JWT) for a GitHub App using the specified context.

        .EXAMPLE
        Update-GitHubAppJWT -Context $Context -PassThru

        This will update the GitHub App JWT for the specified context and return the updated context.

        .EXAMPLE
        Update-GitHubAppJWT -Context $Context -Silent

        This will update the GitHub App JWT for the specified context without displaying progress messages.

        .OUTPUTS
        object

        .NOTES
        [Generating a JSON Web Token (JWT) for a GitHub App | GitHub Docs](https://docs.github.com/apps/creating-github-apps/authenticating-with-a-github-app/generating-a-json-web-token-jwt-for-a-github-app#example-using-powershell-to-generate-a-jwt)

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App/Update-GitHubAppJWT
    #>
    [CmdletBinding(SupportsShouldProcess)]
    [OutputType([object])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '',
        Justification = 'Contains a long link.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingConvertToSecureStringWithPlainText', '',
        Justification = 'Generated JWT is a plaintext string.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '',
        Justification = 'Is the CLI part of the module.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseShouldProcessForStateChangingFunctions', '',
        Justification = 'Function creates a JWT without modifying system state'
    )]
    param(
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context,

        # Return the updated context.
        [Parameter()]
        [switch] $PassThru,

        # Timeout in milliseconds for waiting on mutex. Default is 30 seconds.
        [Parameter()]
        [int] $TimeoutMs = 30000
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if (Test-GitHubJWTRefreshRequired -Context $Context) {
            $lockName = "PSModule.GitHub-$($Context.ID)".Replace('/', '-')
            $lock = $null
            try {
                $lock = [System.Threading.Mutex]::new($false, $lockName)
                $acquiredLock = $lock.WaitOne(0)

                if ($acquiredLock) {
                    try {
                        Write-Debug '⚠ JWT token nearing expiration. Refreshing JWT...'
                        $unsignedJWT = New-GitHubUnsignedJWT -ClientId $Context.ClientID

                        if ($Context.KeyVaultKeyReference) {
                            Write-Debug "Using KeyVault Key Reference: $($Context.KeyVaultKeyReference)"
                            $Context.Token = Add-GitHubKeyVaultJWTSignature -UnsignedJWT $unsignedJWT.Base -KeyVaultKeyReference $Context.KeyVaultKeyReference
                        } elseif ($Context.PrivateKey) {
                            Write-Debug 'Using Private Key from context.'
                            $Context.Token = Add-GitHubLocalJWTSignature -UnsignedJWT $unsignedJWT.Base -PrivateKey $Context.PrivateKey
                        } else {
                            throw 'No Private Key or KeyVault Key Reference provided in the context.'
                        }

                        $Context.TokenExpiresAt = $unsignedJWT.ExpiresAt

                        if ($Context.ID) {
                            if ($PSCmdlet.ShouldProcess('JWT token', 'Update/refresh')) {
                                Set-Context -Context $Context -Vault $script:GitHub.ContextVault
                            }
                        }
                    } finally {
                        $lock.ReleaseMutex()
                    }
                } else {
                    Write-Verbose "JWT token is being updated by another process. Waiting for mutex to be released (timeout: $($TimeoutMs)ms)..."
                    try {
                        if ($lock.WaitOne($TimeoutMs)) {
                            $Context = Resolve-GitHubContext -Context $Context.ID
                            $lock.ReleaseMutex()
                        } else {
                            Write-Warning 'Timeout waiting for JWT token update. Proceeding with current token state.'
                        }
                    } catch [System.Threading.AbandonedMutexException] {
                        Write-Debug 'Mutex was abandoned by another process. Re-checking JWT token state...'
                        $Context = Resolve-GitHubContext -Context $Context.ID
                    }
                }
            } finally {
                if ($lock) {
                    $lock.Dispose()
                }
            }
        } else {
            # JWT is still valid, no refresh needed
            Write-Debug 'JWT is still valid, no refresh needed'
        }

        if ($PassThru) {
            return $Context
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - [Update-GitHubAppJWT] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps] - [Update-GitHubAppJWT]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - [GitHub Apps] - Done"
#endregion [functions] - [private] - [Apps] - [GitHub Apps]
Write-Debug "[$scriptName] - [functions] - [private] - [Apps] - Done"
#endregion [functions] - [private] - [Apps]
#region    [functions] - [private] - [Artifacts]
Write-Debug "[$scriptName] - [functions] - [private] - [Artifacts] - Processing folder"
#region    [functions] - [private] - [Artifacts] - [Get-GitHubArtifactById]
Write-Debug "[$scriptName] - [functions] - [private] - [Artifacts] - [Get-GitHubArtifactById] - Importing"
function Get-GitHubArtifactById {
    <#
        .SYNOPSIS
        Retrieves a specific artifact from a GitHub Actions workflow run.

        .DESCRIPTION
        Gets a single artifact from a workflow run in the specified repository by its unique identifier.
        Requires authentication via OAuth or personal access token with `repo` scope for private repositories.
        The function returns a custom GitHubArtifact object containing metadata and download information for the artifact.

        .EXAMPLE
        Get-GitHubArtifactById -Owner 'octocat' -Repository 'hello-world' -ID '123456'

        Output:
        ```powershell
        Name               : build-artifact
        ID                 : 123456
        Url                : https://api.github.com/repos/octocat/hello-world/actions/artifacts/123456
        Size               : 102400
        ArchiveDownloadUrl : https://github.com/download/artifact.zip
        Expired            : False
        ```

        Retrieves the artifact with ID 123456 from the 'hello-world' repository owned by 'octocat'.

        .OUTPUTS
        GitHubArtifact

        .NOTES
        A GitHubArtifact object representing a workflow artifact from the run.
        When -AllVersions is used, all versions of each artifact name are returned instead of the latest only.

        .NOTES
        [Get an artifact](https://docs.github.com/rest/actions/artifacts#get-an-artifact)
    #>
    [OutputType([GitHubArtifact])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The unique identifier of the artifact.
        [Parameter(Mandatory)]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/actions/artifacts/$ID"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubArtifact]::new($_.Response, $Owner, $Repository, $Context)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Artifacts] - [Get-GitHubArtifactById] - Done"
#endregion [functions] - [private] - [Artifacts] - [Get-GitHubArtifactById]
#region    [functions] - [private] - [Artifacts] - [Get-GitHubArtifactFromRepository]
Write-Debug "[$scriptName] - [functions] - [private] - [Artifacts] - [Get-GitHubArtifactFromRepository] - Importing"
function Get-GitHubArtifactFromRepository {
    <#
        .SYNOPSIS
        Lists artifacts for a GitHub repository.

        .DESCRIPTION
        Retrieves all workflow artifacts associated with a specified GitHub repository.
        Anyone with read access to the repository can invoke this function.
        For private repositories, personal access tokens or OAuth tokens must include the `repo` scope.
        By default, only the latest version of each artifact is returned unless -AllVersions is specified.

        .EXAMPLE
        Get-GitHubArtifactFromRepository -Owner 'octocat' -Repository 'demo-repo' -AllVersions

        Output:
        ```powershell
        Name        : build-output
        ID          : 4567890
        Expired     : False
        CreatedAt   : 3/31/2025 2:43:12 PM
        ```

        Retrieves all versions of the 'build-output' artifact from the 'demo-repo' repository owned by 'octocat'.

        .OUTPUTS
        GitHubArtifact[]

        .NOTES
        A list of GitHubArtifact objects representing workflow artifacts from the run.
        When -AllVersions is used, all versions of each artifact name are returned instead of the latest only.

        .NOTES
        [List artifacts for a repository](https://docs.github.com/rest/actions/artifacts#list-artifacts-for-a-repository)
    #>
    [OutputType([GitHubArtifact[]])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name field of an artifact. When specified, only artifacts with this name will be returned.
        [Parameter()]
        [string] $Name,

        # Return all versions of artifacts. This will include artifacts from all runs from the workflow.
        [Parameter()]
        [switch] $AllVersions,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            name = $Name
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/actions/artifacts"
            Body        = $body
            Context     = $Context
        }

        $response = Invoke-GitHubAPI @apiParams

        $artifacts = $response.Response.artifacts |
            Sort-Object -Property created_at -Descending

        if (-not $AllVersions) {
            $artifacts = $artifacts | Group-Object -Property name | ForEach-Object {
                $_.Group | Select-Object -First 1
            }
        }

        $artifacts | ForEach-Object {
            [GitHubArtifact]::new($_, $Owner, $Repository, $Context)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Artifacts] - [Get-GitHubArtifactFromRepository] - Done"
#endregion [functions] - [private] - [Artifacts] - [Get-GitHubArtifactFromRepository]
#region    [functions] - [private] - [Artifacts] - [Get-GitHubArtifactFromWorkflowRun]
Write-Debug "[$scriptName] - [functions] - [private] - [Artifacts] - [Get-GitHubArtifactFromWorkflowRun] - Importing"
function Get-GitHubArtifactFromWorkflowRun {
    <#
        .SYNOPSIS
        Retrieves artifacts from a specific GitHub Actions workflow run.

        .DESCRIPTION
        Lists all artifacts generated by a given GitHub Actions workflow run. Users must have read access to the
        repository. For private repositories, OAuth and personal access tokens must have the `repo` scope.
        The function can optionally filter artifacts by name or return only the latest version per artifact name.

        .EXAMPLE
        Get-GitHubArtifactFromWorkflowRun -Owner 'octocat' -Repository 'demo' -ID '123456789'

        Output:
        ```powershell
        ID                 : 10
        NodeID             : MDEwOkFydGlmYWN0MQ==
        Name               : build-logs
        Size               : 24576
        Url                : https://api.github.com/repos/octocat/demo/actions/artifacts/10
        ArchiveDownloadUrl : https://api.github.com/repos/octocat/demo/actions/artifacts/10/zip
        Expired            : False
        Digest             : abc123def456
        CreatedAt          : 2024-01-01T12:00:00Z
        UpdatedAt          : 2024-01-01T12:10:00Z
        ExpiresAt          : 2024-02-01T12:00:00Z
        WorkflowRun        : @{id=123456789; name=CI}
        ```

        Retrieves all artifacts for the given workflow run, returning only the latest version of each artifact.

        .OUTPUTS
        GitHubArtifact[]

        .NOTES
        A list of GitHubArtifact objects representing workflow artifacts from the run.
        When -AllVersions is used, all versions of each artifact name are returned instead of the latest only.

        .NOTES
        [List workflow run artifacts](https://docs.github.com/rest/actions/artifacts#list-workflow-run-artifacts)
    #>
    [OutputType([GitHubArtifact[]])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The unique identifier of the workflow run.
        [Parameter(Mandatory)]
        [string] $ID,

        # The name field of an artifact. When specified, only artifacts with this name will be returned.
        [Parameter()]
        [string] $Name,

        # Return all versions of artifacts. This will include artifacts from all runs from the workflow.
        [Parameter()]
        [switch] $AllVersions,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            name = $Name
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/actions/runs/$ID/artifacts"
            Body        = $body
            Context     = $Context
        }

        $response = Invoke-GitHubAPI @apiParams

        $artifacts = $response.Response.artifacts |
            Sort-Object -Property created_at -Descending

        if (-not $AllVersions) {
            $artifacts = $artifacts | Group-Object -Property name | ForEach-Object {
                $_.Group | Select-Object -First 1
            }
        }

        $artifacts | ForEach-Object {
            [GitHubArtifact]::new($_, $Owner, $Repository, $Context)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Artifacts] - [Get-GitHubArtifactFromWorkflowRun] - Done"
#endregion [functions] - [private] - [Artifacts] - [Get-GitHubArtifactFromWorkflowRun]
Write-Debug "[$scriptName] - [functions] - [private] - [Artifacts] - Done"
#endregion [functions] - [private] - [Artifacts]
#region    [functions] - [private] - [Auth]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - Processing folder"
#region    [functions] - [private] - [Auth] - [Get-GitHubToken]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Get-GitHubToken] - Importing"
function Get-GitHubToken {
    <#
        .SYNOPSIS
        Retrieves a GitHub token from environment variables as plaintext or a secure string.

        .DESCRIPTION
        Returns the value of the `GH_TOKEN` or `GITHUB_TOKEN` environment variable. If the `AsPlainText`
        switch is provided, the token is returned as a plaintext string. If not, the token is returned as
        a secure string using `ConvertTo-SecureString`. This allows flexibility for consumers who require
        either a raw token value or a secure version for sensitive operations.

        .EXAMPLE
        Get-GitHubToken

        Output:
        ```powershell
        System.Security.SecureString
        ```

        Returns the GitHub token as a secure string for safer handling in scripts or automation.

        .EXAMPLE
        Get-GitHubToken -AsPlainText

        Output:
        ```powershell
        ghp_XXXXXXXXXXXXXXXXXXXXXX
        ```

        Returns the GitHub token as a plaintext string if set in the environment.

        .OUTPUTS
        System.String

        .OUTPUTS
        System.Security.SecureString

        .LINK
        https://psmodule.io/GitHub/Functions/Get-GitHubToken/
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingConvertToSecureStringWithPlainText', '',
        Justification = 'The token is already plaintext.'
    )]
    [OutputType([System.Security.SecureString], ParameterSetName = 'SecureString')]
    [OutputType([System.String], ParameterSetName = 'String')]
    [CmdletBinding(DefaultParameterSetName = 'SecureString')]
    param(
        # Returns the token as a plaintext string when specified.
        [Parameter(Mandatory, ParameterSetName = 'String')]
        [switch] $AsPlainText
    )

    $token = $env:GH_TOKEN ?? $env:GITHUB_TOKEN

    if ([string]::IsNullOrEmpty($token)) {
        return
    }

    if ($AsPlainText) {
        return $token
    }

    return $token | ConvertTo-SecureString -AsPlainText -Force
}
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Get-GitHubToken] - Done"
#endregion [functions] - [private] - [Auth] - [Get-GitHubToken]
#region    [functions] - [private] - [Auth] - [Test-GitHubToken]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Test-GitHubToken] - Importing"
function Test-GitHubToken {
    <#
        .SYNOPSIS
        Tests if the GitHub token is set in the environment variables.

        .DESCRIPTION
        This function checks if the GitHub token is available in the environment variables.

        .EXAMPLE
        Test-GitHubToken
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param()

    return -not [string]::IsNullOrEmpty((Get-GitHubToken))
}
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Test-GitHubToken] - Done"
#endregion [functions] - [private] - [Auth] - [Test-GitHubToken]
#region    [functions] - [private] - [Auth] - [Cli]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Cli] - Processing folder"
#region    [functions] - [private] - [Auth] - [Cli] - [Connect-GithubCli]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Cli] - [Connect-GithubCli] - Importing"
filter Connect-GitHubCli {
    <#
        .SYNOPSIS
        Authenticates to GitHub CLI using a secure token from the provided context.

        .DESCRIPTION
        This function takes an input context containing authentication details and logs into GitHub CLI (`gh auth login`).
        It extracts the token from the provided context and passes it securely to the authentication command.
        If authentication fails, a warning is displayed, and `LASTEXITCODE` is reset to `0`.

        .EXAMPLE
        $context = Connect-GitHubAccount
        $context | Connect-GitHubCli

        Output:
        ```powershell
        (No output unless an error occurs)
        ```

        Logs into GitHub CLI using the provided authentication token and hostname from the context.

        .OUTPUTS
        void

        .NOTES
        The function does not return any output. It logs into GitHub CLI using the provided context.
    #>
    [OutputType([void])]
    [CmdletBinding()]
    param(
        # The context to run the command in.
        [Parameter(
            Mandatory,
            ValueFromPipeline
        )]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $return = ($Context.Token | ConvertFrom-SecureString -AsPlainText | gh auth login --with-token --hostname $Context.HostName) 2>&1
        $return = $return -join [System.Environment]::NewLine
        if ($LASTEXITCODE -ne 0) {
            if ($return.Contains('GITHUB_TOKEN environment variable is being used for authentication')) {
                Write-Debug $return
            } else {
                Write-Warning "Unable to log on with the GitHub Cli. ($LASTEXITCODE)"
                Write-Warning "$($return)"
            }
            $Global:LASTEXITCODE = 0
            Write-Debug "Resetting LASTEXITCODE: $LASTEXITCODE"
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Cli] - [Connect-GithubCli] - Done"
#endregion [functions] - [private] - [Auth] - [Cli] - [Connect-GithubCli]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Cli] - Done"
#endregion [functions] - [private] - [Auth] - [Cli]
#region    [functions] - [private] - [Auth] - [Context]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - Processing folder"
#region    [functions] - [private] - [Auth] - [Context] - [Assert-GitHubContext]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - [Assert-GitHubContext] - Importing"
filter Assert-GitHubContext {
    <#
        .SYNOPSIS
        Check if the context meets the requirements for the command.

        .DESCRIPTION
        This function checks if the context meets the requirements for the command.
        If the context does not meet the requirements, an error is thrown.

        .EXAMPLE
        Assert-GitHubContext -Context 'github.com/Octocat' -AuthType 'App'
    #>
    [OutputType([void])]
    [CmdletBinding()]
    param(
        # The context to run the command in.
        [Parameter(Mandatory, ValueFromPipeline)]
        [AllowNull()]
        [object] $Context,

        # The required authtypes for the command.
        [Parameter(Mandatory)]
        [string[]] $AuthType

        # TODO: Implement permission check
        # # The required permission for the command.
        # [Parameter()]
        # [string] $Permission
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $command = (Get-PSCallStack)[1].Command
        Write-Verbose "Context: $Context"
        Write-Verbose "AuthType: $AuthType"

        if (-not $Context) {
            if ('Anonymous' -in $AuthType) {
                return
            }
            $PSCmdlet.ThrowTerminatingError(
                [System.Management.Automation.ErrorRecord]::new(
                    [System.Exception]::new("Please provide a valid context or log in using 'Connect-GitHub'."),
                    'InvalidContext',
                    [System.Management.Automation.ErrorCategory]::InvalidArgument,
                    $Context
                )
            )
        }
        if ($Context -eq 'Anonymous' -and $AuthType -contains 'Anonymous') { return }
        if ($Context.AuthType -in $AuthType) { return }

        $errorText = "The context '$($Context.Name)' is of type [$($Context.AuthType)] which does not match the required" +
        "types [$($AuthType -join ', ')] for [$command]."
        $PSCmdlet.ThrowTerminatingError(
            [System.Management.Automation.ErrorRecord]::new(
                [System.Exception]::new($errorText),
                'InvalidContextAuthType',
                [System.Management.Automation.ErrorCategory]::InvalidArgument,
                $Context
            )
        )
        # TODO: Implement permission check
        # if ($Context.AuthType -in 'IAT' -and $Context.Permission -notin $Permission) {
        #     throw "The context '$($Context.Name)' does not match the required Permission [$Permission] for [$command]."
        # }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - [Assert-GitHubContext] - Done"
#endregion [functions] - [private] - [Auth] - [Context] - [Assert-GitHubContext]
#region    [functions] - [private] - [Auth] - [Context] - [completers]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - [completers] - Importing"
Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport) -ParameterName Context -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter

    $contexts = @()
    $hasAnonymousParameter = $false
    $command = Get-Command -Name $commandName -ErrorAction SilentlyContinue
    if ($command) {
        $hasAnonymousParameter = $command.Parameters.ContainsKey('Anonymous')
    }
    if ($hasAnonymousParameter) {
        $contexts += 'Anonymous'
    }

    $contexts += (Get-GitHubContext -ListAvailable -Verbose:$false).Name
    $contexts | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - [completers] - Done"
#endregion [functions] - [private] - [Auth] - [Context] - [completers]
#region    [functions] - [private] - [Auth] - [Context] - [Remove-GitHubContext]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - [Remove-GitHubContext] - Importing"
filter Remove-GitHubContext {
    <#
        .SYNOPSIS
        Removes a context from the context vault.

        .DESCRIPTION
        This function removes a context from the vault. It supports removing a single context by name,
        multiple contexts using wildcard patterns, and can also accept input from the pipeline.
        If the specified context(s) exist, they will be removed from the vault.

        .EXAMPLE
        Remove-Context

        Removes all contexts from the vault.

        .EXAMPLE
        Remove-Context -ID 'MyContext'

        Removes the context called 'MyContext' from the vault.
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The name of the context.
        [Parameter(Mandatory)]
        [string] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $null = Get-GitHubConfig
    }

    process {
        if ($PSCmdlet.ShouldProcess($context.Name, 'Remove context')) {
            Remove-Context -ID $Context -Vault $script:GitHub.ContextVault
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
#Requires -Modules @{ ModuleName = 'Context'; RequiredVersion = '8.1.0' }
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - [Remove-GitHubContext] - Done"
#endregion [functions] - [private] - [Auth] - [Context] - [Remove-GitHubContext]
#region    [functions] - [private] - [Auth] - [Context] - [Resolve-GitHubContext]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - [Resolve-GitHubContext] - Importing"
filter Resolve-GitHubContext {
    <#
        .SYNOPSIS
        Resolves the context into a GitHubContext object.

        .DESCRIPTION
        This function resolves the context into a GitHubContext object.
        If the context is already a GitHubContext object, it will return the object.
        If the context is a string, it will get the context details and return a GitHubContext object.

        If the context is a App, it will look at the available contexts and return the one that matches the scope of the command being run.

        .EXAMPLE
        $Context = Resolve-GitHubContext -Context 'github.com/Octocat'

        This will resolve the context 'github.com/Octocat' into a GitHubContext object.

        .EXAMPLE
        $Context = Resolve-GitHubContext -Context $GitHubContext

        This will return the GitHubContext object.
    #>
    [OutputType([GitHubContext])]
    [CmdletBinding()]
    param(
        # The context to resolve into an object. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory, ValueFromPipeline)]
        [AllowNull()]
        [object] $Context,

        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter()]
        [bool] $Anonymous
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Initialize-GitHubConfig
    }

    process {
        Write-Verbose "Context:"
        $Context | Out-String -Stream | ForEach-Object { Write-Verbose $_ }
        Write-Verbose "Anonymous: [$Anonymous]"
        if ($Anonymous -or $Context -eq 'Anonymous') {
            Write-Verbose 'Returning Anonymous context.'
            return [GitHubContext]::new(
                [pscustomobject]@{
                    Name     = 'Anonymous'
                    AuthType = 'Anonymous'
                }
            )
        }

        if ($Context -is [string]) {
            $contextName = $Context
            Write-Verbose "Getting context: [$contextName]"
            $Context = Get-GitHubContext -Context $contextName
        }

        if ($null -eq $Context) {
            Write-Verbose 'Context is null, returning default context.'
            $Context = Get-GitHubContext
        }

        switch ($Context.TokenType) {
            'ghu' {
                Write-Verbose 'Update GitHub User Access Token.'
                $Context = Update-GitHubUserAccessToken -Context $Context -PassThru
            }
            'JWT' {
                Write-Verbose 'Update GitHub App JWT Token.'
                $Context = Update-GitHubAppJWT -Context $Context -PassThru
            }
        }

        # TODO: Implement App installation context resolution
        # switch ($Context.Type) {
        #     'App' {
        #         $availableContexts = Get-GitHubContext -ListAvailable |
        #             Where-Object { $_.Type -eq 'Installation' -and $_.ClientID -eq $Context.ClientID }
        #         $params = Get-FunctionParameter -Scope 2
        #         Write-Debug 'Resolving parameters used in called function'
        #         Write-Debug ($params | Out-String)
        #         if ($params.Keys -in 'Owner', 'Organization') {
        #             $Context = $availableContexts | Where-Object { $_.Owner -eq $params.Owner }
        #         }
        #     }
        # }

        $Context
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - [Resolve-GitHubContext] - Done"
#endregion [functions] - [private] - [Auth] - [Context] - [Resolve-GitHubContext]
#region    [functions] - [private] - [Auth] - [Context] - [Resolve-GitHubContextSetting]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - [Resolve-GitHubContextSetting] - Importing"
function Resolve-GitHubContextSetting {
    <#
        .SYNOPSIS
        Resolves a GitHub context setting based on a provided name.

        .DESCRIPTION
        This function retrieves a setting value from the specified GitHub context. If a value is provided, it
        returns that value; otherwise, it will extract the value from the given context object if provided. As a last resort,
        it will return the default value from the GitHub configuration. This is useful for resolving API-related settings dynamically.

        .EXAMPLE
        Resolve-GitHubContextSetting -Name 'Repository' -Value 'MyRepo'

        Output:
        ```powershell
        MyRepo
        ```

        Returns the provided value 'MyRepo' for the 'Repository' setting.

        .EXAMPLE
        Resolve-GitHubContextSetting -Name 'Repository' -Context $GitHubContext

        Output:
        ```powershell
        MyRepository
        ```

        Retrieves the 'Repository' setting from the provided GitHub context object.

        .EXAMPLE
        Resolve-GitHubContextSetting -Name 'ApiBaseUrl'

        Output:
        ```powershell
        https://api.github.com
        ```

        Returns the default value for the 'ApiBaseUrl' setting from the GitHub configuration when no value or context is provided.

        .LINK
        https://psmodule.io/GitHub/Functions/Resolve-GitHubContextSetting
    #>

    [CmdletBinding()]
    param(
        # The name of the setting to resolve.
        [Parameter(Mandatory)]
        [string] $Name,

        # The value to use for the setting. If not provided, the value will be resolved from the context.
        [Parameter()]
        [object] $Value,

        # The context to resolve into an object. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    if ($Name -eq 'PerPage' -and $Value -eq 0) {
        $Value = $null
    }

    Write-Debug "Resolving setting [$Name]"
    [pscustomobject]@{
        'Name'                 = $Name
        'Parameter Value'      = $Value
        'Context Value'        = $Context.$Name
        'Saved Config Value'   = $script:GitHub.Config.$Name
        'Default Config Value' = $script:GitHub.DefaultConfig.$Name
    } | Format-List | Out-String -Stream | ForEach-Object { Write-Debug $_ }

    if (-not [string]::IsNullOrEmpty($Value)) {
        Write-Debug "[$Name] - [$Value] - Provided value"
        return $Value
    }

    if (-not [string]::IsNullOrEmpty($Context.$Name)) {
        Write-Debug "[$Name] - [$($Context.$Name)] - Context value"
        return $Context.$Name
    }

    if (-not [string]::IsNullOrEmpty($Script:GitHub.Config.$Name)) {
        Write-Debug "[$Name] - [$($script:GitHub.Config.$Name)] - Default value from GitHub.Config"
        return $script:GitHub.Config.$Name
    }

    if (-not [string]::IsNullOrEmpty($Script:GitHub.DefaultConfig.$Name)) {
        Write-Debug "[$Name] - [$($script:GitHub.DefaultConfig.$Name)] - Default value from GitHub.DefaultConfig"
        return $script:GitHub.DefaultConfig.$Name
    }
    Write-Debug ' - No value found, returning'
    return $null
}
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - [Resolve-GitHubContextSetting] - Done"
#endregion [functions] - [private] - [Auth] - [Context] - [Resolve-GitHubContextSetting]
#region    [functions] - [private] - [Auth] - [Context] - [Set-GitHubContext]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - [Set-GitHubContext] - Importing"
function Set-GitHubContext {
    <#
        .SYNOPSIS
        Sets the GitHub context and stores it in the context vault.

        .DESCRIPTION
        This function sets the GitHub context and stores it in the context vault.
        The context is used to authenticate with the GitHub API.

        .EXAMPLE
        $context = @{
            ApiBaseUri = 'https://api.github.com'
            ApiVersion = '2022-11-28'
            HostName   = 'github.com'
            AuthType   = 'PAT'
            Enterprise = 'msx'
            Owner      = 'octocat'
            Repository = 'Hello-World'
        }
        Set-GitHubContext -Context $context

        Sets the GitHub context with the specified settings as a hashtable.
    #>
    [OutputType([GitHubContext])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The GitHub context to save in the vault.
        [hashtable] $Context,

        # Set as the default context.
        [Parameter()]
        [switch] $Default,

        # Pass the context through the pipeline.
        [Parameter()]
        [switch] $PassThru
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $null = Get-GitHubConfig
        $contextObj = @{} + $Context
    }

    process {
        Write-Debug 'Context:'
        $contextObj | Out-String -Stream | ForEach-Object { Write-Debug $_ }

        # Run functions to get info on the temporary context.
        try {
            Write-Debug "Getting info on the context [$($contextObj['AuthType'])]."
            switch -Regex (($contextObj['AuthType'])) {
                'PAT|UAT|IAT' {
                    $viewer = Get-GitHubViewer -Context $contextObj
                    $viewer | Out-String -Stream | ForEach-Object { Write-Debug $_ }
                    if ([string]::IsNullOrEmpty($contextObj['DisplayName'])) {
                        $contextObj['DisplayName'] = [string]$viewer.name
                    }
                    if ([string]::IsNullOrEmpty($contextObj['Username'])) {
                        $login = [string]($viewer.login -Replace '\[bot\]')
                        $contextObj['Username'] = $login
                    }
                    if ([string]::IsNullOrEmpty($contextObj['NodeID'])) {
                        $contextObj['NodeID'] = [string]$viewer.id
                    }
                    if ([string]::IsNullOrEmpty($contextObj['DatabaseID'])) {
                        $contextObj['DatabaseID'] = [string]$viewer.databaseId
                    }
                }
                'PAT|UAT' {
                    $contextName = "$($contextObj['HostName'])/$login"
                    $contextObj['Name'] = $contextName
                    $contextObj['Type'] = 'User'
                }
                'IAT' {
                    $contextObj['Type'] = 'Installation'
                    if ([string]::IsNullOrEmpty($contextObj['DisplayName'])) {
                        try {
                            $app = Get-GitHubApp -Name $contextObj['Username'] -Context $contextObj
                            $contextObj['DisplayName'] = [string]$app.Name
                        } catch {
                            Write-Debug "Failed to get the GitHub App with the slug: [$($contextObj['Username'])]."
                        }
                    }
                    if ($script:IsGitHubActions) {
                        $gitHubEvent = Get-Content -Path $env:GITHUB_EVENT_PATH -Raw | ConvertFrom-Json
                        $installationType = $gitHubEvent.repository.owner.type
                        $installationName = $gitHubEvent.repository.owner.login
                        $enterprise = $gitHubEvent.enterprise.slug
                        $organization = $gitHubEvent.organization.login
                        $owner = $gitHubEvent.repository.owner.login
                        $Repository = $gitHubEvent.repository.name
                        $gh_sender = $gitHubEvent.sender.login # sender is an automatic variable in Powershell
                        Write-Debug "Enterprise:            $enterprise"
                        Write-Debug "Organization:          $organization"
                        Write-Debug "Repository:            $Repository"
                        Write-Debug "Repository Owner:      $owner"
                        Write-Debug "Repository Owner Type: $installationType"
                        Write-Debug "Sender:                $gh_sender"
                        if ([string]::IsNullOrEmpty($contextObj['Enterprise'])) {
                            $contextObj['Enterprise'] = [string]$enterprise
                        }
                        if ([string]::IsNullOrEmpty($contextObj['Owner'])) {
                            $contextObj['Owner'] = [string]$owner
                        }
                        if ([string]::IsNullOrEmpty($contextObj['Repository'])) {
                            $contextObj['Repository'] = [string]$Repository
                        }
                        if ([string]::IsNullOrEmpty($contextObj['InstallationType'])) {
                            $contextObj['InstallationType'] = [string]$installationType
                        }
                        if ([string]::IsNullOrEmpty($contextObj['InstallationName'])) {
                            $contextObj['InstallationName'] = [string]$installationName
                        }
                        $contextObj['Name'] = "$($contextObj['HostName'])/$($contextObj['Username'])/" +
                        "$($contextObj['InstallationType'])/$($contextObj['InstallationName'])"
                    } else {
                        $contextObj['Name'] = "$($contextObj['HostName'])/$($contextObj['Username'])/" +
                        "$($contextObj['InstallationType'])/$($contextObj['InstallationName'])"
                    }
                }
                'App' {
                    $app = Get-GitHubApp -Context $contextObj
                    $contextObj['Name'] = "$($contextObj['HostName'])/$($app.Slug)"
                    $contextObj['DisplayName'] = [string]$app.Name
                    $contextObj['Username'] = [string]$app.Slug
                    $contextObj['NodeID'] = [string]$app.NodeID
                    $contextObj['DatabaseID'] = [string]$app.ID
                    $contextObj['Permissions'] = [PSCustomObject]$app.Permissions
                    $contextObj['Events'] = [string[]]$app.Events
                    $contextObj['OwnerName'] = [string]$app.Owner.Name
                    $contextObj['OwnerType'] = [string]$app.Owner.Type
                    $contextObj['Type'] = 'App'
                }
                default {
                    throw 'Failed to get info on the context. Unknown logon type.'
                }
            }
            Write-Debug "Found [$($contextObj['Type'])] with login: [$($contextObj['Name'])]"
            $contextObj | Out-String -Stream | ForEach-Object { Write-Debug $_ }
            Write-Debug '----------------------------------------------------'
            if ($PSCmdlet.ShouldProcess('Context', 'Set')) {
                Write-Debug "Saving context: [$($contextObj['Name'])]"
                Set-Context -ID $($contextObj['Name']) -Context $contextObj -Vault $script:GitHub.ContextVault
                if ($Default) {
                    Switch-GitHubContext -Context $contextObj['Name']
                }
                if ($script:IsGitHubActions) {
                    if ($contextObj['AuthType'] -ne 'APP') {
                        Set-GitHubGitConfig -Context $contextObj['Name']
                        Connect-GitHubCli -Context $contextObj
                    }
                }
                if ($PassThru) {
                    Get-GitHubContext -Context $($contextObj['Name'])
                }
            }
        } catch {
            Write-Error $_ | Select-Object *
            throw 'Failed to set the GitHub context.'
        } finally {
            $contextObj.Clear()
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
#Requires -Modules @{ ModuleName = 'Context'; RequiredVersion = '8.1.0' }
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - [Set-GitHubContext] - Done"
#endregion [functions] - [private] - [Auth] - [Context] - [Set-GitHubContext]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [Context] - Done"
#endregion [functions] - [private] - [Auth] - [Context]
#region    [functions] - [private] - [Auth] - [DeviceFlow]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - Processing folder"
#region    [functions] - [private] - [Auth] - [DeviceFlow] - [Invoke-GitHubDeviceFlowLogin]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - [Invoke-GitHubDeviceFlowLogin] - Importing"
function Invoke-GitHubDeviceFlowLogin {
    <#
        .SYNOPSIS
        Starts the GitHub Device Flow login process.

        .DESCRIPTION
        Starts the GitHub Device Flow login process. This will prompt the user to visit a URL and enter a code.

        .EXAMPLE
        Invoke-GitHubDeviceFlowLogin

        This will start the GitHub Device Flow login process.
        The user gets prompted to visit a URL and enter a code.

        .NOTES
        For more info about the Device Flow visit:
        https://docs.github.com/apps/creating-github-apps/writing-code-for-a-github-app/building-a-cli-with-a-github-app
        https://docs.github.com/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#device-flow
    #>
    [OutputType([void])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingWriteHost', '', Justification = 'Is the CLI part of the module.')]
    [CmdletBinding()]
    param(
        # The Client ID of the GitHub App.
        [Parameter(Mandatory)]
        [string] $ClientID,

        # The scope of the access token, when using OAuth authentication.
        # Provide the list of scopes as space-separated values.
        # For more information on scopes visit:
        # https://docs.github.com/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps
        [Parameter()]
        [string] $Scope,

        # The host to connect to.
        [Parameter(Mandatory)]
        [string] $HostName,

        # The refresh token to use for re-authentication.
        [Parameter()]
        [securestring] $RefreshToken
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        do {
            if ($RefreshToken) {
                $tokenResponse = Wait-GitHubAccessToken -ClientID $ClientID -RefreshToken $RefreshToken -HostName $HostName
            } else {
                $deviceCodeResponse = Request-GitHubDeviceCode -ClientID $ClientID -Scope $Scope -HostName $HostName

                $deviceCode = $deviceCodeResponse.device_code
                $interval = $deviceCodeResponse.interval
                $userCode = $deviceCodeResponse.user_code
                $verificationUri = $deviceCodeResponse.verification_uri

                Write-Host '! ' -ForegroundColor DarkYellow -NoNewline
                Write-Host "We added the code to your clipboard: [$userCode]"
                $userCode | Set-Clipboard
                Read-Host "Press Enter to open $HostName in your browser..."
                Start-Process $verificationUri

                $tokenResponse = Wait-GitHubAccessToken -DeviceCode $deviceCode -ClientID $ClientID -Interval $interval -HostName $HostName
            }
        } while ($tokenResponse.error)
        $tokenResponse
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - [Invoke-GitHubDeviceFlowLogin] - Done"
#endregion [functions] - [private] - [Auth] - [DeviceFlow] - [Invoke-GitHubDeviceFlowLogin]
#region    [functions] - [private] - [Auth] - [DeviceFlow] - [Request-GitHubAccessToken]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - [Request-GitHubAccessToken] - Importing"
function Request-GitHubAccessToken {
    <#
        .SYNOPSIS
        Request a GitHub token using the Device Flow.

        .DESCRIPTION
        Request a GitHub token using the Device Flow.
        This will poll the GitHub API until the user has entered the code.

        .EXAMPLE
        Request-GitHubAccessToken -DeviceCode $deviceCode -ClientID $ClientID -HostName 'github.com'

        This will poll the GitHub API until the user has entered the code.

        .NOTES
        For more info about the Device Flow visit:
        https://docs.github.com/apps/creating-github-apps/writing-code-for-a-github-app/building-a-cli-with-a-github-app
    #>
    [OutputType([PSCustomObject])]
    [CmdletBinding(DefaultParameterSetName = 'DeviceFlow')]
    param(
        # The Client ID of the GitHub App.
        [Parameter(Mandatory)]
        [string] $ClientID,

        # The 'device_code' used to request the access token.
        [Parameter(
            Mandatory,
            ParameterSetName = 'DeviceFlow'
        )]
        [string] $DeviceCode,

        # The refresh token used create a new access token.
        [Parameter(
            Mandatory,
            ParameterSetName = 'RefreshToken'
        )]
        [securestring] $RefreshToken,

        # The host to connect to.
        [Parameter(Mandatory)]
        [string] $HostName
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $body = @{
            'client_id' = $ClientID
        }

        if ($PSBoundParameters.ContainsKey('RefreshToken')) {
            $body += @{
                'refresh_token' = (ConvertFrom-SecureString $RefreshToken -AsPlainText)
                'grant_type'    = 'refresh_token'
            }
        }

        if ($PSBoundParameters.ContainsKey('DeviceCode')) {
            $body += @{
                'device_code' = $DeviceCode
                'grant_type'  = 'urn:ietf:params:oauth:grant-type:device_code'
            }
        }

        $headers = @{
            'Accept' = 'application/json'
        }

        $RESTParams = @{
            Method  = 'POST'
            Uri     = "https://$HostName/login/oauth/access_token"
            Headers = $headers
            Body    = $body
        }

        Write-Debug ($RESTParams.GetEnumerator() | Out-String)
        $tokenResponse = Invoke-RestMethod @RESTParams -Verbose:$false
        Write-Debug ($tokenResponse | ConvertTo-Json | Out-String)
        return $tokenResponse

    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - [Request-GitHubAccessToken] - Done"
#endregion [functions] - [private] - [Auth] - [DeviceFlow] - [Request-GitHubAccessToken]
#region    [functions] - [private] - [Auth] - [DeviceFlow] - [Request-GitHubDeviceCode]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - [Request-GitHubDeviceCode] - Importing"
function Request-GitHubDeviceCode {
    <#
        .SYNOPSIS
        Request a GitHub Device Code.

        .DESCRIPTION
        Request a GitHub Device Code.

        .EXAMPLE
        Request-GitHubDeviceCode -ClientID $ClientID -Mode $Mode -HostName 'github.com'

        This will request a GitHub Device Code.

        .NOTES
        For more info about the Device Flow visit:
        https://docs.github.com/apps/creating-github-apps/writing-code-for-a-github-app/building-a-cli-with-a-github-app
    #>
    [OutputType([PSCustomObject])]
    [CmdletBinding()]
    param(
        # The Client ID of the GitHub App.
        [Parameter(Mandatory)]
        [string] $ClientID,

        # The scope of the access token, when using OAuth authentication.
        # Provide the list of scopes as space-separated values.
        # For more information on scopes visit:
        # https://docs.github.com/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps
        [Parameter()]
        [string] $Scope = 'gist, read:org, repo, workflow',

        # The host to connect to.
        [Parameter(Mandatory)]
        [string] $HostName
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $headers = @{
            Accept = 'application/json'
        }

        $body = @{
            client_id = $ClientID
            scope     = $Scope
        }

        $RESTParams = @{
            Method  = 'POST'
            Uri     = "https://$HostName/login/device/code"
            Headers = $headers
            Body    = $body
        }

        Write-Debug ($RESTParams.GetEnumerator() | Out-String)
        $deviceCodeResponse = Invoke-RestMethod @RESTParams -Verbose:$false
        return $deviceCodeResponse
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - [Request-GitHubDeviceCode] - Done"
#endregion [functions] - [private] - [Auth] - [DeviceFlow] - [Request-GitHubDeviceCode]
#region    [functions] - [private] - [Auth] - [DeviceFlow] - [Test-GitHubAccessTokenRefreshRequired]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - [Test-GitHubAccessTokenRefreshRequired] - Importing"
function Test-GitHubAccessTokenRefreshRequired {
    <#
        .SYNOPSIS
        Test if the GitHub access token should be refreshed.

        .DESCRIPTION
        Test if the GitHub access token should be refreshed.

        .EXAMPLE
        Test-GitHubAccessTokenRefreshRequired

        This will test if the GitHub access token should be refreshed.
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param(
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        try {
            ($Context.TokenExpiresAt - [datetime]::Now).TotalHours -lt $script:GitHub.Config.AccessTokenGracePeriodInHours
        } catch {
            return $true
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - [Test-GitHubAccessTokenRefreshRequired] - Done"
#endregion [functions] - [private] - [Auth] - [DeviceFlow] - [Test-GitHubAccessTokenRefreshRequired]
#region    [functions] - [private] - [Auth] - [DeviceFlow] - [Update-GitHubUserAccessToken]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - [Update-GitHubUserAccessToken] - Importing"
function Update-GitHubUserAccessToken {
    <#
        .SYNOPSIS
        Updates the GitHub access token.

        .DESCRIPTION
        Updates the GitHub access token. If the access token is still valid, it will not be refreshed.

        .EXAMPLE
        Update-GitHubUserAccessToken

        This will update the GitHub access token for the default context.

        .EXAMPLE
        Update-GitHubUserAccessToken -Context 'github.com/mojombo'

        This will update the GitHub access token for the context 'github.com/mojombo'.

        .NOTES
        [Refreshing user access tokens](https://docs.github.com/apps/creating-github-apps/authenticating-with-a-github-app/refreshing-user-access-tokens)
    #>
    [CmdletBinding(SupportsShouldProcess)]
    [OutputType([GitHubContext])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '',
        Justification = 'Is the CLI part of the module.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingConvertToSecureStringWithPlainText', '',
        Justification = 'The tokens are recieved as clear text. Mitigating exposure by removing variables and performing garbage collection.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '',
        Justification = 'Reason for suppressing'
    )]
    param(
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context,

        # Return the updated context.
        [Parameter()]
        [switch] $PassThru,

        # Timeout in milliseconds for waiting on mutex. Default is 30 seconds.
        [Parameter()]
        [int] $TimeoutMs = 30000
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if (Test-GitHubAccessTokenRefreshRequired -Context $Context) {
            $lockName = "PSModule.GitHub-$($Context.ID)".Replace('/', '-')
            $lock = $null
            try {
                $lock = [System.Threading.Mutex]::new($false, $lockName)
                $updateToken = $lock.WaitOne(0)

                if ($updateToken) {
                    try {
                        $refreshTokenValidity = [datetime]($Context.RefreshTokenExpiresAt) - [datetime]::Now
                        $refreshTokenIsValid = $refreshTokenValidity.TotalSeconds -gt 0
                        if ($refreshTokenIsValid) {
                            Write-Debug '⚠ Access token expired. Refreshing access token...'
                            $tokenResponse = Invoke-GitHubDeviceFlowLogin -ClientID $Context.AuthClientID -RefreshToken $Context.RefreshToken -HostName $Context.HostName
                        } else {
                            Write-Verbose "Using $($Context.DeviceFlowType) authentication..."
                            $tokenResponse = Invoke-GitHubDeviceFlowLogin -ClientID $Context.AuthClientID -HostName $Context.HostName
                        }
                        $Context.Token = ConvertTo-SecureString -AsPlainText $tokenResponse.access_token
                        $Context.TokenExpiresAt = ([DateTime]::Now).AddSeconds($tokenResponse.expires_in)
                        $Context.TokenType = $tokenResponse.access_token -replace $script:GitHub.TokenPrefixPattern
                        $Context.RefreshToken = ConvertTo-SecureString -AsPlainText $tokenResponse.refresh_token
                        $Context.RefreshTokenExpiresAt = ([DateTime]::Now).AddSeconds($tokenResponse.refresh_token_expires_in)

                        if ($PSCmdlet.ShouldProcess('Access token', 'Update/refresh')) {
                            Set-Context -Context $Context -Vault $script:GitHub.ContextVault
                        }
                    } finally {
                        $lock.ReleaseMutex()
                    }
                } else {
                    Write-Verbose "Access token is not valid. Waiting for mutex to be released (timeout: $($TimeoutMs)ms)..."
                    try {
                        if ($lock.WaitOne($TimeoutMs)) {
                            $Context = Resolve-GitHubContext -Context $Context.ID
                            $lock.ReleaseMutex()
                        } else {
                            Write-Warning 'Timeout waiting for token update. Proceeding with current token state.'
                        }
                    } catch [System.Threading.AbandonedMutexException] {
                        Write-Debug 'Mutex was abandoned by another process. Re-checking token state...'
                        $Context = Resolve-GitHubContext -Context $Context.ID
                    }
                }
            } finally {
                if ($lock) {
                    $lock.Dispose()
                }
            }
        }
        if ($PassThru) {
            return $Context
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - [Update-GitHubUserAccessToken] - Done"
#endregion [functions] - [private] - [Auth] - [DeviceFlow] - [Update-GitHubUserAccessToken]
#region    [functions] - [private] - [Auth] - [DeviceFlow] - [Wait-GitHubAccessToken]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - [Wait-GitHubAccessToken] - Importing"
function Wait-GitHubAccessToken {
    <#
        .SYNOPSIS
        Waits for the GitHub Device Flow to complete.

        .DESCRIPTION
        Waits for the GitHub Device Flow to complete.
        This will poll the GitHub API until the user has entered the code.

        .EXAMPLE
        Wait-GitHubAccessToken -DeviceCode $deviceCode -ClientID $ClientID -Interval $interval

        This will poll the GitHub API until the user has entered the code.

        .EXAMPLE
        Wait-GitHubAccessToken -Refresh -ClientID $ClientID

        .NOTES
        For more info about the Device Flow visit:
        https://docs.github.com/apps/creating-github-apps/writing-code-for-a-github-app/building-a-cli-with-a-github-app
    #>
    [OutputType([PSCustomObject])]
    [CmdletBinding(DefaultParameterSetName = 'DeviceFlow')]
    param(
        # The Client ID of the GitHub App.
        [Parameter(Mandatory)]
        [string] $ClientID,

        # The device code used to request the access token.
        [Parameter(
            Mandatory,
            ParameterSetName = 'DeviceFlow'
        )]
        [string] $DeviceCode,

        # The refresh token used to request a new access token.
        [Parameter(
            Mandatory,
            ParameterSetName = 'RefreshToken'
        )]
        [securestring] $RefreshToken,

        # The host to connect to.
        [Parameter(Mandatory)]
        [string] $HostName,

        # The interval to wait between polling for the token.
        [Parameter()]
        [int] $Interval = 5
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        do {
            if ($RefreshToken) {
                $response = Request-GitHubAccessToken -ClientID $ClientID -RefreshToken $RefreshToken -HostName $HostName
            } else {
                $response = Request-GitHubAccessToken -ClientID $ClientID -DeviceCode $DeviceCode -HostName $HostName
            }
            if ($response.error) {
                switch ($response.error) {
                    'authorization_pending' {
                        # The user has not yet entered the code.
                        # Wait, then poll again.
                        Write-Debug $response.error_description
                        Start-Sleep -Seconds $interval
                        continue
                    }
                    'slow_down' {
                        # The app polled too fast.
                        # Wait for the interval plus 5 seconds, then poll again.
                        Write-Debug $response.error_description
                        Start-Sleep -Seconds ($interval + 5)
                        continue
                    }
                    'expired_token' {
                        # The 'device_code' expired, and the process needs to restart.
                        Write-Error $response.error_description
                        exit 1
                    }
                    'unsupported_grant_type' {
                        # The 'grant_type' is not supported.
                        Write-Error $response.error_description
                        exit 1
                    }
                    'incorrect_client_credentials' {
                        # The 'client_id' is not valid.
                        Write-Error $response.error_description
                        exit 1
                    }
                    'incorrect_device_code' {
                        # The 'device_code' is not valid.
                        Write-Error $response.error_description
                        exit 2
                    }
                    'access_denied' {
                        # The user cancelled the process. Stop polling.
                        Write-Error $response.error_description
                        exit 1
                    }
                    'device_flow_disabled' {
                        # The GitHub App does not support the Device Flow.
                        Write-Error $response.error_description
                        exit 1
                    }
                    default {
                        # The response contains an access token. Stop polling.
                        Write-Error 'Unknown error:'
                        Write-Error $response.error
                        Write-Error $response.error_description
                        Write-Error $response.error_uri
                        break
                    }
                }
            }
        } until ($response.access_token)
        $response
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - [Wait-GitHubAccessToken] - Done"
#endregion [functions] - [private] - [Auth] - [DeviceFlow] - [Wait-GitHubAccessToken]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - [DeviceFlow] - Done"
#endregion [functions] - [private] - [Auth] - [DeviceFlow]
Write-Debug "[$scriptName] - [functions] - [private] - [Auth] - Done"
#endregion [functions] - [private] - [Auth]
#region    [functions] - [private] - [Branches]
Write-Debug "[$scriptName] - [functions] - [private] - [Branches] - Processing folder"
#region    [functions] - [private] - [Branches] - [Get-GitHubBranchList]
Write-Debug "[$scriptName] - [functions] - [private] - [Branches] - [Get-GitHubBranchList] - Importing"
filter Get-GitHubBranchList {
    <#
        .SYNOPSIS
        List branches

        .DESCRIPTION
        Lists all branches from a repository

        .EXAMPLE
        Get-GitHubBranchList -Owner 'octocat' -Repository 'Hello-World'

        Gets all the branches from the 'Hello-World' repository owned by 'octocat'

        .NOTES
        [List branches](https://docs.github.com/rest/branches/branches#list-branches)
    #>
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/branches"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Branches] - [Get-GitHubBranchList] - Done"
#endregion [functions] - [private] - [Branches] - [Get-GitHubBranchList]
Write-Debug "[$scriptName] - [functions] - [private] - [Branches] - Done"
#endregion [functions] - [private] - [Branches]
#region    [functions] - [private] - [Commands]
Write-Debug "[$scriptName] - [functions] - [private] - [Commands] - Processing folder"
#region    [functions] - [private] - [Commands] - [ConvertFrom-GitHubOutput]
Write-Debug "[$scriptName] - [functions] - [private] - [Commands] - [ConvertFrom-GitHubOutput] - Importing"
filter ConvertFrom-GitHubOutput {
    <#
        .SYNOPSIS
        Gets the GitHub output.

        .DESCRIPTION
        Gets the GitHub output from $env:GITHUB_OUTPUT and creates an object with key-value pairs,
        supporting both single-line and multi-line values, and parsing JSON values.

        .EXAMPLE
        $content = @'
        zen=something else
        result={"MyOutput":"Hello, World!","Status":"Success"}
        MY_VALUE<<EOF_12a089b9-051e-4c4e-91c9-8e24fc2fbbf6
        Line1
        Line2
        Line3
        EOF_12a089b9-051e-4c4e-91c9-8e24fc2fbbf6
        Config={"Nested":{"SubSetting":"SubValue"},"Setting1":"Value1","Setting2":2}
        Numbers=12345
        '@

        ConvertFrom-GitHubOutput -OutputContent $content

        zen      : something else
        result   : @{MyOutput=Hello, World!; Status=Success}
        MY_VALUE : Line1
                Line2
                Line3
        Config   : {[Nested, System.Collections.Hashtable], [Setting1, Value1], [Setting2, 2]}
        Numbers  : 12345

        This will convert the GitHub Actions output syntax to a PowerShell object.

    #>
    [OutputType([pscustomobject])]
    [OutputType([hashtable])]
    [CmdletBinding()]
    param(
        # The input data to convert
        [Parameter(Mandatory)]
        [AllowEmptyString()]
        [string] $OutputContent,

        # Whether to convert the input data to a hashtable
        [switch] $AsHashtable
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        Write-Debug "[$stackPath] - Process - Start"
        $lines = $OutputContent -split [System.Environment]::NewLine
        Write-Debug "[$stackPath] - Output lines: $($lines.Count)"
        if ($lines.count -eq 0) {
            return @{}
        }

        $result = @{}
        $i = 0
        $pad = $lines.count.ToString().Length
        while ($i -lt $lines.Count) {
            $lineNumber = ($i + 1).ToString().PadLeft($pad)
            $line = $lines[$i].Trim()
            Write-Debug "[$lineNumber]: [$line]"

            # Check for key=value pattern (single-line)
            if ($line -match '^([^=]+)=(.*)$') {
                Write-Debug ' - Single-line pattern'
                $key = $Matches[1].Trim()
                $value = $Matches[2]

                Write-Debug " - Single-line pattern - [$key] = [$value]"
                # Check for empty value
                if ([string]::IsNullOrWhiteSpace($value) -or [string]::IsNullOrEmpty($value) -or $value.Length -eq 0) {
                    Write-Debug ' - Single-line pattern - Empty value'
                    $result[$key] = ''
                    $i++
                    continue
                }

                # Attempt to parse JSON
                if (Test-Json $value -ErrorAction SilentlyContinue) {
                    Write-Debug ' - Single-line pattern - value is JSON'
                    $value = ConvertFrom-Json $value -AsHashtable:$AsHashtable
                }

                $result[$key] = $value
                $i++
                continue
            }

            # Check for key<<EOF pattern (multi-line)
            if ($line -match '^([^<]+)<<(\S+)$') {
                Write-Debug ' - Multi-line pattern'
                $key = $Matches[1].Trim()
                Write-Debug " - Multi-line pattern' - [$key]"
                $eof_marker = $Matches[2]
                Write-Debug " - Multi-line pattern' - [$key] - [$eof_marker] - Start"
                $i++
                $value_lines = @()                # Read lines until the EOF marker
                while ($i -lt $lines.Count -and $lines[$i] -ne $eof_marker) {
                    $valueItem = $lines[$i]
                    Write-Debug " [$key] <- [$valueItem]"
                    $value_lines += $valueItem
                    $i++
                }

                # Skip the EOF marker
                if ($i -lt $lines.Count -and $lines[$i] -eq $eof_marker) {
                    Write-Debug " - Multi-line pattern' - [$key] - [$eof_marker] - End"
                    $i++
                }

                # Handle special cases:
                # 1. No lines between delimiters = null value
                # 2. One empty line between delimiters = empty string
                if ($value_lines.Count -eq 0) {
                    Write-Debug " - key<<EOF pattern - [$key] - Null value"
                    $result[$key] = $null
                    continue
                } elseif ($value_lines.Count -eq 1 -and [string]::IsNullOrEmpty($value_lines[0])) {
                    Write-Debug " - key<<EOF pattern - [$key] - Empty string"
                    $result[$key] = ''
                    continue
                }

                $value = $value_lines -join [System.Environment]::NewLine                # Attempt to parse JSON
                if (Test-Json $value -ErrorAction SilentlyContinue) {
                    Write-Debug " - key<<EOF pattern - [$key] - value is JSON"
                    # Handle special JSON serialized values for null and empty string
                    if ($value -eq 'null') {
                        $value = $null
                    } elseif ($value -eq '""') {
                        $value = ''
                    } else {
                        $value = ConvertFrom-Json $value -AsHashtable:$AsHashtable
                    }
                }

                $result[$key] = $value
                continue
            }

            # Unexpected line type
            Write-Debug ' - No pattern match - Skipping line'
            $i++
            continue
        }
        Write-Debug "[$stackPath] - Process - End"
    }

    end {
        Write-Debug "[$stackPath] - End - Start"
        if ($AsHashtable) {
            $result
        } else {
            [PSCustomObject]$result
        }
        Write-Debug "[$stackPath] - End - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Commands] - [ConvertFrom-GitHubOutput] - Done"
#endregion [functions] - [private] - [Commands] - [ConvertFrom-GitHubOutput]
#region    [functions] - [private] - [Commands] - [ConvertTo-GitHubOutput]
Write-Debug "[$scriptName] - [functions] - [private] - [Commands] - [ConvertTo-GitHubOutput] - Importing"
filter ConvertTo-GitHubOutput {
    <#
    .SYNOPSIS
        Converts a PowerShell object's properties to expected format for GitHub Actions output syntax.

    .DESCRIPTION
        The function iterates over each property of the provided PowerShell object and writes
        them to a specified file in the format used by GitHub Actions for outputs. It supports:
        - Single-line values (written as key=value).
        - Multi-line string values (using key<<EOF syntax with a unique EOF marker).
        - Converts hashtables and PSCustomObject values to compressed JSON strings.

    .EXAMPLE
        $object = [PSCustomObject]@{
            zen      = 'something else'
            result   = [PSCustomObject]@{ MyOutput = "Hello, World!"; Status = "Success" }
            MY_VALUE = "Line1`nLine2`nLine3"
            Config   = @{ Setting1 = "Value1"; Setting2 = 2; Nested = @{ SubSetting = "SubValue" } }
            Numbers  = 12345
        }

        $object | ConvertTo-GitHubOutput

        zen=something else
        result={"MyOutput":"Hello, World!","Status":"Success"}
        MY_VALUE<<EOF_12a089b9-051e-4c4e-91c9-8e24fc2fbbf6
        Line1
        Line2
        Line3
        EOF_12a089b9-051e-4c4e-91c9-8e24fc2fbbf6
        Config={"Nested":{"SubSetting":"SubValue"},"Setting1":"Value1","Setting2":2}
        Numbers=12345

        This will convert the properties of $object to GitHub Actions output syntax.

    #>
    [OutputType([string])]
    [CmdletBinding()]
    param(
        # The PowerShell object containing the key-value pairs to be saved.
        # Each property of the object represents a key.
        [Parameter(
            Mandatory,
            ValueFromPipeline
        )]
        [object] $InputObject
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $outputLines = @()

        Write-Debug "Input object type: $($InputObject.GetType().Name)"
        Write-Debug 'Input object value:'
        Write-Debug ($InputObject | Out-String)

        if ($InputObject -is [hashtable]) {
            $InputObject = [PSCustomObject]$InputObject
        }
        foreach ($property in $InputObject.PSObject.Properties) {
            $key = $property.Name
            $value = $property.Value

            Write-Debug "Processing property: $key"
            Write-Debug "Property value type: $($null -eq $value ? 'null' : $value.GetType().Name)"
            Write-Debug 'Property value:'
            Write-Debug ($InputObject | Out-String)

            $guid = [Guid]::NewGuid().ToString()
            $EOFMarker = "EOF_$guid"
            $outputLines += "$key<<$EOFMarker"

            # Handle null values - leave a blank line between delimiters for empty string
            # and no blank line for null
            if ($null -eq $value) {
                Write-Debug "Null value for key: $key"
                # No output between delimiters for null
            } elseif ($value -is [string] -and $value -eq '') {
                Write-Debug "Empty string value for key: $key"
                # Add a blank line for empty string
                $outputLines += ''
            } else {
                # For each non-null, non-empty property value:
                if ($value -is [string]) {
                    if (Test-Json $value -ErrorAction SilentlyContinue) {
                        # Normalize valid JSON strings to a consistent format.
                        $value = ($value | ConvertFrom-Json) | ConvertTo-Json -Depth 100 -Compress
                    }
                } else {
                    # For non-string values, convert to JSON.
                    # Special handling for properties that may contain null values
                    try {
                        $value = $value | ConvertTo-Json -Depth 100 -Compress
                    } catch {
                        Write-Debug "Error converting value to JSON: $_"
                        $value = if ($null -eq $value) { 'null' } else { $value.ToString() }
                    }
                }
                $outputLines += $value
            }

            $outputLines += $EOFMarker
        }
        Write-Debug 'Output lines:'
        Write-Debug ($outputLines | Out-String)
        $outputLines
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Commands] - [ConvertTo-GitHubOutput] - Done"
#endregion [functions] - [private] - [Commands] - [ConvertTo-GitHubOutput]
Write-Debug "[$scriptName] - [functions] - [private] - [Commands] - Done"
#endregion [functions] - [private] - [Commands]
#region    [functions] - [private] - [Config]
Write-Debug "[$scriptName] - [functions] - [private] - [Config] - Processing folder"
#region    [functions] - [private] - [Config] - [Get-GitHubEnvironmentType]
Write-Debug "[$scriptName] - [functions] - [private] - [Config] - [Get-GitHubEnvironmentType] - Importing"
function Get-GitHubEnvironmentType {
    <#
        .SYNOPSIS
        Determines the environment type for GitHub Actions.

        .DESCRIPTION
        Determines the environment type for GitHub Actions.

        .OUTPUTS
        System.String
    #>
    [OutputType([string])]
    [CmdletBinding()]
    param()

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if ($script:IsGitHubActions) {
            Write-Debug 'Detected GitHub Actions environment.'
            return 'GHA'
        } elseif ($script:IsFunctionApp) {
            Write-Debug 'Detected Azure Functions environment.'
            return 'AFA'
        } else {
            Write-Debug 'Detected local environment.'
            return 'Local'
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Config] - [Get-GitHubEnvironmentType] - Done"
#endregion [functions] - [private] - [Config] - [Get-GitHubEnvironmentType]
#region    [functions] - [private] - [Config] - [Initialize-GitHubConfig]
Write-Debug "[$scriptName] - [functions] - [private] - [Config] - [Initialize-GitHubConfig] - Importing"
function Initialize-GitHubConfig {
    <#
        .SYNOPSIS
        Initialize the GitHub module configuration.

        .DESCRIPTION
        Initialize the GitHub module configuration.

        .EXAMPLE
        Initialize-GitHubConfig

        Initializes the GitHub module configuration.

        .EXAMPLE
        Initialize-GitHubConfig -Force

        Forces the initialization of the GitHub module configuration.
    #>
    [OutputType([void])]
    [CmdletBinding()]
    param (
        # Force the initialization of the GitHub config.
        [switch] $Force
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        Write-Debug "Force:           [$Force]"
        if ($Force) {
            Write-Debug 'Forcing initialization of GitHubConfig.'
            $context = Set-Context -Context $script:GitHub.DefaultConfig -Vault $script:GitHub.ContextVault -PassThru
            $script:GitHub.Config = [GitHubConfig]$context
            return
        }

        Write-Debug "GitHubConfig ID: [$($script:GitHub.Config.ID)]"
        if ($null -ne $script:GitHub.Config) {
            Write-Debug 'GitHubConfig already initialized and available in memory.'
            return
        }

        Write-Debug 'Attempt to load the stored GitHubConfig from ContextVault'
        $context = Get-Context -ID $script:GitHub.DefaultConfig.ID -Vault $script:GitHub.ContextVault
        if ($context) {
            Write-Debug 'GitHubConfig loaded into memory.'

            Write-Debug 'Checking if new default properties are available in the stored context.'
            $needsUpdate = $false
            $defaultProperties = $script:GitHub.DefaultConfig.PSObject.Properties.Name
            foreach ($propName in $defaultProperties) {
                if (-not $context.PSObject.Properties.Name.Contains($propName)) {
                    Write-Debug "Adding missing property [$propName] from DefaultConfig"
                    $context | Add-Member -MemberType NoteProperty -Name $propName -Value $script:GitHub.DefaultConfig.$propName
                    $needsUpdate = $true
                }
            }
            if ($needsUpdate) {
                Write-Debug 'Updating stored context with new default properties'
                $context = Set-Context -Context $context -Vault $script:GitHub.ContextVault -PassThru
            }

            $script:GitHub.Config = [GitHubConfig]$context
            return
        }
        Write-Debug 'Initializing GitHubConfig from defaults'
        $context = Set-Context -Context $script:GitHub.DefaultConfig -Vault $script:GitHub.ContextVault -PassThru
        $script:GitHub.Config = [GitHubConfig]$context
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
#Requires -Modules @{ ModuleName = 'Context'; RequiredVersion = '8.1.0' }
Write-Debug "[$scriptName] - [functions] - [private] - [Config] - [Initialize-GitHubConfig] - Done"
#endregion [functions] - [private] - [Config] - [Initialize-GitHubConfig]
Write-Debug "[$scriptName] - [functions] - [private] - [Config] - Done"
#endregion [functions] - [private] - [Config]
#region    [functions] - [private] - [Core]
Write-Debug "[$scriptName] - [functions] - [private] - [Core] - Processing folder"
#region    [functions] - [private] - [Core] - [ConvertTo-GitHubGraphQLField]
Write-Debug "[$scriptName] - [functions] - [private] - [Core] - [ConvertTo-GitHubGraphQLField] - Importing"
function ConvertTo-GitHubGraphQLField {
    <#
        .SYNOPSIS
        Converts property names to their corresponding GitHub GraphQL field syntax.

        .DESCRIPTION
        Takes a list of property names, optional additional properties, and a property-to-GraphQL mapping table,
        and returns a string of GraphQL fields suitable for use in a query.

        Properties not found in the mapping table are skipped with a warning.

        .EXAMPLE
        $fields = ConvertTo-GitHubGraphQLField -Property @('Name','Owner') -AdditionalProperty 'Url' -PropertyToGraphQLMap $map
        Returns the GraphQL fields for Name, Owner, and Url.

        .OUTPUTS
        string

        .NOTES
        Properties not found in the mapping table are skipped with a warning.
    #>
    [CmdletBinding()]
    param(
        # The main set of property names to include in the GraphQL query.
        [string[]] $PropertyList,

        # A hashtable mapping property names to their GraphQL field syntax.
        [Parameter(Mandatory)]
        [hashtable] $PropertyToGraphQLMap
    )
    $PropertyList = $PropertyList | Select-Object -Unique
    $mappedProperties = $PropertyList | Where-Object { -not [string]::IsNullOrEmpty($_) } | ForEach-Object {
        if ($PropertyToGraphQLMap.ContainsKey($_)) {
            $PropertyToGraphQLMap[$_]
        } else {
            Write-Warning "Property '$_' is not available. Skipping."
        }
    }

    $mappedProperties = $mappedProperties | Select-Object -Unique
    Write-Debug "Mapped properties:"
    $mappedProperties | ForEach-Object { Write-Debug $_ }
    return ($mappedProperties -join "`n")
}
Write-Debug "[$scriptName] - [functions] - [private] - [Core] - [ConvertTo-GitHubGraphQLField] - Done"
#endregion [functions] - [private] - [Core] - [ConvertTo-GitHubGraphQLField]
Write-Debug "[$scriptName] - [functions] - [private] - [Core] - Done"
#endregion [functions] - [private] - [Core]
#region    [functions] - [private] - [Enterprise]
Write-Debug "[$scriptName] - [functions] - [private] - [Enterprise] - Processing folder"
#region    [functions] - [private] - [Enterprise] - [Get-GitHubEnterpriseByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Enterprise] - [Get-GitHubEnterpriseByName] - Importing"
function Get-GitHubEnterpriseByName {
    <#
        .SYNOPSIS
        Retrieves details about a GitHub Enterprise instance by name (slug).

        .DESCRIPTION
        This function retrieves detailed information about a GitHub Enterprise instance, including its avatar, billing details, storage usage,
        creation date, and other metadata based on the provided name (slug). It returns an object of type GitHubEnterprise populated with this
        information.

        .EXAMPLE
        Get-GitHubEnterpriseByName -Name 'my-enterprise'

        Output:
        ```powershell
        Name              : My Enterprise
        Slug              : my-enterprise
        URL               : https://github.com/enterprises/my-enterprise
        CreatedAt         : 2022-01-01T00:00:00Z
        ViewerIsAdmin     : True
        ```

        Retrieves details about the GitHub Enterprise instance named 'my-enterprise'.

        .OUTPUTS
        GitHubEnterprise

        .NOTES
        An object containing detailed information about the GitHub Enterprise instance, including billing info, URLs, and metadata.
    #>
    [OutputType([GitHubEnterprise])]
    [CmdletBinding()]
    param(
        # The name (slug) of the GitHub Enterprise instance to retrieve.
        [Parameter(Mandatory)]
        [Alias('Slug')]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $graphQLFields = ([GitHubEnterprise]::PropertyToGraphQLMap).Values

        $enterpriseQuery = @{
            query     = @"
query(`$Slug: String!) {
    enterprise(slug: `$Slug) {
        $graphQLFields
    }
}
"@
            Variables = @{
                Slug = $Name
            }
            Context   = $Context
        }
        $enterpriseResult = Invoke-GitHubGraphQLQuery @enterpriseQuery
        [GitHubEnterprise]::new($enterpriseResult.enterprise)
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Enterprise] - [Get-GitHubEnterpriseByName] - Done"
#endregion [functions] - [private] - [Enterprise] - [Get-GitHubEnterpriseByName]
#region    [functions] - [private] - [Enterprise] - [Get-GitHubEnterpriseList]
Write-Debug "[$scriptName] - [functions] - [private] - [Enterprise] - [Get-GitHubEnterpriseList] - Importing"
function Get-GitHubEnterpriseList {
    <#
        .SYNOPSIS
        Retrieves a list of all GitHub Enterprise instances.

        .DESCRIPTION
        This function retrieves detailed information about all GitHub Enterprise instances, including their avatars, billing details, storage usage,
        creation dates, and other metadata. It returns an array of objects of type GitHubEnterprise populated with this information.

        .EXAMPLE
        Get-GitHubEnterpriseList

        Output:
        ```powershell
        Name              : My Enterprise
        Slug              : my-enterprise
        URL               : https://github.com/enterprises/my-enterprise
        CreatedAt         : 2022-01-01T00:00:00Z

        Name              : Another Enterprise
        Slug              : another-enterprise
        URL               : https://github.com/enterprises/another-enterprise
        CreatedAt         : 2021-12-01T00:00:00Z
        ```

        Retrieves details about the GitHub Enterprise instance.

        .OUTPUTS
        GitHubEnterprise[]

        .NOTES
        An array of objects containing detailed information about the GitHub Enterprise instances, including billing info, URLs, and metadata.
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'hasNextPage', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'after', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    [OutputType([GitHubEnterprise[]])]
    [CmdletBinding()]
    param(
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $hasNextPage = $false
        $after = $null
        $perPageSetting = Resolve-GitHubContextSetting -Name 'PerPage' -Value $PerPage -Context $Context

        $graphQLFields = ([GitHubEnterprise]::PropertyToGraphQLMap).Values

        do {
            $enterpriseQuery = @{
                query     = @"
query(`$perPage: Int!, `$after: String) {
    viewer {
        enterprises(first: `$perPage, after: `$after) {
            nodes {
                $graphQLFields
            }
            pageInfo {
                endCursor
                hasNextPage
            }
        }
    }
}
"@
                Variables = @{
                    perPage = $perPageSetting
                    after   = $after
                }
                Context   = $Context
            }
            Invoke-GitHubGraphQLQuery @enterpriseQuery | ForEach-Object {
                foreach ($enterprise in $_.viewer.enterprises.nodes) {
                    [GitHubEnterprise]::new($enterprise)
                }
                $hasNextPage = $_.viewer.enterprises.pageInfo.hasNextPage
                $after = $_.viewer.enterprises.pageInfo.endCursor
            }
        } while ($hasNextPage)
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Enterprise] - [Get-GitHubEnterpriseList] - Done"
#endregion [functions] - [private] - [Enterprise] - [Get-GitHubEnterpriseList]
Write-Debug "[$scriptName] - [functions] - [private] - [Enterprise] - Done"
#endregion [functions] - [private] - [Enterprise]
#region    [functions] - [private] - [Environments]
Write-Debug "[$scriptName] - [functions] - [private] - [Environments] - Processing folder"
#region    [functions] - [private] - [Environments] - [Get-GitHubEnvironmentByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Environments] - [Get-GitHubEnvironmentByName] - Importing"
filter Get-GitHubEnvironmentByName {
    <#
        .SYNOPSIS
        Retrieves details of a specified GitHub environment.

        .DESCRIPTION
        This function retrieves information about a specific environment in a GitHub repository.
        To get information about name patterns that branches must match in order to deploy to this environment,
        see "[Get a deployment branch policy](https://docs.github.com/rest/deployments/branch-policies#get-a-deployment-branch-policy)."

        Anyone with read access to the repository can use this function.
        OAuth app tokens and personal access tokens (classic) need the `repo` scope
        to use this function with a private repository.

        .EXAMPLE
        Get-GitHubEnvironment -Owner 'PSModule' -Repository 'EnvironmentTest' -Name 'test'

        Output:
        ```pwsh
        id                       : 5944178128
        node_id                  : EN_kwDOOJqfM88AAAABYkz10A
        name                     : test
        url                      : https://api.github.com/repos/PSModule/EnvironmentTest/environments/test
        html_url                 : https://github.com/PSModule/EnvironmentTest/deployments/activity_log?environments_filter=test
        created_at               : 3/16/2025 11:17:52 PM
        updated_at               : 3/16/2025 11:17:52 PM
        can_admins_bypass        : True
        protection_rules         : {@{id=30352888; node_id=GA_kwDOOJqfM84BzyX4; type=required_reviewers; prevent_self_review=False;
                                   reviewers=System.Object[]}, @{id=30352889; node_id=GA_kwDOOJqfM84BzyX5; type=wait_timer; wait_timer=100},
                                   @{id=30352890; node_id=GA_kwDOOJqfM84BzyX6; type=branch_policy}}
        deployment_branch_policy : @{protected_branches=False; custom_branch_policies=True}
        ```

        Retrieves details of the "test" environment in the specified repository.

        .OUTPUTS
        GitHubEnvironment

        .NOTES
        Contains environment details, including name, URL, and protection settings.

        .LINK
        https://psmodule.io/GitHub/Functions/Get-GitHubEnvironmentByName/
    #>
    [OutputType([GitHubEnvironment])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Repository,

        # The name of the environment.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $encodedName = [System.Uri]::EscapeDataString($Name)
        $apiParams = @{
            Method  = 'GET'
            Uri     = $Context.ApiBaseUri + "/repos/$Owner/$Repository/environments/$encodedName"
            Context = $Context
        }
        try {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                [GitHubEnvironment]::new($_.Response, $Owner, $Repository, $Context)
            }
        } catch {
            return
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Environments] - [Get-GitHubEnvironmentByName] - Done"
#endregion [functions] - [private] - [Environments] - [Get-GitHubEnvironmentByName]
#region    [functions] - [private] - [Environments] - [Get-GitHubEnvironmentList]
Write-Debug "[$scriptName] - [functions] - [private] - [Environments] - [Get-GitHubEnvironmentList] - Importing"
filter Get-GitHubEnvironmentList {
    <#
        .SYNOPSIS
        Lists the environments for a repository.

        .DESCRIPTION
        Lists the environments available in a specified GitHub repository.
        Anyone with read access to the repository can use this endpoint.
        OAuth app tokens and personal access tokens (classic) need the `repo` scope
        to use this endpoint with a private repository.

        .EXAMPLE
        Get-GitHubEnvironmentList -Owner 'PSModule' -Repository 'EnvironmentTest'

        Output:
        ```pwsh
        id                       : 5944178128
        node_id                  : EN_kwDOOJqfM88AAAABYkz10A
        name                     : test
        url                      : https://api.github.com/repos/PSModule/EnvironmentTest/environments/test
        html_url                 : https://github.com/PSModule/EnvironmentTest/deployments/activity_log?environments_filter=test
        created_at               : 3/16/2025 11:17:52 PM
        updated_at               : 3/16/2025 11:17:52 PM
        can_admins_bypass        : True
        protection_rules         : {@{id=30352888; node_id=GA_kwDOOJqfM84BzyX4; type=required_reviewers; prevent_self_review=False;
                                   reviewers=System.Object[]}, @{id=30352889; node_id=GA_kwDOOJqfM84BzyX5; type=wait_timer; wait_timer=100},
                                   @{id=30352890; node_id=GA_kwDOOJqfM84BzyX6; type=branch_policy}}
        deployment_branch_policy : @{protected_branches=False; custom_branch_policies=True}
        ```

        Lists all environments available in the "EnvironmentTest" repository owned by "PSModule".

        .OUTPUTS
        GitHubEnvironment[]

        .NOTES
        Contains details of each environment in the repository, including its name and protection settings.

        .NOTES
        [List environments](https://docs.github.com/rest/deployments/environments#list-environments)
    #>
    [OutputType([GitHubEnvironment[]])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Repository,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/environments"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($environment in $_.Response.environments) {
                [GitHubEnvironment]::new($environment, $Owner, $Repository, $Context)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Environments] - [Get-GitHubEnvironmentList] - Done"
#endregion [functions] - [private] - [Environments] - [Get-GitHubEnvironmentList]
Write-Debug "[$scriptName] - [functions] - [private] - [Environments] - Done"
#endregion [functions] - [private] - [Environments]
#region    [functions] - [private] - [Gitignore]
Write-Debug "[$scriptName] - [functions] - [private] - [Gitignore] - Processing folder"
#region    [functions] - [private] - [Gitignore] - [Get-GitHubGitignoreByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Gitignore] - [Get-GitHubGitignoreByName] - Importing"
filter Get-GitHubGitignoreByName {
    <#
        .SYNOPSIS
        Get a gitignore template

        .DESCRIPTION
        The API also allows fetching the source of a single template.
        Use the raw [media type](https://docs.github.com/rest/overview/media-types/) to get the raw contents.

        .EXAMPLE
        Get-GitHubGitignoreList

        Get all gitignore templates

        .NOTES
        https://docs.github.com/rest/gitignore/gitignore#get-a-gitignore-template

    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/gitignore/templates/$Name"
            Accept      = 'application/vnd.github.raw+json'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Gitignore] - [Get-GitHubGitignoreByName] - Done"
#endregion [functions] - [private] - [Gitignore] - [Get-GitHubGitignoreByName]
#region    [functions] - [private] - [Gitignore] - [Get-GitHubGitignoreList]
Write-Debug "[$scriptName] - [functions] - [private] - [Gitignore] - [Get-GitHubGitignoreList] - Importing"
filter Get-GitHubGitignoreList {
    <#
        .SYNOPSIS
        Get all gitignore templates

        .DESCRIPTION
        List all templates available to pass as an option when
        [creating a repository](https://docs.github.com/rest/repos/repos#create-a-repository-for-the-authenticated-user).

        .EXAMPLE
        Get-GitHubGitignoreList

        Get all gitignore templates

        .NOTES
        https://docs.github.com/rest/gitignore/gitignore#get-all-gitignore-templates

    #>
    [OutputType([string[]])]
    [CmdletBinding()]
    param(
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/gitignore/templates'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Gitignore] - [Get-GitHubGitignoreList] - Done"
#endregion [functions] - [private] - [Gitignore] - [Get-GitHubGitignoreList]
Write-Debug "[$scriptName] - [functions] - [private] - [Gitignore] - Done"
#endregion [functions] - [private] - [Gitignore]
#region    [functions] - [private] - [License]
Write-Debug "[$scriptName] - [functions] - [private] - [License] - Processing folder"
#region    [functions] - [private] - [License] - [Get-GitHubLicenseByName]
Write-Debug "[$scriptName] - [functions] - [private] - [License] - [Get-GitHubLicenseByName] - Importing"
filter Get-GitHubLicenseByName {
    <#
        .SYNOPSIS
        Get a license

        .DESCRIPTION
        Gets information about a specific license.
        For more information, see "[Licensing a repository ](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository)."

        .EXAMPLE
        Get-GitHubGitignoreList

        Get all gitignore templates

        .NOTES
        https://docs.github.com/rest/licenses/licenses#get-a-license

    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [CmdletBinding()]
    param(
        # The license keyword, license name, or license SPDX ID. For example, mit or mpl-2.0.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/licenses/$Name"
            Accept      = 'application/vnd.github+json'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubLicense]::New($_.Response)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [License] - [Get-GitHubLicenseByName] - Done"
#endregion [functions] - [private] - [License] - [Get-GitHubLicenseByName]
#region    [functions] - [private] - [License] - [Get-GitHubLicenseList]
Write-Debug "[$scriptName] - [functions] - [private] - [License] - [Get-GitHubLicenseList] - Importing"
filter Get-GitHubLicenseList {
    <#
        .SYNOPSIS
        Get all commonly used licenses

        .DESCRIPTION
        Lists the most commonly used licenses on GitHub.
        For more information, see "[Licensing a repository ](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository)."

        .EXAMPLE
        Get-GitHubLicenseList

        Get all commonly used licenses.

        .OUTPUTS
        GitHubLicense[]

        .NOTES
        [Get all commonly used licenses](https://docs.github.com/rest/licenses/licenses#get-all-commonly-used-licenses)
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [OutputType([GitHubLicense[]])]
    [CmdletBinding()]
    param(
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/licenses'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response | ForEach-Object { [GitHubLicense]::New($_) }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [License] - [Get-GitHubLicenseList] - Done"
#endregion [functions] - [private] - [License] - [Get-GitHubLicenseList]
#region    [functions] - [private] - [License] - [Get-GitHubRepositoryLicense]
Write-Debug "[$scriptName] - [functions] - [private] - [License] - [Get-GitHubRepositoryLicense] - Importing"
filter Get-GitHubRepositoryLicense {
    <#
        .SYNOPSIS
        Get the license for a repository

        .DESCRIPTION
        This method returns the contents of the repository's license file, if one is detected.

        Similar to [Get repository content](https://docs.github.com/rest/repos/contents#get-repository-content), this method also supports
        [custom media types](https://docs.github.com/rest/overview/media-types) for retrieving the raw license content or rendered license HTML.

        .EXAMPLE
        Get-GitHubRepositoryLicense -Owner 'octocat' -Repository 'Hello-World'

        Get the license for the Hello-World repository from the octocat account.

        .OUTPUTS
        GitHubLicense

        .NOTES
        [Get the license for a repository](https://docs.github.com/rest/licenses/licenses#get-the-license-for-a-repository)
    #>
    [OutputType([GitHubLicense])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The type of data to return. Can be either 'raw' or 'html'.
        [Parameter()]
        [ValidateSet('raw', 'html')]
        [string] $Type = 'raw',

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $contentType = switch ($Type) {
            'raw' { 'application/vnd.github.raw+json' }
            'html' { 'application/vnd.github.html+json' }
        }

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/license"
            ContentType = $contentType
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $Response = $_.Response
            $rawContent = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Response.content))
            $Response | Add-Member -NotePropertyName 'raw_content' -NotePropertyValue $rawContent -Force
            $Response
        }
    }
    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [License] - [Get-GitHubRepositoryLicense] - Done"
#endregion [functions] - [private] - [License] - [Get-GitHubRepositoryLicense]
Write-Debug "[$scriptName] - [functions] - [private] - [License] - Done"
#endregion [functions] - [private] - [License]
#region    [functions] - [private] - [Organization]
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - Processing folder"
#region    [functions] - [private] - [Organization] - [Get-GitHubAllOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Get-GitHubAllOrganization] - Importing"
filter Get-GitHubAllOrganization {
    <#
        .SYNOPSIS
        List organizations

        .DESCRIPTION
        Lists all organizations, in the order that they were created on GitHub.

        **Note:** Pagination is powered exclusively by the `since` parameter.
        Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of organizations.

        .EXAMPLE
        Get-GitHubAllOrganization -Since 142951047

        List organizations, starting with PSModule

        .OUTPUTS
        GitHubOrganization

        .NOTES
        [List organizations](https://docs.github.com/rest/orgs/orgs#list-organizations)
    #>
    [OutputType([GitHubOrganization])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [CmdletBinding()]
    param(
        # A organization ID. Only return organizations with an ID greater than this ID.
        [Parameter()]
        [int] $Since = 0,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            since = $Since
        }

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/organizations'
            Body        = $body
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($organization in $_.Response) {
                [GitHubOrganization]::new($organization, $Context)
            }
        }
    }
    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Get-GitHubAllOrganization] - Done"
#endregion [functions] - [private] - [Organization] - [Get-GitHubAllOrganization]
#region    [functions] - [private] - [Organization] - [Get-GitHubOrganizationByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Get-GitHubOrganizationByName] - Importing"
filter Get-GitHubOrganizationByName {
    <#
        .SYNOPSIS
        Get an organization

        .DESCRIPTION
        To see many of the organization response values, you need to be an authenticated organization
        owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`,
        the organization requires all members, billing managers, and outside collaborators to enable
        [two-factor authentication](https://docs.github.com/articles/securing-your-account-with-two-factor-authentication-2fa/).

        GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information
        about an organization's GitHub plan. See
        "[Authenticating with GitHub Apps](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/)"
        for details. For an example response, see 'Response with GitHub plan information' below."

        .EXAMPLE
        Get-GitHubOrganizationByName -Name 'github'

        Get the 'GitHub' organization

        .OUTPUTS
        GitHubOrganization

        .NOTES
        [Get an organization](https://docs.github.com/rest/orgs/orgs#get-an-organization)
    #>
    [OutputType([GitHubOrganization])]
    [CmdletBinding()]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Name"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubOrganization]::new($_.Response, $Context)
        }
    }
    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Get-GitHubOrganizationByName] - Done"
#endregion [functions] - [private] - [Organization] - [Get-GitHubOrganizationByName]
#region    [functions] - [private] - [Organization] - [Get-GitHubOrganizationListForAuthUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Get-GitHubOrganizationListForAuthUser] - Importing"
function Get-GitHubOrganizationListForAuthUser {
    <#
        .SYNOPSIS
        Retrieves a list of all GitHub organizations for the authenticated user.

        .DESCRIPTION
        This function retrieves detailed information about all GitHub organizations that the authenticated user belongs to, including their avatars,
        creation dates, member counts, and other metadata. It returns an array of objects of type GitHubOrganization populated with this information.

        .EXAMPLE
        Get-GitHubOrganizationListForAuthUser

        Output:
        ```powershell
        Name              : MyOrganization
        Login             : my-org
        URL               : https://github.com/my-org
        CreatedAt         : 2022-01-01T00:00:00Z

        Name              : Another Organization
        Login             : another-org
        URL               : https://github.com/another-org
        CreatedAt         : 2021-12-01T00:00:00Z
        ```

        Retrieves details about the GitHub organizations the authenticated user belongs to.

        .OUTPUTS
        GitHubOrganization[]

        .NOTES
        An array of objects containing detailed information about the GitHub organizations, including member info, URLs, and metadata.
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'hasNextPage', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'after', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    [OutputType([GitHubOrganization[]])]
    [CmdletBinding()]
    param(
        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $hasNextPage = $false
        $after = $null
        $perPageSetting = Resolve-GitHubContextSetting -Name 'PerPage' -Value $PerPage -Context $Context

        $graphQLFields = ([GitHubOrganization]::PropertyToGraphQLMap).Values

        do {
            $organizationQuery = @{
                query     = @"
query(`$perPage: Int!, `$after: String) {
    viewer {
        organizations(first: `$perPage, after: `$after) {
            nodes {
                $graphQLFields
            }
            pageInfo {
                endCursor
                hasNextPage
            }
        }
    }
}
"@
                Variables = @{
                    perPage = $perPageSetting
                    after   = $after
                }
                Context   = $Context
            }
            Invoke-GitHubGraphQLQuery @organizationQuery | ForEach-Object {
                foreach ($organization in $_.viewer.organizations.nodes) {
                    [GitHubOrganization]::new($organization, $Context)
                }
                $hasNextPage = $_.viewer.organizations.pageInfo.hasNextPage
                $after = $_.viewer.organizations.pageInfo.endCursor
            }
        } while ($hasNextPage)
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Get-GitHubOrganizationListForAuthUser] - Done"
#endregion [functions] - [private] - [Organization] - [Get-GitHubOrganizationListForAuthUser]
#region    [functions] - [private] - [Organization] - [Get-GitHubUserOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Get-GitHubUserOrganization] - Importing"
filter Get-GitHubUserOrganization {
    <#
        .SYNOPSIS
        List organizations for a user

        .DESCRIPTION
        List [public organization memberships](https://docs.github.com/articles/publicizing-or-concealing-organization-membership)
        for the specified user.

        This method only lists _public_ memberships, regardless of authentication.
        If you need to fetch all of the organization memberships (public and private) for the authenticated user, use the
        [List organizations for the authenticated user](https://docs.github.com/rest/orgs/orgs#list-organizations-for-the-authenticated-user)
        API instead.

        .EXAMPLE
        Get-GitHubUserOrganization -Username 'octocat'

        List public organizations for the user 'octocat'.

        .OUTPUTS
        GitHubOrganization

        .NOTES
        [List organizations for a user](https://docs.github.com/rest/orgs/orgs#list-organizations-for-a-user)
    #>
    [OutputType([GitHubOrganization])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(Mandatory)]
        [string] $Username,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/users/$Username/orgs"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($organization in $_.Response) {
                [GitHubOrganization]::new($organization, $Context)
            }
        }
    }
    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Get-GitHubUserOrganization] - Done"
#endregion [functions] - [private] - [Organization] - [Get-GitHubUserOrganization]
#region    [functions] - [private] - [Organization] - [Blocking]
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Blocking] - Processing folder"
#region    [functions] - [private] - [Organization] - [Blocking] - [Block-GitHubUserByOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Blocking] - [Block-GitHubUserByOrganization] - Importing"
filter Block-GitHubUserByOrganization {
    <#
        .SYNOPSIS
        Block a user from an organization

        .DESCRIPTION
        Blocks the given user on behalf of the specified organization and returns a 204.
        If the organization cannot block the given user a 422 is returned.

        .EXAMPLE
        Block-GitHubUserByOrganization -Organization 'github' -Username 'octocat'

        Blocks the user 'octocat' from the organization 'github'.
        Returns $true if successful, $false if not.

        .NOTES
        https://docs.github.com/rest/orgs/blocking#block-a-user-from-an-organization
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Organization,

        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Username,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/orgs/$Organization/blocks/$Username"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Blocking] - [Block-GitHubUserByOrganization] - Done"
#endregion [functions] - [private] - [Organization] - [Blocking] - [Block-GitHubUserByOrganization]
#region    [functions] - [private] - [Organization] - [Blocking] - [Get-GitHubBlockedUserByOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Blocking] - [Get-GitHubBlockedUserByOrganization] - Importing"
filter Get-GitHubBlockedUserByOrganization {
    <#
        .SYNOPSIS
        List users blocked by an organization

        .DESCRIPTION
        List the users blocked by an organization.

        .EXAMPLE
        Get-GitHubBlockedUserByOrganization -Organization 'github'

        Lists all users blocked by the organization `github`.

        .NOTES
        [List users blocked by an organization](https://docs.github.com/rest/orgs/blocking#list-users-blocked-by-an-organization)
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('login')]
        [string] $Organization,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Organization/blocks"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }
    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Blocking] - [Get-GitHubBlockedUserByOrganization] - Done"
#endregion [functions] - [private] - [Organization] - [Blocking] - [Get-GitHubBlockedUserByOrganization]
#region    [functions] - [private] - [Organization] - [Blocking] - [Test-GitHubBlockedUserByOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Blocking] - [Test-GitHubBlockedUserByOrganization] - Importing"
filter Test-GitHubBlockedUserByOrganization {
    <#
        .SYNOPSIS
        Check if a user is blocked by an organization

        .DESCRIPTION
        Returns a 204 if the given user is blocked by the given organization.
        Returns a 404 if the organization is not blocking the user, or if the user account has been identified as spam by GitHub.

        .EXAMPLE
        Test-GitHubBlockedUserByOrganization -Organization 'PSModule' -Username 'octocat'

        Checks if the user `octocat` is blocked by the organization `PSModule`.
        Returns true if the user is blocked, false if not.

        .NOTES
        https://docs.github.com/rest/orgs/blocking#check-if-a-user-is-blocked-by-an-organization
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Organization,

        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Username,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Organization/blocks/$Username"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Blocking] - [Test-GitHubBlockedUserByOrganization] - Done"
#endregion [functions] - [private] - [Organization] - [Blocking] - [Test-GitHubBlockedUserByOrganization]
#region    [functions] - [private] - [Organization] - [Blocking] - [Unblock-GitHubUserByOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Blocking] - [Unblock-GitHubUserByOrganization] - Importing"
filter Unblock-GitHubUserByOrganization {
    <#
        .SYNOPSIS
        Unblock a user from an organization

        .DESCRIPTION
        Unblocks the given user on behalf of the specified organization.

        .EXAMPLE
        Unblock-GitHubUserByOrganization -Organization 'github' -Username 'octocat'

        Unblocks the user 'octocat' from the organization 'github'.
        Returns $true if successful.

        .NOTES
        https://docs.github.com/rest/orgs/blocking#unblock-a-user-from-an-organization
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Organization,

        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/orgs/$Organization/blocks/$Username"
            Context     = $Context
        }
        Invoke-GitHubAPI @apiParams
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Blocking] - [Unblock-GitHubUserByOrganization] - Done"
#endregion [functions] - [private] - [Organization] - [Blocking] - [Unblock-GitHubUserByOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - [Blocking] - Done"
#endregion [functions] - [private] - [Organization] - [Blocking]
Write-Debug "[$scriptName] - [functions] - [private] - [Organization] - Done"
#endregion [functions] - [private] - [Organization]
#region    [functions] - [private] - [Releases]
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - Processing folder"
#region    [functions] - [private] - [Releases] - [Get-GitHubReleaseAll]
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Get-GitHubReleaseAll] - Importing"
filter Get-GitHubReleaseAll {
    <#
        .SYNOPSIS
        List releases

        .DESCRIPTION
        This returns a list of releases, which does not include regular Git tags that have not been associated with a release.
        To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/repos/repos#list-repository-tags).
        Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.

        .EXAMPLE
        Get-GitHubReleaseAll -Owner 'octocat' -Repository 'hello-world'

        Gets all the releases for the repository 'hello-world' owned by 'octocat'.

        .INPUTS
        GitHubRepository

        .OUTPUTS
        GitHubRelease

        .NOTES
        [List releases](https://docs.github.com/rest/releases/releases#list-releases)
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'hasNextPage', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'after', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    [OutputType([GitHubRelease])]
    [CmdletBinding(SupportsPaging)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $hasNextPage = $true
        $after = $null
        $perPageSetting = Resolve-GitHubContextSetting -Name 'PerPage' -Value $PerPage -Context $Context

        do {
            $apiParams = @{
                Query     = @'
query($owner: String!, $repository: String!, $perPage: Int, $after: String) {
  repository(owner: $owner, name: $repository) {
    releases(first: $perPage, after: $after) {
      nodes {
        id
        databaseId
        tagName
        name
        description
        isLatest
        isDraft
        isPrerelease
        url
        createdAt
        publishedAt
        updatedAt
        author {
          login
        }
      }
      pageInfo {
        endCursor
        hasNextPage
      }
    }
  }
}
'@
                Variables = @{
                    owner      = $Owner
                    repository = $Repository
                    perPage    = $perPageSetting
                    after      = $after
                }
                Context   = $Context
            }

            Invoke-GitHubGraphQLQuery @apiParams | ForEach-Object {
                foreach ($release in $_.repository.releases.nodes) {
                    [GitHubRelease]::new($release, $Owner, $Repository, $null)
                }
                $hasNextPage = $_.repository.releases.pageInfo.hasNextPage
                $after = $_.repository.releases.pageInfo.endCursor
            }
        } while ($hasNextPage)
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Get-GitHubReleaseAll] - Done"
#endregion [functions] - [private] - [Releases] - [Get-GitHubReleaseAll]
#region    [functions] - [private] - [Releases] - [Get-GitHubReleaseByID]
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Get-GitHubReleaseByID] - Importing"
filter Get-GitHubReleaseByID {
    <#
        .SYNOPSIS
        Get a release

        .DESCRIPTION
        **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets.
        This key is a [hypermedia resource](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia).

        .EXAMPLE
        Get-GitHubReleaseById -Owner 'octocat' -Repository 'hello-world' -ID '1234567'

        Gets the release with the ID '1234567' for the repository 'hello-world' owned by 'octocat'.

        .INPUTS
        GitHubRepository

        .OUTPUTS
        GitHubRelease

        .NOTES
        [Get a release](https://docs.github.com/rest/releases/releases#get-a-release)
    #>
    [OutputType([GitHubRelease])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The unique identifier of the release.
        [Parameter(Mandatory)]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $latest = Get-GitHubReleaseLatest -Owner $Owner -Repository $Repository -Context $Context

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/releases/$ID"
            Context     = $Context
        }

        try {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                $isLatest = $_.Response.id -eq $latest.id
                [GitHubRelease]::new($_.Response, $Owner, $Repository, $isLatest)
            }
        } catch { return }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Get-GitHubReleaseByID] - Done"
#endregion [functions] - [private] - [Releases] - [Get-GitHubReleaseByID]
#region    [functions] - [private] - [Releases] - [Get-GitHubReleaseByTagName]
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Get-GitHubReleaseByTagName] - Importing"
filter Get-GitHubReleaseByTagName {
    <#
        .SYNOPSIS
        Get a release by tag name

        .DESCRIPTION
        Get a published release with the specified tag.

        .EXAMPLE
        Get-GitHubReleaseByTagName -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0.0'

        Gets the release with the tag 'v1.0.0' for the repository 'hello-world' owned by 'octocat'.

        .INPUTS
        GitHubRepository

        .OUTPUTS
        GitHubRelease

        .NOTES
        [Get a release by tag name](https://docs.github.com/rest/releases/releases#get-a-release-by-tag-name)
    #>
    [OutputType([GitHubRelease])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the tag to get a release from.
        [Parameter(Mandatory)]
        [string] $Tag,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Query     = @'
query($owner: String!, $repository: String!, $tag: String!) {
  repository(owner: $owner, name: $repository) {
    release(tagName: $tag) {
      id
      databaseId
      tagName
      name
      description
      isLatest
      isDraft
      isPrerelease
      url
      createdAt
      publishedAt
      updatedAt
      author {
        login
      }
    }
  }
}
'@
            Variables = @{
                owner      = $Owner
                repository = $Repository
                tag        = $Tag
            }
            Context   = $Context
        }

        Invoke-GitHubGraphQLQuery @apiParams | ForEach-Object {
            $release = $_.repository.release
            if ($release) {
                [GitHubRelease]::new($release, $Owner, $Repository, $null)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Get-GitHubReleaseByTagName] - Done"
#endregion [functions] - [private] - [Releases] - [Get-GitHubReleaseByTagName]
#region    [functions] - [private] - [Releases] - [Get-GitHubReleaseLatest]
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Get-GitHubReleaseLatest] - Importing"
filter Get-GitHubReleaseLatest {
    <#
        .SYNOPSIS
        Get the latest release

        .DESCRIPTION
        View the latest published full release for the repository.
        The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute.
        The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.

        .EXAMPLE
        Get-GitHubReleaseLatest -Owner 'octocat' -Repository 'hello-world'

        Gets the latest releases for the repository 'hello-world' owned by 'octocat'.

        .INPUTS
        GitHubRepository

        .OUTPUTS
        GitHubRelease

        .NOTES
        [Get the latest release](https://docs.github.com/rest/releases/releases#get-the-latest-release)
    #>
    [OutputType([GitHubRelease])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Query     = @'
query($owner: String!, $repository: String!) {
  repository(owner: $owner, name: $repository) {
    latestRelease {
      id
      databaseId
      tagName
      name
      description
      isLatest
      isDraft
      isPrerelease
      url
      createdAt
      publishedAt
      updatedAt
      author {
        login
      }
    }
  }
}
'@
            Variables = @{
                owner      = $Owner
                repository = $Repository
            }
            Context   = $Context
        }

        Invoke-GitHubGraphQLQuery @apiParams | ForEach-Object {
            $release = $_.repository.latestRelease
            if ($release) {
                [GitHubRelease]::new($release, $Owner, $Repository, $null)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Get-GitHubReleaseLatest] - Done"
#endregion [functions] - [private] - [Releases] - [Get-GitHubReleaseLatest]
#region    [functions] - [private] - [Releases] - [Assets]
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Assets] - Processing folder"
#region    [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetByID]
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetByID] - Importing"
filter Get-GitHubReleaseAssetByID {
    <#
        .SYNOPSIS
        Get a release asset by ID

        .DESCRIPTION
        To download the asset's binary content, set the `Accept` header of the request to
        [`application/octet-stream`](https://docs.github.com/rest/overview/media-types).
        The API will either redirect the client to the location, or stream it directly if
        possible. API clients should handle both a `200` or `302` response.

        .EXAMPLE
        Get-GitHubReleaseAssetByID -Owner 'octocat' -Repository 'hello-world' -ID '1234567'

        Gets the release asset with the ID '1234567' for the repository 'octocat/hello-world'.

        .OUTPUTS
        GitHubReleaseAsset

        .NOTES
        https://docs.github.com/rest/releases/assets#get-a-release-asset
    #>
    [OutputType([GitHubReleaseAsset])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The unique identifier of the asset.
        [Parameter(Mandatory)]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/releases/assets/$ID"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubReleaseAsset]::new($_.Response)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetByID] - Done"
#endregion [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetByID]
#region    [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetByReleaseID]
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetByReleaseID] - Importing"
filter Get-GitHubReleaseAssetByReleaseID {
    <#
        .SYNOPSIS
        List release assets

        .DESCRIPTION
        List release assets

        .EXAMPLE
        Get-GitHubReleaseAssetByReleaseID -Owner 'octocat' -Repository 'hello-world' -ID '1234567'

        Gets the release assets for the release with the ID '1234567' for the repository 'octocat/hello-world'.

        .EXAMPLE
        Get-GitHubReleaseAssetByReleaseID -Owner 'octocat' -Repository 'hello-world' -ID '1234567' -Name 'example.zip'

        Gets only the release asset named 'example.zip' for the release with the ID '1234567'.

        .NOTES
        https://docs.github.com/rest/releases/assets#list-release-assets

    #>
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The unique identifier of the release.
        [Parameter(Mandatory)]
        [string] $ID,

        # The name of a specific asset to return. If provided, only the asset with this name will be returned.
        [Parameter()]
        [string] $Name,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/releases/$ID/assets"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($asset in $_.Response) {
                if ($PSBoundParameters.ContainsKey('Name')) {
                    if ($asset.name -eq $Name) {
                        [GitHubReleaseAsset]::new($asset)
                        break
                    }
                } else {
                    [GitHubReleaseAsset]::new($asset)
                }
            }
        }
    }
    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetByReleaseID] - Done"
#endregion [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetByReleaseID]
#region    [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetByTag]
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetByTag] - Importing"
filter Get-GitHubReleaseAssetByTag {
    <#
        .SYNOPSIS
        Get release assets by tag name

        .DESCRIPTION
        Gets all assets from a release identified by its tag name.
        Uses pagination to retrieve all assets even if there are more than the maximum per page.

        .EXAMPLE
        Get-GitHubReleaseAssetByTag -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0.0'

        Gets all release assets for the release with the tag 'v1.0.0' for the repository 'octocat/hello-world'.

        .EXAMPLE
        Get-GitHubReleaseAssetByTag -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0.0' -Name 'app.zip'

        Gets a specific release asset named 'app.zip' from the release with the tag 'v1.0.0' for the repository 'octocat/hello-world'.

        .OUTPUTS
        GitHubReleaseAsset
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'hasNextPage', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'after', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    [OutputType([GitHubReleaseAsset])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the tag to get a release from.
        [Parameter(Mandatory)]
        [string] $Tag,

        # The name of the asset to get. If specified, only assets with this name will be returned.
        [Parameter()]
        [string] $Name,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $hasNextPage = $true
        $after = $null
        $nameParam = $PSBoundParameters.ContainsKey('Name') ? ", name: ""$Name""" : ''
        $perPageSetting = Resolve-GitHubContextSetting -Name 'PerPage' -Value $PerPage -Context $Context

        do {
            $apiParams = @{
                Query     = @"
query(`$owner: String!, `$repository: String!, `$tag: String!, `$perPage: Int, `$after: String) {
  repository(owner: `$owner, name: `$repository) {
    release(tagName: `$tag) {
      releaseAssets(first: `$perPage, after: `$after$nameParam) {
        nodes {
          id
          name
          contentType
          size
          downloadCount
          downloadUrl
          url
          createdAt
          updatedAt
          uploadedBy {
            login
          }
        }
        pageInfo {
          endCursor
          hasNextPage
        }
      }
    }
  }
}
"@
                Variables = @{
                    owner      = $Owner
                    repository = $Repository
                    tag        = $Tag
                    perPage    = $perPageSetting
                    after      = $after
                }
                Context   = $Context
            }

            Invoke-GitHubGraphQLQuery @apiParams | ForEach-Object {
                $release = $_.repository.release
                $assets = $release.releaseAssets
                foreach ($asset in $assets.nodes) {
                    [GitHubReleaseAsset]::new($asset)
                }
                $hasNextPage = $assets.pageInfo.hasNextPage
                $after = $assets.pageInfo.endCursor
            }
        } while ($hasNextPage)
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetByTag] - Done"
#endregion [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetByTag]
#region    [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetFromLatest]
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetFromLatest] - Importing"
filter Get-GitHubReleaseAssetFromLatest {
    <#
        .SYNOPSIS
        Get the assets of the latest release

        .DESCRIPTION
        Gets all assets for the latest published full release for the repository.
        The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute.
        The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.

        .EXAMPLE
        Get-GitHubReleaseAssetFromLatest -Owner 'octocat' -Repository 'hello-world'

        Gets the assets for the latest release of the repository 'hello-world' owned by 'octocat'.

        .EXAMPLE
        Get-GitHubReleaseAssetFromLatest -Owner 'octocat' -Repository 'hello-world' -Name 'asset-name'

        Gets the assets for the latest release of the repository 'hello-world' owned by 'octocat'.

        .INPUTS
        GitHubRepository

        .OUTPUTS
        GitHubReleaseAsset
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'hasNextPage', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'after', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    [OutputType([GitHubReleaseAsset])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the asset to get. If specified, only assets with this name will be returned.
        [Parameter()]
        [string] $Name,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $hasNextPage = $true
        $after = $null
        $nameParam = $PSBoundParameters.ContainsKey('Name') ? ", name: x$Name""" : ''
        $perPageSetting = Resolve-GitHubContextSetting -Name 'PerPage' -Value $PerPage -Context $Context

        do {
            $apiParams = @{
                Query     = @"
query(`$owner: String!, `$repository: String!, `$perPage: Int, `$after: String) {
  repository(owner: `$owner, name: `$repository) {
    latestRelease {
      releaseAssets(first: `$perPage, after: `$after$nameParam) {
        nodes {
          id
          name
          contentType
          size
          downloadCount
          downloadUrl
          url
          createdAt
          updatedAt
          uploadedBy {
            login
          }
        }
        pageInfo {
          endCursor
          hasNextPage
        }
      }
    }
  }
}
"@
                Variables = @{
                    owner      = $Owner
                    repository = $Repository
                    perPage    = $perPageSetting
                    after      = $after
                }
                Context   = $Context
            }

            Invoke-GitHubGraphQLQuery @apiParams | ForEach-Object {
                $release = $_.repository.latestRelease
                $assets = $release.releaseAssets
                foreach ($asset in $assets.nodes) {
                    [GitHubReleaseAsset]::new($asset)
                }
                $hasNextPage = $assets.pageInfo.hasNextPage
                $after = $assets.pageInfo.endCursor
            }
        } while ($hasNextPage)
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetFromLatest] - Done"
#endregion [functions] - [private] - [Releases] - [Assets] - [Get-GitHubReleaseAssetFromLatest]
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - [Assets] - Done"
#endregion [functions] - [private] - [Releases] - [Assets]
Write-Debug "[$scriptName] - [functions] - [private] - [Releases] - Done"
#endregion [functions] - [private] - [Releases]
#region    [functions] - [private] - [Repositories]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - Processing folder"
#region    [functions] - [private] - [Repositories] - [Get-GitHubMyRepositories]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Get-GitHubMyRepositories] - Importing"
filter Get-GitHubMyRepositories {
    <#
        .SYNOPSIS
        List repositories for the authenticated user.

        .DESCRIPTION
        Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
        The authenticated user has explicit permission to access repositories they own, repositories where
        they are a collaborator, and repositories that they can access through an organization membership.

        .EXAMPLE
        Get-GitHubMyRepositories

        Gets the repositories for the authenticated user.

        .EXAMPLE
        Get-GitHubMyRepositories -Visibility 'private'

        Gets the private repositories for the authenticated user.

        .OUTPUTS
        GitHubRepository

        .NOTES
        [List repositories for the authenticated user](https://docs.github.com/rest/repos/repos#list-repositories-for-the-authenticated-user)
    #>
    [OutputType([GitHubRepository])]
    [CmdletBinding()]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseSingularNouns', '',
        Justification = 'Private function, not exposed to user.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'hasNextPage', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'after', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    param(
        # Limit the results to repositories with a visibility level.
        [ValidateSet('Internal', 'Private', 'Public')]
        [Parameter()]
        [string] $Visibility,

        # Limit the results to repositories where the user has this role.
        [ValidateSet('Owner', 'Collaborator', 'Organization_member')]
        [Parameter()]
        [string[]] $Affiliation = 'Owner',

        # Properties to include in the returned object.
        [Parameter()]
        [string[]] $Property = @('Name', 'Owner', 'Url', 'Size', 'Visibility'),

        # Additional properties to include in the returned object.
        [Parameter()]
        [string[]] $AdditionalProperty,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $hasNextPage = $true
        $after = $null
        $perPageSetting = Resolve-GitHubContextSetting -Name 'PerPage' -Value $PerPage -Context $Context

        $graphParams = @{
            PropertyList         = $Property + $AdditionalProperty
            PropertyToGraphQLMap = [GitHubRepository]::PropertyToGraphQLMap
        }
        $graphQLFields = ConvertTo-GitHubGraphQLField @graphParams

        do {
            $apiParams = @{
                Query     = @"
query(
    `$PerPage: Int!,
    `$Cursor: String,
    `$Affiliations: [RepositoryAffiliation!],
    `$Visibility: RepositoryVisibility,
    `$IsArchived: Boolean,
    `$IsFork: Boolean
) {
  viewer {
    repositories(
        first: `$PerPage,
        after: `$Cursor,
        affiliations: `$Affiliations,
        visibility: `$Visibility,
        isArchived: `$IsArchived,
        isFork: `$IsFork
    ) {
      nodes {
$graphQLFields
      }
      pageInfo {
        endCursor
        hasNextPage
      }
    }
  }
}
"@
                Variables = @{
                    PerPage      = $perPageSetting
                    Cursor       = $after
                    Affiliations = $Affiliation | ForEach-Object { $_.ToString().ToUpper() }
                    Visibility   = -not [string]::IsNullOrEmpty($Visibility) ? $Visibility.ToString().ToUpper() : $null
                    IsArchived   = $IsArchived
                    IsFork       = $IsFork
                }
                Context   = $Context
            }

            Invoke-GitHubGraphQLQuery @apiParams | ForEach-Object {
                $_.viewer.repositories.nodes | ForEach-Object {
                    [GitHubRepository]::new($_)
                }
                $hasNextPage = $response.pageInfo.hasNextPage
                $after = $response.pageInfo.endCursor
            }
        } while ($hasNextPage)
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Get-GitHubMyRepositories] - Done"
#endregion [functions] - [private] - [Repositories] - [Get-GitHubMyRepositories]
#region    [functions] - [private] - [Repositories] - [Get-GitHubMyRepositoryByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Get-GitHubMyRepositoryByName] - Importing"
filter Get-GitHubMyRepositoryByName {
    <#
        .SYNOPSIS
        List repositories for the authenticated user.

        .DESCRIPTION
        Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
        The authenticated user has explicit permission to access repositories they own, repositories where
        they are a collaborator, and repositories that they can access through an organization membership.

        .EXAMPLE
        Get-GitHubMyRepositoryByName

        Gets the repositories for the authenticated user.

        .OUTPUTS
        GitHubRepository
    #>
    [OutputType([GitHubRepository])]
    [CmdletBinding()]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseSingularNouns', '',
        Justification = 'Private function, not exposed to user.'
    )]
    param(
        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # Properties to include in the returned object.
        [Parameter()]
        [string[]] $Property = @(
            'ID',
            'NodeID'
            'Name',
            'Owner',
            'FullName',
            'Url',
            'Description',
            'CreatedAt',
            'UpdatedAt',
            'PushedAt',
            'ArchivedAt',
            'Homepage',
            'Size',
            'Language',
            'HasIssues',
            'HasProjects',
            'HasWiki',
            'HasDiscussions',
            'HasSponsorships',
            'IsArchived',
            'IsTemplate',
            'IsFork',
            'License',
            'AllowForking',
            'RequireWebCommitSignoff',
            'Topics',
            'Visibility',
            'OpenIssues',
            'OpenPullRequests',
            'Stargazers',
            'Watchers',
            'Forks',
            'DefaultBranch',
            'Permission',
            'AllowSquashMerge',
            'AllowMergeCommit',
            'AllowRebaseMerge',
            'AllowAutoMerge',
            'DeleteBranchOnMerge',
            'SuggestUpdateBranch',
            'SquashMergeCommitTitle',
            'SquashMergeCommitMessage',
            'MergeCommitTitle',
            'MergeCommitMessage',
            'TemplateRepository',
            'ForkRepository',
            'CustomProperties',
            'CloneUrl',
            'SshUrl',
            'GitUrl'
        ),

        # Additional properties to include in the returned object.
        [Parameter()]
        [string[]] $AdditionalProperty,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $graphParams = @{
            PropertyList         = $Property + $AdditionalProperty
            PropertyToGraphQLMap = [GitHubRepository]::PropertyToGraphQLMap
        }
        $graphQLFields = ConvertTo-GitHubGraphQLField @graphParams

        $apiParams = @{
            Query     = @"
query(
    `$Name: String!
) {
  viewer {
    repository(
      name: `$Name
    ) {
$graphQLFields
    }
  }
}
"@
            Variables = @{
                Name = $Name
            }
            Context   = $Context
        }

        Invoke-GitHubGraphQLQuery @apiParams | ForEach-Object {
            [GitHubRepository]::new($_.viewer.repository)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Get-GitHubMyRepositoryByName] - Done"
#endregion [functions] - [private] - [Repositories] - [Get-GitHubMyRepositoryByName]
#region    [functions] - [private] - [Repositories] - [Get-GitHubRepositoryByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Get-GitHubRepositoryByName] - Importing"
filter Get-GitHubRepositoryByName {
    <#
        .SYNOPSIS
        Get a repository

        .DESCRIPTION
        The `parent` and `source` objects are present when the repository is a fork.
        `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
        **Note:** In order to see the `security_and_analysis` block for a repository you must have admin permissions
        for the repository or be an owner or security manager for the organization that owns the repository.
        For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

        .EXAMPLE
        Get-GitHubRepositoryByName -Owner 'octocat' -Name 'Hello-World'

        Gets the repository 'Hello-World' for the organization 'octocat'.

        .OUTPUTS
        GitHubRepository
    #>
    [OutputType([GitHubRepository])]
    [CmdletBinding()]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # Properties to include in the returned object.
        [Parameter()]
        [string[]] $Property = @(
            'ID',
            'NodeID'
            'Name',
            'Owner',
            'FullName',
            'Url',
            'Description',
            'CreatedAt',
            'UpdatedAt',
            'PushedAt',
            'ArchivedAt',
            'Homepage',
            'Size',
            'Language',
            'HasIssues',
            'HasProjects',
            'HasWiki',
            'HasDiscussions',
            'HasSponsorships',
            'IsArchived',
            'IsTemplate',
            'IsFork',
            'License',
            'AllowForking',
            'RequireWebCommitSignoff',
            'Topics',
            'Visibility',
            'OpenIssues',
            'OpenPullRequests',
            'Stargazers',
            'Watchers',
            'Forks',
            'DefaultBranch',
            'Permission',
            'AllowSquashMerge',
            'AllowMergeCommit',
            'AllowRebaseMerge',
            'AllowAutoMerge',
            'DeleteBranchOnMerge',
            'SuggestUpdateBranch',
            'SquashMergeCommitTitle',
            'SquashMergeCommitMessage',
            'MergeCommitTitle',
            'MergeCommitMessage',
            'TemplateRepository',
            'ForkRepository',
            'CustomProperties',
            'CloneUrl',
            'SshUrl',
            'GitUrl'
        ),

        # Additional properties to include in the returned object.
        [Parameter()]
        [string[]] $AdditionalProperty,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $graphParams = @{
            PropertyList         = $Property + $AdditionalProperty
            PropertyToGraphQLMap = [GitHubRepository]::PropertyToGraphQLMap
        }
        $graphQLFields = ConvertTo-GitHubGraphQLField @graphParams

        $apiParams = @{
            Query     = @"
query(
    `$Owner: String!,
    `$Name: String!
) {
  repositoryOwner(
    login: `$Owner
  ) {
    repository(
        name: `$Name
    ) {
$graphQLFields
    }
  }
}
"@
            Variables = @{
                Owner = $Owner
                Name  = $Name
            }
            Context   = $Context
        }

        Invoke-GitHubGraphQLQuery @apiParams | ForEach-Object {
            [GitHubRepository]::new($_.repositoryOwner.repository)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Get-GitHubRepositoryByName] - Done"
#endregion [functions] - [private] - [Repositories] - [Get-GitHubRepositoryByName]
#region    [functions] - [private] - [Repositories] - [Get-GitHubRepositoryByNameAndTeam]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Get-GitHubRepositoryByNameAndTeam] - Importing"
filter Get-GitHubRepositoryByNameAndTeam {
    <#
        .SYNOPSIS
        Get the permission level for a team on a repository.

        .DESCRIPTION
        Retrieves the permission level assigned to a specific team for a given GitHub repository.

        .EXAMPLE
        Get-GitHubRepositoryByNameAndTeam -Owner 'octocat' -Name 'Hello-World' -Team 'core'

        Output:
        ```powershell

        ```

        Retrieves the permission of the 'core' team on the 'Hello-World' repository owned by 'octocat'.

        .INPUTS
        GitHubRepository

        .OUTPUTS
        GitHubRepository

        .NOTES
        [Check team permissions for a repository](https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-repository)
    #>
    [OutputType([GitHubRepository])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Name,

        # The slug of the team to add or update repository permissions for.
        [Parameter(Mandatory)]
        [Alias('Slug', 'TeamSlug')]
        [string] $Team,

        # The owner of the team. If not specified, the owner will default to the value of -Owner.
        [Parameter()]
        [string] $TeamOwner,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $TeamOwner = [string]::IsNullOrEmpty($TeamOwner) ? $Owner : $TeamOwner
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$TeamOwner/teams/$Team/repos/$Owner/$Name"
            Accept      = 'application/vnd.github.v3.repository+json'
            Context     = $Context
        }
        try {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                [GitHubRepository]::new($_.Response)
            }
        } catch {
            Write-Debug "Team '$Team' does not have access to repository $Owner/$Name."
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Get-GitHubRepositoryByNameAndTeam] - Done"
#endregion [functions] - [private] - [Repositories] - [Get-GitHubRepositoryByNameAndTeam]
#region    [functions] - [private] - [Repositories] - [Get-GitHubRepositoryListByOwner]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Get-GitHubRepositoryListByOwner] - Importing"
filter Get-GitHubRepositoryListByOwner {
    <#
        .SYNOPSIS
        List repositories for a user

        .DESCRIPTION
        Lists public repositories for the specified user.
        Note: For GitHub AE, this endpoint will list internal repositories for the specified user.

        .EXAMPLE
        Get-GitHubRepositoryListByOwner -Owner 'octocat'

        Gets the repositories for the user 'octocat'.

        .EXAMPLE
        Get-GitHubRepositoryListByOwner -Owner 'octocat' -Type 'member'

        Gets the repositories of organizations where the user 'octocat' is a member.

        .EXAMPLE
        Get-GitHubRepositoryListByOwner -Owner 'octocat' -Sort 'created' -Direction 'asc'

        Gets the repositories for the user 'octocat' sorted by creation date in ascending order.

        .OUTPUTS
        GitHubRepository

        .NOTES
        [List repositories for a user](https://docs.github.com/rest/repos/repos#list-repositories-for-a-user)
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'hasNextPage', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseDeclaredVarsMoreThanAssignments', 'after', Scope = 'Function',
        Justification = 'Unknown issue with var scoping in blocks.'
    )]
    [OutputType([GitHubRepository])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # Limit the results to repositories with a visibility level.
        [ValidateSet('Internal', 'Private', 'Public')]
        [Parameter()]
        [string] $Visibility,

        # Limit the results to repositories where the user has this role.
        [ValidateSet('Owner', 'Collaborator', 'Organization_member')]
        [Parameter()]
        [string[]] $Affiliation,

        # Limit the results to repositories where the owner has this affiliation (e.g., OWNER only).
        [ValidateSet('Owner', 'Collaborator', 'Organization_member')]
        [Parameter()]
        [string[]] $OwnerAffiliations = 'Owner',

        # Properties to include in the returned object.
        [Parameter()]
        [string[]] $Property = @('Name', 'Owner', 'Url', 'Size', 'Visibility'),

        # Additional properties to include in the returned object.
        [Parameter()]
        [string[]] $AdditionalProperty = @(),

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $hasNextPage = $true
        $after = $null
        $perPageSetting = Resolve-GitHubContextSetting -Name 'PerPage' -Value $PerPage -Context $Context
        $graphParams = @{
            PropertyList         = $Property + $AdditionalProperty
            PropertyToGraphQLMap = [GitHubRepository]::PropertyToGraphQLMap
        }
        $graphQLFields = ConvertTo-GitHubGraphQLField @graphParams

        do {
            $apiParams = @{
                Query     = @"
query(
    `$Owner: String!,
    `$PerPage: Int!,
    `$Cursor: String,
    `$Affiliations: [RepositoryAffiliation],
    `$OwnerAffiliations: [RepositoryAffiliation!],
    `$Visibility: RepositoryVisibility,
    `$IsArchived: Boolean,
    `$IsFork: Boolean
) {
  repositoryOwner(
    login: `$Owner
  ) {
    repositories(
        first: `$PerPage,
        after: `$Cursor,
        affiliations: `$Affiliations,
        ownerAffiliations: `$OwnerAffiliations,
        visibility: `$Visibility,
        isArchived: `$IsArchived,
        isFork: `$IsFork
    ) {
      nodes {
        $graphQLFields
      }
      pageInfo {
        endCursor
        hasNextPage
      }
    }
  }
}
"@
                Variables = @{
                    Owner             = $Owner
                    PerPage           = $perPageSetting
                    Cursor            = $after
                    Affiliations      = [string]::IsNullOrEmpty($Affiliation) ? $null : $Affiliation.ToUpper()
                    OwnerAffiliations = [string]::IsNullOrEmpty($OwnerAffiliations) ? $null : $OwnerAffiliations.ToUpper()
                    Visibility        = [string]::IsNullOrEmpty($Visibility) ? $null : $Visibility.ToUpper()
                    IsArchived        = $IsArchived
                    IsFork            = $IsFork
                }
                Context   = $Context
            }

            Invoke-GitHubGraphQLQuery @apiParams | ForEach-Object {
                foreach ($repository in $_.repositoryOwner.repositories.nodes) {
                    [GitHubRepository]::new($repository)
                }
                $hasNextPage = $_.repositoryOwner.repositories.pageInfo.hasNextPage
                $after = $_.repositoryOwner.repositories.pageInfo.endCursor
            }
        } while ($hasNextPage)
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Get-GitHubRepositoryListByOwner] - Done"
#endregion [functions] - [private] - [Repositories] - [Get-GitHubRepositoryListByOwner]
#region    [functions] - [private] - [Repositories] - [Get-GitHubRepositoryListByTeam]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Get-GitHubRepositoryListByTeam] - Importing"
filter Get-GitHubRepositoryListByTeam {
    <#
        .SYNOPSIS
        List team repositories.

        .DESCRIPTION
        Lists a team's repositories visible to the authenticated user.

        .EXAMPLE
        Get-GitHubRepositoryListByTeam -Owner 'octocat' -Team 'core'

        Output:
        ```powershell
        ```

        Lists all repositories that the 'core' team has access to in the organization owned by 'octocat'.

        .INPUTS
        GitHubRepository

        .OUTPUTS
        GitHubRepository

        .NOTES
        [List team repositories](https://docs.github.com/rest/teams/teams#list-team-repositories)
    #>
    [OutputType([GitHubRepository])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The slug of the team to add or update repository permissions for.
        [Parameter(Mandatory)]
        [Alias('Slug', 'TeamSlug')]
        [string] $Team,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Owner/teams/$Team/repos"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($repo in $_.Response) {
                [GitHubRepository]::new($repo)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Get-GitHubRepositoryListByTeam] - Done"
#endregion [functions] - [private] - [Repositories] - [Get-GitHubRepositoryListByTeam]
#region    [functions] - [private] - [Repositories] - [New-GitHubRepositoryAsFork]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [New-GitHubRepositoryAsFork] - Importing"
filter New-GitHubRepositoryAsFork {
    <#
        .SYNOPSIS
        Create a fork

        .DESCRIPTION
        Create a fork for the authenticated user.

        **Note**: Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects.
        If this takes longer than 5 minutes, be sure to contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).

        **Note**: Although this endpoint works with GitHub Apps, the GitHub App must be installed on the destination account with access to all
        repositories and on the source account with access to the source repository.

        .EXAMPLE
        New-GitHubRepositoryAsFork -ForkOwner 'github' -ForkRepository 'Hello-World'

        Fork the repository `Hello-World` owned by `github` for the authenticated user.
        Repo will be named `Hello-World`, and all branches and tags will be forked.

        .EXAMPLE
        New-GitHubRepositoryAsFork -ForkOwner 'github' -ForkRepository 'Hello-World' -Name 'Hello-World-2'

        Fork the repository `Hello-World` owned by `github` for the authenticated user, naming the resulting repository `Hello-World-2`.

        .EXAMPLE
        New-GitHubRepositoryAsFork -ForkOwner 'github' -ForkRepository 'Hello-World' -Owner 'octocat'

        Fork the repository `Hello-World` owned by `github` for the organization `octocat`, naming the resulting repository `Hello-World`.

        .EXAMPLE
        New-GitHubRepositoryAsFork -ForkOwner 'github' -ForkRepository 'Hello-World' -IncludeAllBranches

        Fork the repository `Hello-World` owned by `github` for the authenticated user, including all the branches from the source.

        .OUTPUTS
        GitHubRepository

        .NOTES
        [Create a fork](https://docs.github.com/rest/repos/forks#create-a-fork)
    #>
    [OutputType([GitHubRepository])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $ForkOwner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $ForkRepository,

        # The organization or person who will own the new repository.
        # To create a new repository in an organization, the authenticated user must be a member of the specified organization.
        [Parameter()]
        [string] $Owner,

        # The name of the new repository.
        [Parameter()]
        [string] $Name,

        # Include all branches from the source repository.
        [Parameter()]
        [bool] $IncludeAllBranches,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            organization        = $Owner
            name                = $Name
            default_branch_only = -not $IncludeAllBranches
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/repos/$ForkOwner/$ForkRepository/forks"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Repository [$Owner/$Name] as fork of [$ForkOwner/$ForkRepository]", 'Create')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                [GitHubRepository]::New($_.Response)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [New-GitHubRepositoryAsFork] - Done"
#endregion [functions] - [private] - [Repositories] - [New-GitHubRepositoryAsFork]
#region    [functions] - [private] - [Repositories] - [New-GitHubRepositoryFromTemplate]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [New-GitHubRepositoryFromTemplate] - Importing"
filter New-GitHubRepositoryFromTemplate {
    <#
        .SYNOPSIS
        Create a repository using a template

        .DESCRIPTION
        Creates a new repository using a repository template. Use the `template_owner` and `template_repo`
        route parameters to specify the repository to use as the template. If the repository is not public,
        the authenticated user must own or be a member of an organization that owns the repository.
        To check if a repository is available to use as a template, get the repository's information using the
        [Get a repository](https://docs.github.com/rest/repos/repos#get-a-repository) endpoint and check that the `is_template` key is `true`.

        **OAuth scope requirements**

        When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:

        * `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
        * `repo` scope to create a private repository

        .EXAMPLE
        $params = @{
            TemplateOwner      = 'GitHub'
            TemplateRepository = 'octocat'
            Owner              = 'PSModule'
            Name               = 'MyNewRepo'
            IncludeAllBranches = $true
            Description        = 'My new repo'
            Private            = $true
        }
        New-GitHubRepositoryFromTemplate @params

        Creates a new private repository named `MyNewRepo` from the `octocat` template repository owned by `GitHub`.

        .OUTPUTS
        GitHubRepository

        .NOTES
        [Create a repository using a template](https://docs.github.com/rest/repos/repos#create-a-repository-using-a-template)
    #>
    [OutputType([GitHubRepository])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the template repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $TemplateOwner,

        # The name of the template repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $TemplateRepository,

        # The organization or person who will own the new repository.
        # To create a new repository in an organization, the authenticated user must be a member of the specified organization.
        [Parameter()]
        [string] $Owner,

        # The name of the new repository.
        [Parameter(Mandatory)]
        [string] $Name,

        # A short description of the new repository.
        [Parameter()]
        [string] $Description,

        # Include all branches from the source repository.
        [Parameter()]
        [bool] $IncludeAllBranches,

        # The visibility of the repository.
        [Parameter()]
        [ValidateSet('Public', 'Private')]
        [string] $Visibility = 'Public',

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            owner                = $Owner
            name                 = $Name
            description          = $Description
            include_all_branches = [bool]$IncludeAllBranches
            private              = $Visibility -eq 'Private'
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/repos/$TemplateOwner/$TemplateRepository/generate"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Repository [$Owner/$Name] from template [$TemplateOwner/$TemplateRepository]", 'Create')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                [GitHubRepository]::New($_.Response)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [New-GitHubRepositoryFromTemplate] - Done"
#endregion [functions] - [private] - [Repositories] - [New-GitHubRepositoryFromTemplate]
#region    [functions] - [private] - [Repositories] - [New-GitHubRepositoryOrg]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [New-GitHubRepositoryOrg] - Importing"
filter New-GitHubRepositoryOrg {
    <#
        .SYNOPSIS
        Create an organization repository

        .DESCRIPTION
        Creates a new repository in the specified organization. The authenticated user must be a member of the organization.

        **OAuth scope requirements**

        When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:

        * `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
        * `repo` scope to create a private repository

        .EXAMPLE
        $params = @{
            Owner                    = 'PSModule'
            Name                     = 'Hello-World'
            Description              = 'This is your first repository'
            Homepage                 = 'https://github.com'
            HasIssues                = $true
            HasProjects              = $true
            HasWiki                  = $true
            IsTemplate               = $true
            AddReadme                = $true
            AllowSquashMerge         = $true
            AllowAutoMerge           = $true
            DeleteBranchOnMerge      = $true
            SquashMergeCommitTitle   = 'PR_TITLE'
            SquashMergeCommitMessage = 'PR_BODY'
        }
        New-GitHubRepositoryOrg @params

        Creates a new public repository named "Hello-World" owned by the organization "PSModule".

        .OUTPUTS
        GitHubRepository

        .NOTES
        [Create an organization repository](https://docs.github.com/rest/repos/repos#create-an-organization-repository)
    #>
    [OutputType([GitHubRepository])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Organization,

        # The name of the repository.
        [Parameter(Mandatory)]
        [string] $Name,

        # A short description of the repository.
        [Parameter()]
        [string] $Description,

        # A URL with more information about the repository.
        [Parameter()]
        [uri] $Homepage,

        # The visibility of the repository.
        [Parameter()]
        [ValidateSet('Public', 'Private', 'Internal')]
        [string] $Visibility = 'Public',

        # Either true to enable issues for this repository or false to disable them.
        [Parameter()]
        [bool] $HasIssues = $true,

        # Either true to enable projects for this repository or false to disable them.
        # Note: If you're creating a repository in an organization that has disabled repository projects, the default is false,
        # and if you pass true, the API returns an error.
        [Parameter()]
        [bool] $HasProjects = $true,

        # Either true to enable the wiki for this repository or false to disable it.
        [Parameter()]
        [bool] $HasWiki = $true,

        # Either true to make this repo available as a template repository or false to prevent it.
        [Parameter()]
        [bool] $IsTemplate = $false,

        # Pass true to create an initial commit with empty README.
        [Parameter()]
        [bool] $AddReadme = $false,

        # The desired language or platform to apply to the .gitignore.
        [Parameter()]
        [string] $Gitignore,

        # The license keyword of the open source license for this repository.
        [Parameter()]
        [string] $License,

        # Either true to allow squash-merging pull requests, or false to prevent squash-merging.
        [Parameter()]
        [bool] $AllowSquashMerge = $true,

        # Either true to allow merging pull requests with a merge commit, or false to prevent merging pull requests with merge commits.
        [Parameter()]
        [bool] $AllowMergeCommit = $true,

        # Either true to allow rebase-merging pull requests, or false to prevent rebase-merging.
        [Parameter()]
        [bool] $AllowRebaseMerge = $true,

        # Either true to allow auto-merge on pull requests, or false to disallow auto-merge.
        [Parameter()]
        [bool] $AllowAutoMerge = $false,

        # Either true to allow automatically deleting head branches when pull requests are merged, or false to prevent automatic deletion.
        # The authenticated user must be an organization owner to set this property to true.
        [Parameter()]
        [bool] $DeleteBranchOnMerge = $false,

        # The default value for a squash merge commit title:
        #   - PR_TITLE - default to the pull request's title.
        #   - COMMIT_OR_PR_TITLE - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
        [Parameter()]
        [ValidateSet('PR_TITLE', 'COMMIT_OR_PR_TITLE')]
        [string] $SquashMergeCommitTitle,

        # The default value for a squash merge commit message:
        #   - PR_BODY - default to the pull request's body.
        #   - COMMIT_MESSAGES - default to the branch's commit messages.
        #   - BLANK - default to a blank commit message.
        [Parameter()]
        [ValidateSet('PR_BODY', 'COMMIT_MESSAGES', 'BLANK')]
        [string] $SquashMergeCommitMessage,

        # The default value for a merge commit title.
        #   - PR_TITLE - default to the pull request's title.
        #   - MERGE_MESSAGE - default to the classic title for a merge message (e.g.,Merge pull request #123 from branch-name).
        [Parameter()]
        [ValidateSet('PR_TITLE', 'MERGE_MESSAGE')]
        [string] $MergeCommitTitle,

        # The default value for a merge commit message.
        #   - PR_BODY - default to the pull request's body.
        #   - PR_TITLE - default to the pull request's title.
        #   - BLANK - default to a blank commit message.
        [Parameter()]
        [ValidateSet('PR_BODY', 'PR_TITLE', 'BLANK')]
        [string] $MergeCommitMessage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            name                        = $Name
            description                 = $Description
            homepage                    = [string]$Homepage
            visibility                  = $Visibility.ToLower()
            has_issues                  = $HasIssues
            has_projects                = $HasProjects
            has_wiki                    = $HasWiki
            is_template                 = $IsTemplate
            auto_init                   = $AddReadme
            allow_squash_merge          = $AllowSquashMerge
            allow_merge_commit          = $AllowMergeCommit
            allow_rebase_merge          = $AllowRebaseMerge
            allow_auto_merge            = $AllowAutoMerge
            delete_branch_on_merge      = $DeleteBranchOnMerge
            squash_merge_commit_title   = $SquashMergeCommitTitle
            squash_merge_commit_message = $SquashMergeCommitMessage
            merge_commit_title          = $MergeCommitTitle
            merge_commit_message        = $MergeCommitMessage
            gitignore_template          = $Gitignore
            license_template            = $License
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/orgs/$Organization/repos"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Repository [$Name] in organization [$Organization]", 'Create')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                [GitHubRepository]::New($_.Response)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [New-GitHubRepositoryOrg] - Done"
#endregion [functions] - [private] - [Repositories] - [New-GitHubRepositoryOrg]
#region    [functions] - [private] - [Repositories] - [New-GitHubRepositoryUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [New-GitHubRepositoryUser] - Importing"
filter New-GitHubRepositoryUser {
    <#
        .SYNOPSIS
        Create a repository for the authenticated user

        .DESCRIPTION
        Creates a new repository for the authenticated user.

        **OAuth scope requirements**

        When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:

        * `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
        * `repo` scope to create a private repository.

        .EXAMPLE
        $params = @{
            Name                     = 'Hello-World'
            Description              = 'This is your first repository'
            Homepage                 = 'https://github.com'
            HasIssues                = $true
            HasProjects              = $true
            HasWiki                  = $true
            IsTemplate               = $true
            AddReadme                = $true
            AllowSquashMerge         = $true
            AllowAutoMerge           = $true
            DeleteBranchOnMerge      = $true
            SquashMergeCommitTitle   = 'PR_TITLE'
            SquashMergeCommitMessage = 'PR_BODY'
        }
        New-GitHubRepositoryUser @params

        Creates a new public repository named "Hello-World" owned by the authenticated user.

        .OUTPUTS
        GitHubRepository

        .NOTES
        [Create a repository for the authenticated user](https://docs.github.com/rest/repos/repos#create-a-repository-for-the-authenticated-user)
    #>
    [OutputType([GitHubRepository])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The name of the repository.
        [Parameter(Mandatory)]
        [string] $Name,

        # A short description of the repository.
        [Parameter()]
        [string] $Description,

        # A URL with more information about the repository.
        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [uri] $Homepage,

        # The visibility of the repository.
        [Parameter()]
        [ValidateSet('Public', 'Private')]
        [string] $Visibility = 'Public',

        # Whether issues are enabled.
        [Parameter()]
        [bool] $HasIssues = $true,

        # Whether projects are enabled.
        [Parameter()]
        [bool] $HasProjects = $true,

        # Whether the wiki is enabled.
        [Parameter()]
        [bool] $HasWiki = $true,

        # Whether discussions are enabled.
        [Parameter()]
        [bool] $HasDiscussions = $true,

        # Whether this repository acts as a template that can be used to generate new repositories.
        [Parameter()]
        [bool] $IsTemplate = $false,

        # Pass true to create an initial commit with empty README.
        [Parameter()]
        [bool] $AddReadme = $false,

        # The desired language or platform to apply to the .gitignore.
        [Parameter()]
        [string] $Gitignore,

        #The license keyword of the open source license for this repository.
        [Parameter()]
        [string] $License,

        # Whether to allow squash merges for pull requests.
        [Parameter()]
        [bool] $AllowSquashMerge = $true,

        # Whether to allow merge commits for pull requests.
        [Parameter()]
        [bool] $AllowMergeCommit = $true,

        # Whether to allow rebase merges for pull requests.
        [Parameter()]
        [bool] $AllowRebaseMerge = $true,

        # Whether to allow Auto-merge to be used on pull requests.
        [Parameter()]
        [bool] $AllowAutoMerge = $false,

        # Whether to delete head branches when pull requests are merged
        [Parameter()]
        [bool] $DeleteBranchOnMerge = $false,

        # The default value for a squash merge commit title:
        #   - PR_TITLE - default to the pull request's title.
        #   - COMMIT_OR_PR_TITLE - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
        [Parameter()]
        [ValidateSet('PR_TITLE', 'COMMIT_OR_PR_TITLE')]
        [string] $SquashMergeCommitTitle,

        # The default value for a squash merge commit message:
        #   - PR_BODY - default to the pull request's body.
        #   - COMMIT_MESSAGES - default to the branch's commit messages.
        #   - BLANK - default to a blank commit message.
        [Parameter()]
        [ValidateSet('PR_BODY', 'COMMIT_MESSAGES', 'BLANK')]
        [string] $SquashMergeCommitMessage,

        # The default value for a merge commit title.
        #   - PR_TITLE - default to the pull request's title.
        #   - MERGE_MESSAGE - default to the classic title for a merge message (e.g.,Merge pull request #123 from branch-name).
        [Parameter()]
        [ValidateSet('PR_TITLE', 'MERGE_MESSAGE')]
        [string] $MergeCommitTitle,

        # The default value for a merge commit message.
        #   - PR_BODY - default to the pull request's body.
        #   - PR_TITLE - default to the pull request's title.
        #   - BLANK - default to a blank commit message.
        [Parameter()]
        [ValidateSet('PR_BODY', 'PR_TITLE', 'BLANK')]
        [string] $MergeCommitMessage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            name                        = $Name
            description                 = $Description
            homepage                    = [string]$Homepage
            has_issues                  = [bool]$HasIssues
            has_projects                = [bool]$HasProjects
            has_wiki                    = [bool]$HasWiki
            has_discussions             = [bool]$HasDiscussions
            is_template                 = [bool]$IsTemplate
            auto_init                   = [bool]$AddReadme
            gitignore_template          = $Gitignore
            license_template            = $License
            allow_squash_merge          = [bool]$AllowSquashMerge
            allow_merge_commit          = [bool]$AllowMergeCommit
            allow_rebase_merge          = [bool]$AllowRebaseMerge
            allow_auto_merge            = [bool]$AllowAutoMerge
            delete_branch_on_merge      = [bool]$DeleteBranchOnMerge
            squash_merge_commit_title   = $SquashMergeCommitTitle
            squash_merge_commit_message = $SquashMergeCommitMessage
            merge_commit_title          = $MergeCommitTitle
            merge_commit_message        = $MergeCommitMessage
            private                     = $Visibility -eq 'Private'
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = '/user/repos'
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess('Repository for user', 'Create')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                [GitHubRepository]::New($_.Response)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [New-GitHubRepositoryUser] - Done"
#endregion [functions] - [private] - [Repositories] - [New-GitHubRepositoryUser]
#region    [functions] - [private] - [Repositories] - [Autolinks]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Autolinks] - Processing folder"
#region    [functions] - [private] - [Repositories] - [Autolinks] - [Get-GitHubRepositoryAutolinkById]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Autolinks] - [Get-GitHubRepositoryAutolinkById] - Importing"
filter Get-GitHubRepositoryAutolinkById {
    <#
        .SYNOPSIS
        Get an autolink reference of a repository

        .DESCRIPTION
        This returns a single autolink reference by ID that was configured for the given repository.

        Information about autolinks are only available to repository administrators.

        .EXAMPLE
        Get-GitHubRepositoryAutolinkById -Owner 'octocat' -Repository 'Hello-World' -ID 1

        Gets the autolink with the ID 1 for the repository 'Hello-World' owned by 'octocat'.

        .NOTES
        https://docs.github.com/rest/repos/autolinks#get-an-autolink-reference-of-a-repository

    #>
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The unique identifier of the autolink.
        [Parameter(Mandatory)]
        [Alias('autolink_id')]
        [Alias('AutolinkId')]
        [int] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/autolinks/$ID"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Autolinks] - [Get-GitHubRepositoryAutolinkById] - Done"
#endregion [functions] - [private] - [Repositories] - [Autolinks] - [Get-GitHubRepositoryAutolinkById]
#region    [functions] - [private] - [Repositories] - [Autolinks] - [Get-GitHubRepositoryAutolinkList]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Autolinks] - [Get-GitHubRepositoryAutolinkList] - Importing"
filter Get-GitHubRepositoryAutolinkList {
    <#
        .SYNOPSIS
        List all autolinks of a repository

        .DESCRIPTION
        This returns a list of autolinks configured for the given repository.

        Information about autolinks are only available to repository administrators.

        .EXAMPLE
        Get-GitHubRepositoryAutolinkList -Owner 'octocat' -Repository 'Hello-World'

        Gets all autolinks for the repository 'Hello-World' owned by 'octocat'.

        .NOTES
        https://docs.github.com/rest/repos/autolinks#list-all-autolinks-of-a-repository

    #>
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/autolinks"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Autolinks] - [Get-GitHubRepositoryAutolinkList] - Done"
#endregion [functions] - [private] - [Repositories] - [Autolinks] - [Get-GitHubRepositoryAutolinkList]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [Autolinks] - Done"
#endregion [functions] - [private] - [Repositories] - [Autolinks]
#region    [functions] - [private] - [Repositories] - [RuleSuite]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [RuleSuite] - Processing folder"
#region    [functions] - [private] - [Repositories] - [RuleSuite] - [Get-GitHubRepositoryRuleSuiteById]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [RuleSuite] - [Get-GitHubRepositoryRuleSuiteById] - Importing"
filter Get-GitHubRepositoryRuleSuiteById {
    <#
        .SYNOPSIS
        Get a repository rule suite

        .DESCRIPTION
        Gets information about a suite of rule evaluations from within a repository.
        For more information, see "[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets)."

        .EXAMPLE
        Get-GitHubRepositoryRuleSuiteById -Owner 'octocat' -Repository 'hello-world' -RuleSuiteId 123456789

        Gets information about a suite of rule evaluations with ID 123456789 from within the octocat/hello-world repository.

        .NOTES
        [Get a repository rule suite](https://docs.github.com/rest/repos/rule-suites#get-a-repository-rule-suite)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/RuleSuite/Get-GitHubRepositoryRuleSuiteById
    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Long links')]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The unique identifier of the rule suite result. To get this ID, you can use GET /repos/ { owner }/ { repo }/rulesets/rule-suites for repositories and GET /orgs/ { org }/rulesets/rule-suites for organizations.
        [Parameter(Mandatory)]
        [int] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/rulesets/rule-suites/$ID"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [RuleSuite] - [Get-GitHubRepositoryRuleSuiteById] - Done"
#endregion [functions] - [private] - [Repositories] - [RuleSuite] - [Get-GitHubRepositoryRuleSuiteById]
#region    [functions] - [private] - [Repositories] - [RuleSuite] - [Get-GitHubRepositoryRuleSuiteList]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [RuleSuite] - [Get-GitHubRepositoryRuleSuiteList] - Importing"
filter Get-GitHubRepositoryRuleSuiteList {
    <#
        .SYNOPSIS
        List repository rule suites

        .DESCRIPTION
        Lists suites of rule evaluations at the repository level.
        For more information, see"[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets)."

        .EXAMPLE
        $params = @{
            Owner           = 'octocat'
            Repo            = 'hello-world'
            Ref             = 'main'
            TimePeriod      = 'day'
            ActorName       = 'octocat'
            RuleSuiteResult = 'all'
        }
        Get-GitHubRepositoryRuleSuiteList @params

        Gets a list of rule suites for the main branch of the hello-world repository owned by octocat.

        .NOTES
        [List repository rule suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/RuleSuite/Get-GitHubRepositoryRuleSuiteList
    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Long links')]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the ref. Cannot contain wildcard characters.
        # When specified, only rule evaluations triggered for this ref will be returned.
        [Parameter()]
        [string] $Ref,

        # The time period to filter by.
        # For example,day will filter for rule suites that occurred in the past 24 hours,
        # and week will filter for insights that occurred in the past 7 days (168 hours).
        [Parameter()]
        [ValidateSet('hour', 'day', 'week', 'month')]
        [string] $TimePeriod = 'day',

        # The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
        [Parameter()]
        [string] $ActorName,

        # The rule results to filter on. When specified, only suites with this result will be returned.
        [Parameter()]
        [ValidateSet('pass', 'fail', 'bypass', 'all')]
        [string] $RuleSuiteResult = 'all',

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            ref               = $Ref
            time_period       = $TimePeriod
            actor_name        = $ActorName
            rule_suite_result = $RuleSuiteResult
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/rulesets/rule-suites"
            Body        = $body
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [RuleSuite] - [Get-GitHubRepositoryRuleSuiteList] - Done"
#endregion [functions] - [private] - [Repositories] - [RuleSuite] - [Get-GitHubRepositoryRuleSuiteList]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - [RuleSuite] - Done"
#endregion [functions] - [private] - [Repositories] - [RuleSuite]
Write-Debug "[$scriptName] - [functions] - [private] - [Repositories] - Done"
#endregion [functions] - [private] - [Repositories]
#region    [functions] - [private] - [Secrets]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - Processing folder"
#region    [functions] - [private] - [Secrets] - [Get-GitHubSecretEnvironmentByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretEnvironmentByName] - Importing"
function Get-GitHubSecretEnvironmentByName {
    <#
        .SYNOPSIS
        Get an environment secret.

        .DESCRIPTION
        Gets a single environment secret without revealing its encrypted value. Authenticated users must have collaborator access to a repository to
        create, update, or read secrets. OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubSecretEnvironmentByName -Owner 'octocat' -Repository 'Hello-World' -Environment 'dev' -Name 'SECRET1' -Context $GitHubContext

        Output:
        ```powershell
        Name                 : SECRET1
        Owner                : octocat
        Repository           : Hello-World
        Environment          : dev
        ```

        Retrieves the specified secret from the specified environment.

        .OUTPUTS
        GitHubSecret

        .NOTES
        Returns an GitHubSecret object containing details about the environment Secret,
        including its name, associated repository, and environment details.

        .NOTES
        [Get an environment secret](https://docs.github.com/rest/actions/secrets#get-an-environment-secret)
    #>
    [OutputType([GitHubSecret])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the environment.
        [Parameter(Mandatory)]
        [string] $Environment,

        # The name of the Secret.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/environments/$Environment/secrets/$Name"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubSecret]::new($_.Response, $Owner, $Repository, $Environment, $null)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretEnvironmentByName] - Done"
#endregion [functions] - [private] - [Secrets] - [Get-GitHubSecretEnvironmentByName]
#region    [functions] - [private] - [Secrets] - [Get-GitHubSecretEnvironmentList]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretEnvironmentList] - Importing"
function Get-GitHubSecretEnvironmentList {
    <#
        .SYNOPSIS
        List environment secrets.

        .DESCRIPTION
        Lists all secrets available in an environment without revealing their encrypted values. Authenticated users must have collaborator access to a
        repository to create, update, or read secrets. OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this
        endpoint.

        .EXAMPLE
        Get-GitHubSecretEnvironmentList -Owner 'octocat' -Repository 'Hello-World' -Environment 'dev' -Context $GitHubContext

        Output:
        ```powershell
        Name                 : SECRET1
        Owner                : octocat
        Repository           : Hello-World
        Environment          : dev

        Name                 : SECRET2
        Owner                : octocat
        Repository           : Hello-World
        Environment          : dev
        ```

        Retrieves all secrets for the specified environment.

        .OUTPUTS
        GitHubSecret[]

        .NOTES
        An array of GitHubSecret objects representing the environment secrets.
        Each object contains Name, CreatedAt, UpdatedAt, Owner, Repository, and Environment properties.

        .NOTES
        [List environment secrets](https://docs.github.com/rest/actions/secrets#list-environment-secrets)
    #>
    [OutputType([GitHubSecret[]])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the environment.
        [Parameter(Mandatory)]
        [string] $Environment,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/environments/$Environment/secrets"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response.secrets | ForEach-Object {
                [GitHubSecret]::new($_, $Owner, $Repository, $Environment, $null)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretEnvironmentList] - Done"
#endregion [functions] - [private] - [Secrets] - [Get-GitHubSecretEnvironmentList]
#region    [functions] - [private] - [Secrets] - [Get-GitHubSecretFromOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretFromOrganization] - Importing"
function Get-GitHubSecretFromOrganization {
    <#
        .SYNOPSIS
        List repository organization secrets.

        .DESCRIPTION
        Lists all organization secrets shared with a repository without revealing their encrypted values. Authenticated users must have collaborator
        access to a repository to create, update, or read secrets. OAuth app tokens and personal access tokens (classic) need the `repo` scope to use
        this endpoint.

        .EXAMPLE
        Get-GitHubSecretFromOrganization -Owner 'octocat' -Repository 'helloworld' -Context (Get-GitHubContext)

        Output:
        ```powershell
        Name                 : SECRET1
        Owner                : octocat
        Repository           :
        Environment          :
        CreatedAt            : 3/17/2025 10:56:22 AM
        UpdatedAt            : 3/17/2025 10:56:22 AM
        Visibility           :
        SelectedRepositories :

        Name                 : SECRET2
        Owner                : octocat
        Repository           :
        Environment          :
        CreatedAt            : 3/17/2025 10:56:39 AM
        UpdatedAt            : 3/17/2025 10:56:39 AM
        Visibility           :
        SelectedRepositories :

        Name                 : TESTSECRET
        Owner                : octocat
        Repository           :
        Environment          :
        CreatedAt            : 3/17/2025 10:56:05 AM
        UpdatedAt            : 3/17/2025 10:56:05 AM
        Visibility           :
        SelectedRepositories :
        ```

        Lists the secrets visible from 'octocat' to the 'helloworld' repository.

        .OUTPUTS
        GitHubSecret[]

        .NOTES
        An array of GitHubSecret objects representing the environment secrets.
        Each object contains Name, CreatedAt, UpdatedAt, Owner, Repository, and Environment properties.

        .NOTES
        [List repository organization secrets](https://docs.github.com/rest/actions/secrets#list-repository-organization-secrets)
    #>
    [OutputType([GitHubSecret[]])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/actions/organization-secrets"
            PerPage     = $PerPage
            Context     = $Context
        }

        try {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                $_.Response.secrets | ForEach-Object {
                    [GitHubSecret]::new($_, $Owner, $null, $null, $null)
                }
            }
        } catch {
            return $null
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretFromOrganization] - Done"
#endregion [functions] - [private] - [Secrets] - [Get-GitHubSecretFromOrganization]
#region    [functions] - [private] - [Secrets] - [Get-GitHubSecretOwnerByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretOwnerByName] - Importing"
function Get-GitHubSecretOwnerByName {
    <#
        .SYNOPSIS
        Create or update an organization secret.

        .DESCRIPTION
        Creates or updates an organization secret with an encrypted value. Encrypt your secret using
        [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see
        "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
        Authenticated users must have collaborator access to a repository to create, update, or read secrets. OAuth tokens and personal access tokens
        (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need
        the `repo` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubSecretOwnerByName -Owner 'octocat' -Name 'SECRET_THING' -Context (Get-GitHubContext)

        Output:
        ```powershell
        Name                 : SECRET_THING
        Owner                : octocat
        Repository           :
        Environment          :
        CreatedAt            : 3/17/2025 10:56:39 AM
        UpdatedAt            : 3/17/2025 10:56:39 AM
        Visibility           : selected
        SelectedRepositories : {hello-world, profile-repo}
        ```

        Retrieves the specified secret from the specified organization.

        .NOTES
        [Create or update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret)
    #>
    [OutputType([GitHubSecret])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the secret.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Owner/actions/secrets/$Name"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $selectedRepositories = @()
            if ($_.Response.visibility -eq 'selected') {
                $selectedRepositories = Get-GitHubSecretSelectedRepository -Owner $Owner -Name $_.Response.name -Context $Context
            }
            [GitHubSecret]::new($_.Response, $Owner, $null, $null, $selectedRepositories)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretOwnerByName] - Done"
#endregion [functions] - [private] - [Secrets] - [Get-GitHubSecretOwnerByName]
#region    [functions] - [private] - [Secrets] - [Get-GitHubSecretOwnerList]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretOwnerList] - Importing"
function Get-GitHubSecretOwnerList {
    <#
        .SYNOPSIS
        List organization secrets.

        .DESCRIPTION
        Lists all secrets available in an organization without revealing their encrypted values. Authenticated users must have collaborator access to
        a repository to create, update, or read secrets. OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this
        endpoint. If the repository is private, the `repo` scope is also required.

        .EXAMPLE
        Get-GitHubSecretOwnerList -Owner 'PSModule' -Context (Get-GitHubContext)

        Output:
        ```powershell
        ```

        Retrieves all secrets from the specified organization.

        .OUTPUTS
        GitHubSecret

        .NOTES
        An array of GitHubSecret objects representing the organization secrets.

        .NOTES
        [List organization secrets](https://docs.github.com/rest/actions/secrets#list-organization-secrets)
    #>
    [OutputType([GitHubSecret[]])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Owner/actions/secrets"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response.secrets | ForEach-Object {
                $selectedRepositories = @()
                if ($_.visibility -eq 'selected') {
                    $selectedRepositories = Get-GitHubSecretSelectedRepository -Owner $Owner -Name $_.name -Context $Context
                }
                [GitHubSecret]::new($_, $Owner, $null, $null, $selectedRepositories)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretOwnerList] - Done"
#endregion [functions] - [private] - [Secrets] - [Get-GitHubSecretOwnerList]
#region    [functions] - [private] - [Secrets] - [Get-GitHubSecretRepositoryByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretRepositoryByName] - Importing"
function Get-GitHubSecretRepositoryByName {
    <#
        .SYNOPSIS
        Get a repository secret.

        .DESCRIPTION
        Gets a single repository secret without revealing its encrypted value. The authenticated user must have collaborator access to the repository
        to use this endpoint. OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubSecretRepositoryByName -Owner 'octocat' -Repository 'Hello-World' -Name 'SECRET1' -Context (Get-GitHubContext)

        Output:
        ```powershell
        Name                 : SECRET1
        Owner                : octocat
        Repository           : Hello-World
        Environment          :
        ```

        Retrieves the specified secret from the specified repository.

        .NOTES
        [Get a repository secret](https://docs.github.com/rest/actions/secrets#get-a-repository-secret)
    #>
    [OutputType([GitHubSecret])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the secret.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/actions/secrets/$Name"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubSecret]::new($_.Response, $Owner, $Repository, $null, $null)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretRepositoryByName] - Done"
#endregion [functions] - [private] - [Secrets] - [Get-GitHubSecretRepositoryByName]
#region    [functions] - [private] - [Secrets] - [Get-GitHubSecretRepositoryList]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretRepositoryList] - Importing"
function Get-GitHubSecretRepositoryList {
    <#
        .SYNOPSIS
        List repository secrets.

        .DESCRIPTION
        Lists all secrets available in a repository without revealing their encrypted values. Authenticated users must have collaborator access to a
        repository to create, update, or read secrets. OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this
        endpoint.

        .EXAMPLE
        Get-GitHubSecretRepositoryList -Owner 'octocat' -Repository 'Hello-World' -Context (Get-GitHubContext)

        Output:
        ```powershell
        Name                 : SECRET1
        Owner                : octocat
        Repository           : Hello-World
        Environment          :

        Name                 : SECRET2
        Owner                : octocat
        Repository           : Hello-World
        Environment          :
        ```

        Retrieves all secrets for the specified repository.

        .OUTPUTS
        GitHubSecret[]

        .NOTES
        An array of GitHubSecret objects representing the environment secrets.
        Each object contains Name, CreatedAt, UpdatedAt, Owner, Repository, and Environment properties.

        .NOTES
        [List repository secrets](https://docs.github.com/rest/actions/secrets#list-repository-secrets)
    #>
    [OutputType([GitHubSecret[]])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/actions/secrets"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response.secrets | ForEach-Object {
                [GitHubSecret]::new($_, $Owner, $Repository, $null, $null)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Get-GitHubSecretRepositoryList] - Done"
#endregion [functions] - [private] - [Secrets] - [Get-GitHubSecretRepositoryList]
#region    [functions] - [private] - [Secrets] - [Remove-GitHubSecretFromEnvironment]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Remove-GitHubSecretFromEnvironment] - Importing"
function Remove-GitHubSecretFromEnvironment {
    <#
        .SYNOPSIS
        Delete an environment secret.

        .DESCRIPTION
        Deletes a secret in an environment using the secret name. Authenticated users must have collaborator access to a repository to create, update,
        or read secrets. OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Remove-GitHubSecretFromEnvironment -Owner 'octocat' -Repository 'Hello-World' -Environment 'dev' -Name 'SECRET1' -Context $GitHubContext

        Deletes the specified secret from the specified environment.

        .NOTES
        [Delete an environment secret](https://docs.github.com/rest/actions/secrets#delete-an-environment-secret)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the repository environment.
        [Parameter(Mandatory)]
        [string] $Environment,

        # The name of the secret.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/repos/$Owner/$Repository/environments/$Environment/secrets/$Name"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("secret [$Name] on [$Owner/$Repository/$Environment]", 'Delete')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Remove-GitHubSecretFromEnvironment] - Done"
#endregion [functions] - [private] - [Secrets] - [Remove-GitHubSecretFromEnvironment]
#region    [functions] - [private] - [Secrets] - [Remove-GitHubSecretFromOwner]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Remove-GitHubSecretFromOwner] - Importing"
function Remove-GitHubSecretFromOwner {
    <#
        .SYNOPSIS
        Delete an organization secret.

        .DESCRIPTION
        Deletes a secret in an organization using the secret name. Authenticated users must have collaborator access to a repository to create,
        update, or read secrets. OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository
        is private, OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Remove-GitHubSecretFromOwner -Owner 'octocat' -Name 'HOST_NAME' -Context $GitHubContext

        Deletes the specified secret from the specified organization.

        .NOTES
        [Delete an organization secret](https://docs.github.com/rest/actions/secrets#delete-an-organization-secret)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the secret.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/orgs/$Owner/actions/secrets/$Name"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("secret [$Name] on [$Owner]", 'Delete')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Remove-GitHubSecretFromOwner] - Done"
#endregion [functions] - [private] - [Secrets] - [Remove-GitHubSecretFromOwner]
#region    [functions] - [private] - [Secrets] - [Remove-GitHubSecretFromRepository]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Remove-GitHubSecretFromRepository] - Importing"
function Remove-GitHubSecretFromRepository {
    <#
        .SYNOPSIS
        Delete a repository secret.

        .DESCRIPTION
        Deletes a secret in a repository using the secret name. Authenticated users must have collaborator access to a repository to create, update,
        or read secrets. OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Remove-GitHubSecretFromRepository -Owner 'octocat' -Repository 'Hello-World' -Name 'SECRET1' -Context $GitHubContext

        Deletes the specified secret from the specified repository.

        .NOTES
        [Delete a repository secret](https://docs.github.com/rest/actions/secrets#delete-a-repository-secret)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the secret.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/repos/$Owner/$Repository/actions/secrets/$Name"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("secret [$Name] on [$Owner/$Repository]", 'Delete')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Remove-GitHubSecretFromRepository] - Done"
#endregion [functions] - [private] - [Secrets] - [Remove-GitHubSecretFromRepository]
#region    [functions] - [private] - [Secrets] - [Set-GitHubSecretOnEnvironment]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Set-GitHubSecretOnEnvironment] - Importing"
function Set-GitHubSecretOnEnvironment {
    <#
        .SYNOPSIS
        Create or update an environment secret.

        .DESCRIPTION
        Creates or updates an environment secret with an encrypted value. Encrypt your secret using
        [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see
        "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
        Authenticated users must have collaborator access to a repository to create, update, or read secrets.
        OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        $params = @{
            Owner       = 'octocat'
            Repository  = 'Hello-World'
            Environment = 'dev'
            Name        = 'SECRET1'
            Value       = 'secret_value
            Context     = $GitHubContext
        }
        Set-GitHubSecretOnEnvironment @params

        Creates a new environment secret named `SECRET1` with the value `secret_value` in the specified environment.

        .NOTES
        [Create or update an environment secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-environment-secret)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the repository environment.
        [Parameter(Mandatory)]
        [string] $Environment,

        # The name of the secret.
        [Parameter(Mandatory)]
        [string] $Name,

        # The encrypted value of the secret.
        [Parameter(Mandatory)]
        [string] $Value,

        # ID of the key you used to encrypt the secret.
        [Parameter(Mandatory)]
        [string] $KeyID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            encrypted_value = $Value
            key_id          = $KeyID
        }

        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/repos/$Owner/$Repository/environments/$Environment/secrets/$Name"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("secret [$Name] on [$Owner/$Repository/$Environment]", 'Set')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Set-GitHubSecretOnEnvironment] - Done"
#endregion [functions] - [private] - [Secrets] - [Set-GitHubSecretOnEnvironment]
#region    [functions] - [private] - [Secrets] - [Set-GitHubSecretOnOwner]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Set-GitHubSecretOnOwner] - Importing"
function Set-GitHubSecretOnOwner {
    <#
        .SYNOPSIS
        Create or update an organization secret.

        .DESCRIPTION
        Creates or updates an organization secret with an encrypted value. Encrypt your secret using
        [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see
        "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
        Authenticated users must have collaborator access to a repository to create, update, or read secrets. OAuth tokens and personal access tokens
        (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need
        the `repo` scope to use this endpoint.

        .EXAMPLE
        Set-GitHubSecretOnOwner -Owner 'octocat' -Name 'HOST_NAME' -Value 'test_value' -Context $GitHubContext

        Creates a new organization secret named `HOST_NAME` with the value `test_value` in the specified organization.

        .NOTES
        [Create or update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the secret.
        [Parameter(Mandatory)]
        [string] $Name,

        # The encrypted value of the secret.
        [Parameter(Mandatory)]
        [string] $Value,

        # ID of the key you used to encrypt the secret.
        [Parameter(Mandatory)]
        [string] $KeyID,

        # The visibility of the secret. Can be `private`, `selected`, or `all`.
        # `private` - The secret is only available to the organization.
        # `selected` - The secret is available to selected repositories.
        # `all` - The secret is available to all repositories in the organization.
        [Parameter()]
        [ValidateSet('private', 'selected', 'all')]
        [string] $Visibility = 'private',

        # The IDs of the repositories to which the secret is available.
        # This parameter is only used when the `-Visibility` parameter is set to `selected`.
        # The IDs can be obtained from the `Get-GitHubRepository` function.
        [Parameter()]
        [UInt64[]] $SelectedRepositories,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            encrypted_value = $Value
            key_id          = $KeyID
            visibility      = $Visibility
        }

        if ($Visibility -eq 'selected') {
            if (-not $SelectedRepositories) {
                throw 'You must specify the -SelectedRepositories parameter when using the -Visibility selected switch.'
            }
            $body['selected_repository_ids'] = $SelectedRepositories
        }

        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/orgs/$Owner/actions/secrets/$Name"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("secret [$Name] on [$Owner]", 'Set')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Set-GitHubSecretOnOwner] - Done"
#endregion [functions] - [private] - [Secrets] - [Set-GitHubSecretOnOwner]
#region    [functions] - [private] - [Secrets] - [Set-GitHubSecretOnRepository]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Set-GitHubSecretOnRepository] - Importing"
function Set-GitHubSecretOnRepository {
    <#
        .SYNOPSIS
        Create or update a repository secret.

        .DESCRIPTION
        Creates or updates a repository secret with an encrypted value. Encrypt your secret using
        [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see
        "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
        Authenticated users must have collaborator access to a repository to create, update, or read secrets.
        OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Set-GitHubSecretOnRepository -Owner 'octocat' -Repository 'Hello-World' -Name 'SECRET1' -Value 'SECRET_VALUE' -Context $GitHubContext

        Creates a new repository secret named `SECRET1` with the value `SECRET_VALUE` in the specified repository.

        .NOTES
        [Create or update a repository secret](https://docs.github.com/rest/actions/secrets#create-or-update-a-repository-secret)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the secret.
        [Parameter(Mandatory)]
        [string] $Name,

        # The encrypted value of the secret.
        [Parameter(Mandatory)]
        [string] $Value,

        # ID of the key you used to encrypt the secret.
        [Parameter(Mandatory)]
        [string] $KeyID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            encrypted_value = $Value
            key_id          = $KeyID
        }

        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/repos/$Owner/$Repository/actions/secrets/$Name"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("secret [$Name] on [$Owner/$Repository]", 'Set')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [Set-GitHubSecretOnRepository] - Done"
#endregion [functions] - [private] - [Secrets] - [Set-GitHubSecretOnRepository]
#region    [functions] - [private] - [Secrets] - [PublicKey]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - Processing folder"
#region    [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForActionOnEnvironment]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForActionOnEnvironment] - Importing"
function Get-GitHubPublicKeyForActionOnEnvironment {
    <#
        .SYNOPSIS
        Get an environment public key.

        .DESCRIPTION
        Get the public key for an environment, which you need to encrypt environment secrets. You need to encrypt a secret before you can create or
        update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private, OAuth tokens and personal
        access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubPublicKeyForActionOnEnvironment -Owner 'octocat' -Repository 'hello-world' -Environment 'prod' -Context $GitHubContext

        Outputs:
        ```powershell
        ID          : 3380204578043523366
        Key         : ypK8XbFOtcXsCaqJOfdWjpCNumPmF3sfAbbv7x+3uSE=                    #gitleaks:allow
        Type        : actions
        Owner       : octocat
        Repository  : hello-world
        Environment : prod
        ```

        Gets the public key for the 'prod' environment in the 'octocat/hello-world' repository using the provided GitHub context.

        .OUTPUTS
        GitHubPublicKey

        .NOTES
        [Get an environment public key](https://docs.github.com/rest/actions/secrets#get-an-environment-public-key)
    #>
    [OutputType([GitHubPublicKey])]
    [CmdletBinding()]
    param (
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the environment.
        [Parameter(Mandatory)]
        [string] $Environment,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/environments/$Environment/secrets/public-key"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubPublicKey]::new($_.Response, 'actions', $Owner, $Repository, $Environment)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForActionOnEnvironment] - Done"
#endregion [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForActionOnEnvironment]
#region    [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForActionOnOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForActionOnOrganization] - Importing"
function Get-GitHubPublicKeyForActionOnOrganization {
    <#
        .SYNOPSIS
        Get an organization public key.

        .DESCRIPTION
        Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. The
        authenticated user must have collaborator access to a repository to create, update, or read secrets. OAuth tokens and personal access tokens
        (classic) need the`admin:org` scope to use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic)
        need the `repo` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubPublicKeyForActionOnOrganization -Owner 'octocat' -Context $GitHubContext

        Outputs:
        ```powershell
        ID          : 3380204578043523366
        Key         : hwzclrjNNtZxYby19+0fiG7LazGFZxaM1IEbB25fkwo=                    #gitleaks:allow
        Type        : actions
        Owner       : octocat
        Repository  :
        Environment :
        ```

        Gets the public key for the organization 'octocat' using the provided GitHub context.

        .OUTPUTS
        GitHubPublicKey

        .NOTES
        [Get an organization public key](https://docs.github.com/rest/actions/secrets#get-an-organization-public-key)
    #>
    [OutputType([GitHubPublicKey])]
    [CmdletBinding()]
    param (
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Owner/actions/secrets/public-key"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubPublicKey]::new($_.Response, 'actions', $Owner, $null, $null)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForActionOnOrganization] - Done"
#endregion [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForActionOnOrganization]
#region    [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForActionOnRepository]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForActionOnRepository] - Importing"
function Get-GitHubPublicKeyForActionOnRepository {
    <#
        .SYNOPSIS
        Get a repository public key.

        .DESCRIPTION
        Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. Anyone with
        read access to the repository can use this endpoint. If the repository is private, OAuth tokens and personal access tokens (classic) need
        the `repo` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubPublicKeyForActionOnRepository -Owner 'octocat' -Repository 'hello-world' -Context $GitHubContext

        Outputs:
        ```powershell
        ID          : 3380204578043523366
        Key         : WkwZZ0xWbxZMqWrfUxLgvnALbrfdZSWxrhBcfTKshDY=                    #gitleaks:allow
        Type        : actions
        Owner       : octocat
        Repository  : hello-world
        Environment :
        ```

        Gets the public key for the 'hellow-world' repository in the 'octocat' organization using the provided GitHub context.

        .OUTPUTS
        GitHubPublicKey

        .NOTES
        [Get a repository public key](https://docs.github.com/rest/actions/secrets#get-a-repository-public-key)
    #>
    [OutputType([GitHubPublicKey])]
    [CmdletBinding()]
    param (
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/actions/secrets/public-key"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubPublicKey]::new($_.Response, 'actions', $Owner, $Repository, $null)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForActionOnRepository] - Done"
#endregion [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForActionOnRepository]
#region    [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForCodespacesOnOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForCodespacesOnOrganization] - Importing"
function Get-GitHubPublicKeyForCodespacesOnOrganization {
    <#
        .SYNOPSIS
        Get an organization public key.

        .DESCRIPTION
        Gets a public key for an organization, which is required in order to encrypt secrets. You need to encrypt the value of a secret before you
        can create or update secrets. OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubPublicKeyForCodespacesOnOrganization -Owner 'octocat' -Context $GitHubContext

        Outputs:
        ```powershell
        ID          : 3380189982652154440
        Key         : XbfD9j2CNq6L2qq2xpYrRhRRdFgR0CzfISQqsAIInGE=                    #gitleaks:allow
        Type        : codespaces
        Owner       : octocat
        Repository  :
        Environment :
        ```

        Gets the public key for the organization 'octocat' using the provided GitHub context.

        .OUTPUTS
        GitHubPublicKey

        .NOTES
        [Get an organization public key](https://docs.github.com/rest/codespaces/organization-secrets#get-an-organization-public-key)
    #>
    [OutputType([GitHubPublicKey])]
    [CmdletBinding()]
    param (
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Owner/codespaces/secrets/public-key"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubPublicKey]::new($_.Response, 'codespaces', $Owner, $null, $null)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForCodespacesOnOrganization] - Done"
#endregion [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForCodespacesOnOrganization]
#region    [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForCodespacesOnRepository]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForCodespacesOnRepository] - Importing"
function Get-GitHubPublicKeyForCodespacesOnRepository {
    <#
        .SYNOPSIS
        Get a repository public key.

        .DESCRIPTION
        Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. If the
        repository is private, OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubPublicKeyForCodespacesOnRepository -Owner 'octocat' -Repository 'hello-world' -Context $GitHubContext

        Outputs:
        ```powershell
        ID          : 3380189982652154440
        Key         : xPliIrAsVlPub63sB1cnvx/CKt5FGb5rjlbF7uHC+hM=                    #gitleaks:allow
        Type        : codespaces
        Owner       : octocat
        Repository  : hello-world
        Environment :
        ```

        Gets the public key for the 'hellow-world' repository in the 'octocat' organization using the provided GitHub context.

        .OUTPUTS
        GitHubPublicKey

        .NOTES
        [Get a repository public key](https://docs.github.com/rest/codespaces/repository-secrets#get-a-repository-public-key)
    #>
    [OutputType([GitHubPublicKey])]
    [CmdletBinding()]
    param (
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/codespaces/secrets/public-key"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubPublicKey]::new($_.Response, 'codespaces', $Owner, $Repository, $null)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForCodespacesOnRepository] - Done"
#endregion [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForCodespacesOnRepository]
#region    [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForCodespacesOnUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForCodespacesOnUser] - Importing"
function Get-GitHubPublicKeyForCodespacesOnUser {
    <#
        .SYNOPSIS
        Get public key for the authenticated user.

        .DESCRIPTION
        Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets.
        The authenticated user must have Codespaces access to use this endpoint.
        OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubPublicKeyForCodespacesOnUser -Context $GitHubContext

        Outputs:
        ```powershell
        ID          : 3380189982652154440
        Key         : dpr7ea5wmASt3ewAYNR/wPiPd6qakxN0060jdBmun0Y=                    #gitleaks:allow
        Type        : codespaces
        Owner       : octocat
        Repository  :
        Environment :
        ```

        Gets the public key for the current user for codespaces using the provided GitHub context.

        .OUTPUTS
        GitHubPublicKey

        .NOTES
        [Get public key for the authenticated user](https://docs.github.com/rest/codespaces/secrets#get-public-key-for-the-authenticated-user)
    #>
    [OutputType([GitHubPublicKey])]
    [CmdletBinding()]
    param (
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/user/codespaces/secrets/public-key'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubPublicKey]::new($_.Response, 'codespaces', $Context.UserName, $null, $null)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForCodespacesOnUser] - Done"
#endregion [functions] - [private] - [Secrets] - [PublicKey] - [Get-GitHubPublicKeyForCodespacesOnUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - [PublicKey] - Done"
#endregion [functions] - [private] - [Secrets] - [PublicKey]
Write-Debug "[$scriptName] - [functions] - [private] - [Secrets] - Done"
#endregion [functions] - [private] - [Secrets]
#region    [functions] - [private] - [Teams]
Write-Debug "[$scriptName] - [functions] - [private] - [Teams] - Processing folder"
#region    [functions] - [private] - [Teams] - [Get-GitHubTeamBySlug]
Write-Debug "[$scriptName] - [functions] - [private] - [Teams] - [Get-GitHubTeamBySlug] - Importing"
function Get-GitHubTeamBySlug {
    <#
        .SYNOPSIS
        Get a team by name

        .DESCRIPTION
        Gets a team using the team's slug. To create the slug, GitHub replaces special characters in the name string, changes all words to lowercase,
        and replaces spaces with a - separator. For example, "My TEam Näme" would become my-team-name.

        .EXAMPLE
        Get-GitHubTeamBySlug -Organization 'github' -Slug 'my-team-name'

        .NOTES
        [Get a team by name](https://docs.github.com/rest/teams/teams#get-a-team-by-name)
    #>
    [OutputType([GitHubTeam])]
    [CmdletBinding()]
    param(
        # The organization name. The name is not case sensitive.
        # If not provided, the owner from the context will be used.
        [Parameter(Mandatory)]
        [string] $Organization,

        # The slug of the team name.
        [Parameter(Mandatory)]
        [string] $Slug,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Organization/teams/$Slug"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubTeam]::new($_.Response, $Organization)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Teams] - [Get-GitHubTeamBySlug] - Done"
#endregion [functions] - [private] - [Teams] - [Get-GitHubTeamBySlug]
#region    [functions] - [private] - [Teams] - [Get-GitHubTeamListByOrg]
Write-Debug "[$scriptName] - [functions] - [private] - [Teams] - [Get-GitHubTeamListByOrg] - Importing"
function Get-GitHubTeamListByOrg {
    <#
        .SYNOPSIS
        List teams

        .DESCRIPTION
        Lists all teams in an organization that are visible to the authenticated user.

        .EXAMPLE
        Get-GitHubTeamListByOrg -Organization 'github'

        .OUTPUTS
        GitHubTeam[]

        .NOTES
        [List teams](https://docs.github.com/rest/teams/teams#list-teams)
    #>
    [OutputType([GitHubTeam[]])]
    [CmdletBinding()]
    param(
        # The organization name. The name is not case sensitive.
        # If you don't provide this parameter, the command will use the owner of the context.
        [Parameter(Mandatory)]
        [string] $Organization,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Organization/teams"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($team in $_.Response) {
                [GitHubTeam]::new($team, $Organization)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Teams] - [Get-GitHubTeamListByOrg] - Done"
#endregion [functions] - [private] - [Teams] - [Get-GitHubTeamListByOrg]
#region    [functions] - [private] - [Teams] - [Get-GitHubTeamListByRepo]
Write-Debug "[$scriptName] - [functions] - [private] - [Teams] - [Get-GitHubTeamListByRepo] - Importing"
filter Get-GitHubTeamListByRepo {
    <#
        .SYNOPSIS
        List repository teams.

        .DESCRIPTION
        Lists the teams that have access to the specified repository and that are also visible to the authenticated user.
        For a public repository, a team is listed only if that team added the public repository explicitly.
        OAuth app tokens and personal access tokens (classic) need the public_repo or repo scope to use this endpoint with a public repository,
        and repo scope to use this endpoint with a private repository.

        .EXAMPLE
        Get-GitHubTeamListByRepo -Owner 'octocat' -Repository 'Hello-World'

        Output:
        ```powershell

        ```

        Lists all teams that have access to the 'Hello-World' repository owned by 'octocat'.

        .OUTPUTS
        GitHubTeam[]

        .NOTES
        [List repository teams](https://docs.github.com/rest/repos/repos#list-repository-teams)
    #>
    [OutputType([GitHubTeam[]])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/teams"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($team in $_.Response) {
                [GitHubTeam]::new($team, $Organization)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Teams] - [Get-GitHubTeamListByRepo] - Done"
#endregion [functions] - [private] - [Teams] - [Get-GitHubTeamListByRepo]
Write-Debug "[$scriptName] - [functions] - [private] - [Teams] - Done"
#endregion [functions] - [private] - [Teams]
#region    [functions] - [private] - [Users]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - Processing folder"
#region    [functions] - [private] - [Users] - [Get-GitHubAllUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Get-GitHubAllUser] - Importing"
filter Get-GitHubAllUser {
    <#
        .SYNOPSIS
        List users

        .DESCRIPTION
        Lists all users, in the order that they signed up on GitHub. This list includes personal user accounts and organization accounts.

        Note: Pagination is powered exclusively by the `since` parameter. Use the
        [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers)
        to get the URL for the next page of users.

        .EXAMPLE
        Get-GitHubAllUser -Since 17722253

        Get a list of users, starting with the user 'MariusStorhaug'.

        .OUTPUTS
        GitHubUser

        .NOTES
        [List users](https://docs.github.com/rest/users/users#list-users)
    #>
    [OutputType([GitHubUser])]
    [CmdletBinding()]
    param(
        # A user ID. Only return users with an ID greater than this ID.
        [Parameter()]
        [int] $Since = 0,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            since = $Since
        }

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/users'
            Body        = $body
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($account in $_.Response) {
                if ($account.type -eq 'Organization') {
                    [GitHubOrganization]::New($account, $Context)
                } elseif ($account.type -eq 'User') {
                    [GitHubUser]::New($account)
                } else {
                    [GitHubOwner]::New($account)
                }
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Get-GitHubAllUser] - Done"
#endregion [functions] - [private] - [Users] - [Get-GitHubAllUser]
#region    [functions] - [private] - [Users] - [Get-GitHubMyUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Get-GitHubMyUser] - Importing"
filter Get-GitHubMyUser {
    <#
        .SYNOPSIS
        Get the authenticated user

        .DESCRIPTION
        If the authenticated user is authenticated with an OAuth token with the `user` scope, then the response lists public
        and private profile information.
        If the authenticated user is authenticated through OAuth without the `user` scope, then the response lists only public
        profile information.

        .EXAMPLE
        Get-GitHubMyUser

        Get the authenticated user

        .OUTPUTS
        GitHubUser

        .NOTES
        [Get the authenticated user](https://docs.github.com/rest/users/users#get-the-authenticated-user)
    #>
    [OutputType([GitHubUser])]
    [CmdletBinding()]
    param(
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/user'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            if ($_.Response.type -eq 'Organization') {
                [GitHubOrganization]::New($_.Response, $Context)
            } elseif ($_.Response.type -eq 'User') {
                [GitHubUser]::New($_.Response)
            } else {
                [GitHubOwner]::New($_.Response)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Get-GitHubMyUser] - Done"
#endregion [functions] - [private] - [Users] - [Get-GitHubMyUser]
#region    [functions] - [private] - [Users] - [Get-GitHubUserByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Get-GitHubUserByName] - Importing"
filter Get-GitHubUserByName {
    <#
        .SYNOPSIS
        Get a user

        .DESCRIPTION
        Provides publicly available information about someone with a GitHub account.
        GitHub Apps with the `Plan` user permission can use this endpoint to retrieve information about a user's GitHub plan.
        The GitHub App must be authenticated as a user. See
        "[Identifying and authorizing users for GitHub Apps](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)"
        for details about authentication. For an example response, see 'Response with GitHub plan information' below"
        The `email` key in the following response is the publicly visible email address from your GitHub
        [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email
        address to be ΓÇ£publicΓÇ¥ which provides an email entry for this endpoint. If you do not set a public email address for `email`,
        then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub.
        For more information, see [Authentication](https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication).
        The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly.
        For more information, see "[Emails API](https://docs.github.com/rest/users/emails)".

        .EXAMPLE
        Get-GitHubUserByName -Name 'octocat'

        Get the 'octocat' user.

        .OUTPUTS
        GitHubUser

        .NOTES
        [Get a user](https://docs.github.com/rest/users/users#get-a-user)
    #>
    [OutputType([GitHubUser])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/users/$Name"
            Context     = $Context
        }

        try {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                if ($_.Response.type -eq 'Organization') {
                    [GitHubOrganization]::New($_.Response, $Context)
                } elseif ($_.Response.type -eq 'User') {
                    [GitHubUser]::New($_.Response)
                } else {
                    [GitHubOwner]::New($_.Response)
                }
            }
        } catch {
            return
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Get-GitHubUserByName] - Done"
#endregion [functions] - [private] - [Users] - [Get-GitHubUserByName]
#region    [functions] - [private] - [Users] - [Blocking]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Blocking] - Processing folder"
#region    [functions] - [private] - [Users] - [Blocking] - [Block-GitHubUserByUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Blocking] - [Block-GitHubUserByUser] - Importing"
filter Block-GitHubUserByUser {
    <#
        .SYNOPSIS
        Block a user

        .DESCRIPTION
        Blocks the given user and returns a 204. If the authenticated user cannot block the given user a 422 is returned.

        .EXAMPLE
        Block-GitHubUserByUser -Username 'octocat'

        Blocks the user 'octocat' for the authenticated user.
        Returns $true if successful, $false if not.

        .NOTES
        https://docs.github.com/rest/users/blocking#block-a-user
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/user/blocks/$Username"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Blocking] - [Block-GitHubUserByUser] - Done"
#endregion [functions] - [private] - [Users] - [Blocking] - [Block-GitHubUserByUser]
#region    [functions] - [private] - [Users] - [Blocking] - [Get-GitHubBlockedUserByUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Blocking] - [Get-GitHubBlockedUserByUser] - Importing"
filter Get-GitHubBlockedUserByUser {
    <#
        .SYNOPSIS
        List users blocked by the authenticated user

        .DESCRIPTION
        List the users you've blocked on your personal account.

        .EXAMPLE
        Get-GitHubBlockedUserByUser

        Returns a list of users blocked by the authenticated user.

        .NOTES
        [List users blocked by the authenticated user](https://docs.github.com/rest/users/blocking#list-users-blocked-by-the-authenticated-user)
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/user/blocks'
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Blocking] - [Get-GitHubBlockedUserByUser] - Done"
#endregion [functions] - [private] - [Users] - [Blocking] - [Get-GitHubBlockedUserByUser]
#region    [functions] - [private] - [Users] - [Blocking] - [Test-GitHubBlockedUserByUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Blocking] - [Test-GitHubBlockedUserByUser] - Importing"
filter Test-GitHubBlockedUserByUser {
    <#
        .SYNOPSIS
        Check if a user is blocked by the authenticated user

        .DESCRIPTION
        Returns a 204 if the given user is blocked by the authenticated user.
        Returns a 404 if the given user is not blocked by the authenticated user,
        or if the given user account has been identified as spam by GitHub.

        .EXAMPLE
        Test-GitHubBlockedUserByUser -Username 'octocat'

        Checks if the user `octocat` is blocked by the authenticated user.
        Returns true if the user is blocked, false if not.

        .NOTES
        https://docs.github.com/rest/users/blocking#check-if-a-user-is-blocked-by-the-authenticated-user
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/user/blocks/$Username"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Blocking] - [Test-GitHubBlockedUserByUser] - Done"
#endregion [functions] - [private] - [Users] - [Blocking] - [Test-GitHubBlockedUserByUser]
#region    [functions] - [private] - [Users] - [Blocking] - [Unblock-GitHubUserByUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Blocking] - [Unblock-GitHubUserByUser] - Importing"
filter Unblock-GitHubUserByUser {
    <#
        .SYNOPSIS
        Unblock a user

        .DESCRIPTION
        Unblocks the given user and returns a 204.

        .EXAMPLE
        Unblock-GitHubUserByUser -Username 'octocat'

        Unblocks the user 'octocat' for the authenticated user.
        Returns $true if successful.

        .NOTES
        https://docs.github.com/rest/users/blocking#unblock-a-user
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/user/blocks/$Username"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Blocking] - [Unblock-GitHubUserByUser] - Done"
#endregion [functions] - [private] - [Users] - [Blocking] - [Unblock-GitHubUserByUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Blocking] - Done"
#endregion [functions] - [private] - [Users] - [Blocking]
#region    [functions] - [private] - [Users] - [Emails]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Emails] - Processing folder"
#region    [functions] - [private] - [Users] - [Emails] - [Get-GitHubUserAllEmail]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Emails] - [Get-GitHubUserAllEmail] - Importing"
filter Get-GitHubUserAllEmail {
    <#
        .SYNOPSIS
        List email addresses for the authenticated user

        .DESCRIPTION
        Lists all of your email addresses, and specifies which one is visible to the public.
        This endpoint is accessible with the `user:email` scope.

        .EXAMPLE
        Get-GitHubUserAllEmail

        Gets all email addresses for the authenticated user.

        .NOTES
        https://docs.github.com/rest/users/emails#list-email-addresses-for-the-authenticated-user

    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/user/emails'
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Emails] - [Get-GitHubUserAllEmail] - Done"
#endregion [functions] - [private] - [Users] - [Emails] - [Get-GitHubUserAllEmail]
#region    [functions] - [private] - [Users] - [Emails] - [Get-GitHubUserPublicEmail]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Emails] - [Get-GitHubUserPublicEmail] - Importing"
filter Get-GitHubUserPublicEmail {
    <#
        .SYNOPSIS
        List public email addresses for the authenticated user

        .DESCRIPTION
        Lists your publicly visible email address, which you can set with the
        [Set primary email visibility for the authenticated user](https://docs.github.com/rest/users/emails#set-primary-email-visibility-for-the-authenticated-user)
        endpoint. This endpoint is accessible with the `user:email` scope.

        .EXAMPLE
        Get-GitHubUserPublicEmail

        Gets all public email addresses for the authenticated user.

        .NOTES
        https://docs.github.com/rest/users/emails#list-public-email-addresses-for-the-authenticated-user

    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Link to documentation.')]
    [CmdletBinding()]
    param(
        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/user/public_emails'
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Emails] - [Get-GitHubUserPublicEmail] - Done"
#endregion [functions] - [private] - [Users] - [Emails] - [Get-GitHubUserPublicEmail]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Emails] - Done"
#endregion [functions] - [private] - [Users] - [Emails]
#region    [functions] - [private] - [Users] - [Followers]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - Processing folder"
#region    [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserFollowersOfUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserFollowersOfUser] - Importing"
filter Get-GitHubUserFollowersOfUser {
    <#
        .SYNOPSIS
        List followers of a user

        .DESCRIPTION
        Lists the people following the specified user.

        .EXAMPLE
        Get-GitHubUserFollowersOfUser -Username 'octocat'

        Gets all followers of user 'octocat'.

        .NOTES
        https://docs.github.com/rest/users/followers#list-followers-of-a-user

    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/users/$Username/followers"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserFollowersOfUser] - Done"
#endregion [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserFollowersOfUser]
#region    [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserFollowingMe]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserFollowingMe] - Importing"
filter Get-GitHubUserFollowingMe {
    <#
        .SYNOPSIS
        List the people the authenticated user follows

        .DESCRIPTION
        Lists the people who the authenticated user follows.

        .EXAMPLE
        Get-GitHubUserFollowingMe

        Gets all people the authenticated user follows.

        .NOTES
        https://docs.github.com/rest/users/followers#list-the-people-the-authenticated-user-follows

    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/user/following'
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserFollowingMe] - Done"
#endregion [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserFollowingMe]
#region    [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserFollowingUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserFollowingUser] - Importing"
filter Get-GitHubUserFollowingUser {
    <#
        .SYNOPSIS
        List the people a user follows

        .DESCRIPTION
        Lists the people who the specified user follows.

        .EXAMPLE
        Get-GitHubUserFollowingUser -Username 'octocat'

        Gets all people that 'octocat' follows.

        .NOTES
        https://docs.github.com/rest/users/followers#list-the-people-a-user-follows

    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/users/$Username/following"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserFollowingUser] - Done"
#endregion [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserFollowingUser]
#region    [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserMyFollower]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserMyFollower] - Importing"
filter Get-GitHubUserMyFollower {
    <#
        .SYNOPSIS
        List followers of the authenticated user

        .DESCRIPTION
        Lists the people following the authenticated user.

        .EXAMPLE
        Get-GitHubUserMyFollowers

        Gets all followers of the authenticated user.

        .NOTES
        https://docs.github.com/rest/users/followers#list-followers-of-the-authenticated-user

    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseSingularNouns', '',
        Justification = 'Private function, not exposed to user.'
    )]
    [CmdletBinding()]
    param(
        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/user/followers'
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserMyFollower] - Done"
#endregion [functions] - [private] - [Users] - [Followers] - [Get-GitHubUserMyFollower]
#region    [functions] - [private] - [Users] - [Followers] - [Test-GitHubUserFollowedByMe]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - [Test-GitHubUserFollowedByMe] - Importing"
filter Test-GitHubUserFollowedByMe {
    <#
        .SYNOPSIS
        Check if a person is followed by the authenticated user

        .DESCRIPTION
        Returns a 204 if the given user is followed by the authenticated user.
        Returns a 404 if the user is not followed by the authenticated user.

        .EXAMPLE
        Test-GitHubUserFollowedByMe -Username 'octocat'

        Checks if the authenticated user follows the user 'octocat'.

        .NOTES
        https://docs.github.com/rest/users/followers#check-if-a-person-is-followed-by-the-authenticated-user

    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/user/following/$Username"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - [Test-GitHubUserFollowedByMe] - Done"
#endregion [functions] - [private] - [Users] - [Followers] - [Test-GitHubUserFollowedByMe]
#region    [functions] - [private] - [Users] - [Followers] - [Test-GitHubUserFollowedByUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - [Test-GitHubUserFollowedByUser] - Importing"
filter Test-GitHubUserFollowedByUser {
    <#
        .SYNOPSIS
        Check if a user follows another user

        .DESCRIPTION
        Checks if a user follows another user.

        .EXAMPLE
        Test-GitHubUserFollowedByUser -Username 'octocat' -Follows 'ratstallion'

        Checks if the user 'octocat' follows the user 'ratstallion'.

        .NOTES
        https://docs.github.com/rest/users/followers#check-if-a-user-follows-another-user

    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Username,

        # The handle for the GitHub user account we want to check if user specified by $Username is following.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Follows,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/users/$Username/following/$Follows"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - [Test-GitHubUserFollowedByUser] - Done"
#endregion [functions] - [private] - [Users] - [Followers] - [Test-GitHubUserFollowedByUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Followers] - Done"
#endregion [functions] - [private] - [Users] - [Followers]
#region    [functions] - [private] - [Users] - [GPG-Keys]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [GPG-Keys] - Processing folder"
#region    [functions] - [private] - [Users] - [GPG-Keys] - [Get-GitHubUserGpgKeyForUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [GPG-Keys] - [Get-GitHubUserGpgKeyForUser] - Importing"
filter Get-GitHubUserGpgKeyForUser {
    <#
        .SYNOPSIS
        List GPG keys for a user

        .DESCRIPTION
        Lists the GPG keys for a user. This information is accessible by anyone.

        .EXAMPLE
        Get-GitHubUserGpgKeyForUser -Username 'octocat'

        Gets all GPG keys for the 'octocat' user.

        .NOTES
        https://docs.github.com/rest/users/gpg-keys#list-gpg-keys-for-a-user

    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/users/$Username/gpg_keys"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [GPG-Keys] - [Get-GitHubUserGpgKeyForUser] - Done"
#endregion [functions] - [private] - [Users] - [GPG-Keys] - [Get-GitHubUserGpgKeyForUser]
#region    [functions] - [private] - [Users] - [GPG-Keys] - [Get-GitHubUserMyGpgKey]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [GPG-Keys] - [Get-GitHubUserMyGpgKey] - Importing"
filter Get-GitHubUserMyGpgKey {
    <#
        .SYNOPSIS
        List GPG keys for the authenticated user

        .DESCRIPTION
        Lists the current user's GPG keys.
        Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key`
        [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

        .EXAMPLE
        Get-GitHubUserMyGpgKey

        Gets all GPG keys for the authenticated user.

        .NOTES
        https://docs.github.com/rest/users/gpg-keys#list-gpg-keys-for-the-authenticated-user

    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/user/gpg_keys'
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [GPG-Keys] - [Get-GitHubUserMyGpgKey] - Done"
#endregion [functions] - [private] - [Users] - [GPG-Keys] - [Get-GitHubUserMyGpgKey]
#region    [functions] - [private] - [Users] - [GPG-Keys] - [Get-GitHubUserMyGpgKeyById]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [GPG-Keys] - [Get-GitHubUserMyGpgKeyById] - Importing"
filter Get-GitHubUserMyGpgKeyById {
    <#
        .SYNOPSIS
        Get a GPG key for the authenticated user

        .DESCRIPTION
        View extended details for a single GPG key.
        Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key`
        [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

        .EXAMPLE
        Get-GitHubUserMyGpgKeyById -ID '1234567'

        Gets the GPG key with ID '1234567' for the authenticated user.

        .NOTES
        https://docs.github.com/rest/users/gpg-keys#get-a-gpg-key-for-the-authenticated-user

    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The ID of the GPG key.
        [Parameter(
            Mandatory
        )]
        [Alias('gpg_key_id')]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/user/gpg_keys/$ID"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [GPG-Keys] - [Get-GitHubUserMyGpgKeyById] - Done"
#endregion [functions] - [private] - [Users] - [GPG-Keys] - [Get-GitHubUserMyGpgKeyById]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [GPG-Keys] - Done"
#endregion [functions] - [private] - [Users] - [GPG-Keys]
#region    [functions] - [private] - [Users] - [Keys]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Keys] - Processing folder"
#region    [functions] - [private] - [Users] - [Keys] - [Get-GitHubUserKeyForUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Keys] - [Get-GitHubUserKeyForUser] - Importing"
filter Get-GitHubUserKeyForUser {
    <#
        .SYNOPSIS
        List public SSH keys for a user

        .DESCRIPTION
        Lists the _verified_ public SSH keys for a user. This is accessible by anyone.

        .EXAMPLE
        Get-GitHubUserKeyForUser -Username 'octocat'

        Gets all public SSH keys for the 'octocat' user.

        .NOTES
        https://docs.github.com/rest/users/keys#list-public-keys-for-a-user

    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/users/$Username/keys"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Keys] - [Get-GitHubUserKeyForUser] - Done"
#endregion [functions] - [private] - [Users] - [Keys] - [Get-GitHubUserKeyForUser]
#region    [functions] - [private] - [Users] - [Keys] - [Get-GitHubUserMyKey]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Keys] - [Get-GitHubUserMyKey] - Importing"
filter Get-GitHubUserMyKey {
    <#
        .SYNOPSIS
        List public SSH keys for the authenticated user

        .DESCRIPTION
        Lists the public SSH keys for the authenticated user's GitHub account.
        Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key`
        [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

        .EXAMPLE
        Get-GitHubUserMyKey

        Gets all public SSH keys for the authenticated user.

        .NOTES
        https://docs.github.com/rest/users/keys#list-public-ssh-keys-for-the-authenticated-user

    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/user/keys'
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Keys] - [Get-GitHubUserMyKey] - Done"
#endregion [functions] - [private] - [Users] - [Keys] - [Get-GitHubUserMyKey]
#region    [functions] - [private] - [Users] - [Keys] - [Get-GitHubUserMyKeyById]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Keys] - [Get-GitHubUserMyKeyById] - Importing"
filter Get-GitHubUserMyKeyById {
    <#
        .SYNOPSIS
        Get a public SSH key for the authenticated user

        .DESCRIPTION
        View extended details for a single public SSH key.
        Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key`
        [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

        .EXAMPLE
        Get-GitHubUserMyKeyById -ID '1234567'

        Gets the public SSH key with the ID '1234567' for the authenticated user.

        .NOTES
        https://docs.github.com/rest/users/keys#get-a-public-ssh-key-for-the-authenticated-user

    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The unique identifier of the key.
        [Parameter(
            Mandatory
        )]
        [Alias('key_id')]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/user/keys/$ID"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Keys] - [Get-GitHubUserMyKeyById] - Done"
#endregion [functions] - [private] - [Users] - [Keys] - [Get-GitHubUserMyKeyById]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Keys] - Done"
#endregion [functions] - [private] - [Users] - [Keys]
#region    [functions] - [private] - [Users] - [Social-Accounts]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Social-Accounts] - Processing folder"
#region    [functions] - [private] - [Users] - [Social-Accounts] - [Get-GitHubMyUserSocials]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Social-Accounts] - [Get-GitHubMyUserSocials] - Importing"
filter Get-GitHubMyUserSocials {
    <#
        .SYNOPSIS
        List social accounts for the authenticated user

        .DESCRIPTION
        Lists all of your social accounts.

        .EXAMPLE
        Get-GitHubMyUserSocials

        Lists all of your social accounts.

        .NOTES
        https://docs.github.com/rest/users/social-accounts#list-social-accounts-for-the-authenticated-user
    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseSingularNouns', '', Justification = 'Private function, not exposed to user.')]
    [CmdletBinding()]
    param(
        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/user/social_accounts'
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Social-Accounts] - [Get-GitHubMyUserSocials] - Done"
#endregion [functions] - [private] - [Users] - [Social-Accounts] - [Get-GitHubMyUserSocials]
#region    [functions] - [private] - [Users] - [Social-Accounts] - [Get-GitHubUserSocialsByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Social-Accounts] - [Get-GitHubUserSocialsByName] - Importing"
filter Get-GitHubUserSocialsByName {
    <#
        .SYNOPSIS
        List social accounts for a user

        .DESCRIPTION
        Lists social media accounts for a user. This endpoint is accessible by anyone.

        .EXAMPLE
        Get-GitHubUserSocialsByName -Username 'octocat'

        Lists social media accounts for the user 'octocat'.

        .NOTES
        https://docs.github.com/rest/users/social-accounts#list-social-accounts-for-a-user
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/users/$Username/social_accounts"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Social-Accounts] - [Get-GitHubUserSocialsByName] - Done"
#endregion [functions] - [private] - [Users] - [Social-Accounts] - [Get-GitHubUserSocialsByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [Social-Accounts] - Done"
#endregion [functions] - [private] - [Users] - [Social-Accounts]
#region    [functions] - [private] - [Users] - [SSH-Signing-Keys]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [SSH-Signing-Keys] - Processing folder"
#region    [functions] - [private] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserMySigningKey]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserMySigningKey] - Importing"
filter Get-GitHubUserMySigningKey {
    <#
        .SYNOPSIS
        List SSH signing keys for the authenticated user

        .DESCRIPTION
        Lists the SSH signing keys for the authenticated user's GitHub account. You must authenticate with
        Basic Authentication, or you must authenticate with OAuth with at least `read:ssh_signing_key` scope. For more information, see
        "[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/)."

        .EXAMPLE
        Get-GitHubUserMySigningKey

        Lists the SSH signing keys for the authenticated user's GitHub account.

        .NOTES
        https://docs.github.com/rest/users/ssh-signing-keys#list-ssh-signing-keys-for-the-authenticated-user

    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/user/ssh_signing_keys'
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserMySigningKey] - Done"
#endregion [functions] - [private] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserMySigningKey]
#region    [functions] - [private] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserMySigningKeyById]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserMySigningKeyById] - Importing"
filter Get-GitHubUserMySigningKeyById {
    <#
        .SYNOPSIS
        Get an SSH signing key for the authenticated user

        .DESCRIPTION
        Gets extended details for an SSH signing key.
        You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `read:ssh_signing_key` scope.
        For more information, see
        "[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/)."

        .EXAMPLE
        Get-GitHubUserMySigningKeyById -ID '1234567'

        Gets the SSH signing key with the ID '1234567' for the authenticated user.

        .NOTES
        https://docs.github.com/rest/users/ssh-signing-keys#get-an-ssh-signing-key-for-the-authenticated-user

    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The unique identifier of the SSH signing key.
        [Parameter(
            Mandatory
        )]
        [Alias('ssh_signing_key_id')]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/user/ssh_signing_keys/$ID"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserMySigningKeyById] - Done"
#endregion [functions] - [private] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserMySigningKeyById]
#region    [functions] - [private] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserSigningKeyForUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserSigningKeyForUser] - Importing"
filter Get-GitHubUserSigningKeyForUser {
    <#
        .SYNOPSIS
        List SSH signing keys for a user

        .DESCRIPTION
        List SSH signing keys for a user

        .EXAMPLE
        Get-GitHubUserSigningKeyForUser -Username 'octocat'

        Gets the SSH signing keys for the user 'octocat'.

        .NOTES
        https://docs.github.com/rest/users/ssh-signing-keys#list-ssh-signing-keys-for-a-user

    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/users/$Username/ssh_signing_keys"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserSigningKeyForUser] - Done"
#endregion [functions] - [private] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserSigningKeyForUser]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - [SSH-Signing-Keys] - Done"
#endregion [functions] - [private] - [Users] - [SSH-Signing-Keys]
Write-Debug "[$scriptName] - [functions] - [private] - [Users] - Done"
#endregion [functions] - [private] - [Users]
#region    [functions] - [private] - [Utilities]
Write-Debug "[$scriptName] - [functions] - [private] - [Utilities] - Processing folder"
#region    [functions] - [private] - [Utilities] - [PowerShell]
Write-Debug "[$scriptName] - [functions] - [private] - [Utilities] - [PowerShell] - Processing folder"
#region    [functions] - [private] - [Utilities] - [PowerShell] - [Get-FunctionParameter]
Write-Debug "[$scriptName] - [functions] - [private] - [Utilities] - [PowerShell] - [Get-FunctionParameter] - Importing"
function Get-FunctionParameter {
    <#
        .SYNOPSIS
        Get the parameters and their final value in a function.

        .DESCRIPTION
        This function retrieves the parameters and their final value in a function.
        If a parameter is provided, it will retrieve the provided value.
        If a parameter is not provided, it will attempt to retrieve the default value.

        .EXAMPLE
        Get-FunctionParameter

        This will return all the parameters and their final value in the current function.

        .EXAMPLE
        Get-FunctionParameter -IncludeCommonParameters

        This will return all the parameters and their final value in the current function, including common parameters.

        .EXAMPLE
        Get-FunctionParameter -Scope 2

        This will return all the parameters and their final value in the grandparent function.
    #>
    [OutputType([pscustomobject], [hashtable])]
    [CmdletBinding()]
    param(
        # Include common parameters in the output.
        [Parameter()]
        [switch] $IncludeCommonParameters,

        # The function to get the parameters for.
        # Default is the calling scope (0).
        # Scopes are based on nesting levels:
        # 0 - Current scope
        # 1 - Parent scope
        # 2 - Grandparent scope
        [Parameter()]
        [int] $Scope = 0,

        # Return the parameters as a hashtable.
        [Parameter()]
        [switch] $AsHashtable
    )

    $Scope++

    $commonParameters = @(
        'ProgressAction', 'Debug', 'ErrorAction', 'ErrorVariable', 'InformationAction', 'InformationVariable',
        'OutVariable', 'OutBuffer', 'PipelineVariable', 'Verbose', 'WarningAction', 'WarningVariable', 'WhatIf',
        'Confirm'
    )

    $InvocationInfo = (Get-Variable -Name MyInvocation -Scope $Scope -ErrorAction Stop).Value
    $boundParameters = $InvocationInfo.BoundParameters
    $allParameters = @{}
    $parameters = $InvocationInfo.MyCommand.Parameters

    foreach ($paramName in $parameters.Keys) {
        if (-not $IncludeCommonParameters -and $paramName -in $commonParameters) {
            continue
        }
        if ($boundParameters.ContainsKey($paramName)) {
            # Use the explicitly provided value
            $allParameters[$paramName] = $boundParameters[$paramName]
        } else {
            # Attempt to retrieve the default value by invoking it
            try {
                $defaultValue = (Get-Variable -Name $paramName -Scope $Scope -ErrorAction SilentlyContinue).Value
            } catch {
                $defaultValue = $null
            }
            $allParameters[$paramName] = $defaultValue
        }
    }

    if ($AsHashtable) {
        return $allParameters
    }

    [pscustomobject]$allParameters
}
Write-Debug "[$scriptName] - [functions] - [private] - [Utilities] - [PowerShell] - [Get-FunctionParameter] - Done"
#endregion [functions] - [private] - [Utilities] - [PowerShell] - [Get-FunctionParameter]
#region    [functions] - [private] - [Utilities] - [PowerShell] - [Get-PSCallStackPath]
Write-Debug "[$scriptName] - [functions] - [private] - [Utilities] - [PowerShell] - [Get-PSCallStackPath] - Importing"
function Get-PSCallStackPath {
    <#
        .SYNOPSIS
        Create a string representation of the current call stack.

        .DESCRIPTION
        This function creates a string representation of the current call stack.
        You can use the SkipFirst and SkipLatest parameters to skip the first and last.
        By default it will skip the first (what called the initial function, typically <ScriptBlock>),
        and the last (the current function, Get-PSCallStackPath).

        .EXAMPLE
        Get-PSCallStackPath
        First-Function\Second-Function\Third-Function

        Shows the call stack of the last function called, Third-Function, with the first (<ScriptBlock>)
        and last (Get-PSCallStackPath) functions removed.

        .EXAMPLE
        Get-PSCallStackPath -SkipFirst 0
        <ScriptBlock>\First-Function\Second-Function\Third-Function

        Shows the call stack of the last function called, Third-Function, with the first function included (typically <ScriptBlock>).

        .EXAMPLE
        Get-PSCallStackPath -SkipLatest 0
        First-Function\Second-Function\Third-Function\Get-PSCallStackPath

        Shows the call stack of the last function called, Third-Function, with the last function included (Get-PSCallStackPath).
    #>
    [CmdletBinding()]
    param(
        # Number of the functions to skip from the last function called.
        # Last function is this function, Get-PSCallStackPath.
        [Parameter()]
        [int] $SkipLatest = 1,

        # Number of the functions to skip from the first function called.
        # First function is typically <ScriptBlock>.
        [Parameter()]
        [int] $SkipFirst = 1
    )
    $skipFirst++
    $cmds = (Get-PSCallStack).Command
    $functionPath = $cmds[($cmds.Count - $skipFirst)..$SkipLatest] -join '\'
    $functionPath = $functionPath -replace '^.*<ScriptBlock>\\'
    $functionPath = $functionPath -replace '^.*.ps1\\'
    return $functionPath
}
Write-Debug "[$scriptName] - [functions] - [private] - [Utilities] - [PowerShell] - [Get-PSCallStackPath] - Done"
#endregion [functions] - [private] - [Utilities] - [PowerShell] - [Get-PSCallStackPath]
#region    [functions] - [private] - [Utilities] - [PowerShell] - [Test-GitHubAzPowerShell]
Write-Debug "[$scriptName] - [functions] - [private] - [Utilities] - [PowerShell] - [Test-GitHubAzPowerShell] - Importing"
function Test-GitHubAzPowerShell {
    <#
        .SYNOPSIS
        Tests if Azure PowerShell module is installed and authenticated.

        .DESCRIPTION
        This function checks if the Azure PowerShell module (Az) is installed and the user is authenticated.
        It verifies both the availability of the module and the authentication status.

        .EXAMPLE
        Test-GitHubAzPowerShell

        Returns $true if Azure PowerShell module is installed and authenticated, $false otherwise.

        .OUTPUTS
        [bool]
        Returns $true if Azure PowerShell module is installed and authenticated, $false otherwise.

        .NOTES
        This function is used internally by other GitHub module functions that require Azure PowerShell authentication,
        such as Azure Key Vault operations for GitHub App JWT signing.
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param()

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        try {
            # Check if Azure PowerShell module is installed
            $azModule = Get-Module -Name 'Az.Accounts' -ListAvailable -ErrorAction SilentlyContinue
            if (-not $azModule) {
                Write-Debug "[$stackPath] - Azure PowerShell module (Az.Accounts) not found"
                return $false
            }

            # Check if the module is imported
            $importedModule = Get-Module -Name 'Az.Accounts' -ErrorAction SilentlyContinue
            if (-not $importedModule) {
                Write-Debug "[$stackPath] - Attempting to import Az.Accounts module"
                Import-Module -Name 'Az.Accounts' -ErrorAction SilentlyContinue
            }

            # Check if user is authenticated by trying to get current context
            $context = Get-AzContext -ErrorAction SilentlyContinue
            if (-not $context -or [string]::IsNullOrEmpty($context.Account)) {
                Write-Debug "[$stackPath] - Azure PowerShell authentication failed or no account logged in"
                return $false
            }

            Write-Debug "[$stackPath] - Azure PowerShell is installed and authenticated (Account: $($context.Account.Id))"
            return $true
        } catch {
            Write-Debug "[$stackPath] - Error checking Azure PowerShell: $($_.Exception.Message)"
            return $false
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Utilities] - [PowerShell] - [Test-GitHubAzPowerShell] - Done"
#endregion [functions] - [private] - [Utilities] - [PowerShell] - [Test-GitHubAzPowerShell]
#region    [functions] - [private] - [Utilities] - [PowerShell] - [Test-GitHubAzureCLI]
Write-Debug "[$scriptName] - [functions] - [private] - [Utilities] - [PowerShell] - [Test-GitHubAzureCLI] - Importing"
function Test-GitHubAzureCLI {
    <#
        .SYNOPSIS
        Tests if Azure CLI is installed and authenticated.

        .DESCRIPTION
        This function checks if Azure CLI (az) is installed and the user is authenticated.
        It verifies both the availability of the CLI tool and the authentication status.

        .EXAMPLE
        Test-GitHubAzureCLI

        Returns $true if Azure CLI is installed and authenticated, $false otherwise.

        .OUTPUTS
        bool

        .NOTES
        This function is used internally by other GitHub module functions that require Azure CLI authentication,
        such as Azure Key Vault operations for GitHub App JWT signing.
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param()

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        try {
            # Check if Azure CLI is installed
            $azCommand = Get-Command -Name 'az' -ErrorAction SilentlyContinue
            if (-not $azCommand) {
                Write-Debug "[$stackPath] - Azure CLI (az) command not found"
                return $false
            }

            # Check if user is authenticated by trying to get account info
            $accountInfo = az account show --output json 2>$null
            if ($LASTEXITCODE -ne 0 -or [string]::IsNullOrEmpty($accountInfo)) {
                Write-Debug "[$stackPath] - Azure CLI authentication failed or no account logged in"
                return $false
            }

            # Parse the account info to ensure it's valid
            $account = $accountInfo | ConvertFrom-Json -ErrorAction SilentlyContinue
            if (-not $account -or [string]::IsNullOrEmpty($account.id)) {
                Write-Debug "[$stackPath] - Azure CLI account information is invalid"
                return $false
            }

            Write-Debug "[$stackPath] - Azure CLI is installed and authenticated (Account: $($account.id))"
            return $true
        } catch {
            Write-Debug "[$stackPath] - Error checking Azure CLI: $($_.Exception.Message)"
            return $false
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Utilities] - [PowerShell] - [Test-GitHubAzureCLI] - Done"
#endregion [functions] - [private] - [Utilities] - [PowerShell] - [Test-GitHubAzureCLI]
Write-Debug "[$scriptName] - [functions] - [private] - [Utilities] - [PowerShell] - Done"
#endregion [functions] - [private] - [Utilities] - [PowerShell]
Write-Debug "[$scriptName] - [functions] - [private] - [Utilities] - Done"
#endregion [functions] - [private] - [Utilities]
#region    [functions] - [private] - [Variables]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - Processing folder"
#region    [functions] - [private] - [Variables] - [Get-GitHubVariableEnvironmentByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableEnvironmentByName] - Importing"
function Get-GitHubVariableEnvironmentByName {
    <#
        .SYNOPSIS
        Retrieves a specific variable from a GitHub repository.

        .DESCRIPTION
        Gets a specific variable in an environment of a repository on GitHub.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubVariableEnvironmentByName -Owner 'octocat' -Repository 'Hello-World' -Environment 'dev' -Name 'NAME' -Context $GitHubContext

        Output:
        ```powershell
        Name                 : NAME
        Value                : John Doe
        Owner                : octocat
        Repository           : Hello-World
        Environment          : dev
        ```

        Retrieves the specified variable from the specified environment.

        .OUTPUTS
        GitHubVariable

        .NOTES
        Returns an GitHubVariable object containing details about the environment variable,
        including its name, value, associated repository, and environment details.

        .NOTES
        [Get an environment variable](https://docs.github.com/rest/actions/variables#get-an-environment-variable)
    #>
    [OutputType([GitHubVariable])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the environment.
        [Parameter(Mandatory)]
        [string] $Environment,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/environments/$Environment/variables/$Name"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubVariable]::new($_.Response, $Owner, $Repository, $Environment, $null)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableEnvironmentByName] - Done"
#endregion [functions] - [private] - [Variables] - [Get-GitHubVariableEnvironmentByName]
#region    [functions] - [private] - [Variables] - [Get-GitHubVariableEnvironmentList]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableEnvironmentList] - Importing"
function Get-GitHubVariableEnvironmentList {
    <#
        .SYNOPSIS
        Retrieves all variables for a specified environment in a GitHub repository.

        .DESCRIPTION
        Lists all environment variables in a specified repository environment.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubVariableEnvironmentList -Owner 'octocat' -Repository 'Hello-World' -Environment 'dev' -Context $GitHubContext

        Output:
        ```powershell
        Name                 : NAME
        Value                : John Doe
        Owner                : octocat
        Repository           : Hello-World
        Environment          : dev

        Name                 : EMAIL
        Value                : John.Doe@example.com
        Owner                : octocat
        Repository           : Hello-World
        Environment          : dev
        ```

        Retrieves all variables for the specified environment.

        .OUTPUTS
        GitHubVariable[]

        .NOTES
        An array of GitHubVariable objects representing the environment variables.
        Each object contains Name, Value, CreatedAt, UpdatedAt, Owner, Repository, and Environment properties.

        .NOTES
        [List environment variables](https://docs.github.com/rest/actions/variables#list-environment-variables)
    #>
    [OutputType([GitHubVariable[]])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the environment.
        [Parameter(Mandatory)]
        [string] $Environment,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/environments/$Environment/variables"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response.variables | ForEach-Object {
                [GitHubVariable]::new($_, $Owner, $Repository, $Environment, $null)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableEnvironmentList] - Done"
#endregion [functions] - [private] - [Variables] - [Get-GitHubVariableEnvironmentList]
#region    [functions] - [private] - [Variables] - [Get-GitHubVariableFromOrganization]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableFromOrganization] - Importing"
function Get-GitHubVariableFromOrganization {
    <#
        .SYNOPSIS
        List repository organization variables.

        .DESCRIPTION
        Lists all organization variables shared with a repository.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubVariableFromOrganization -Owner 'PSModule' -Repository 'GitHub' -Context (Get-GitHubContext)

        Output:
        ```powershell
        Name                 : AVAILVAR
        Value                : ValueVar
        Owner                : PSModule
        Repository           :
        Environment          :
        CreatedAt            : 3/17/2025 10:56:22 AM
        UpdatedAt            : 3/17/2025 10:56:22 AM
        Visibility           :
        SelectedRepositories :

        Name                 : SELECTEDVAR
        Value                : Varselected
        Owner                : PSModule
        Repository           :
        Environment          :
        CreatedAt            : 3/17/2025 10:56:39 AM
        UpdatedAt            : 3/17/2025 10:56:39 AM
        Visibility           :
        SelectedRepositories :

        Name                 : TESTVAR
        Value                : VarTest
        Owner                : PSModule
        Repository           :
        Environment          :
        CreatedAt            : 3/17/2025 10:56:05 AM
        UpdatedAt            : 3/17/2025 10:56:05 AM
        Visibility           :
        SelectedRepositories :
        ```

        Lists the variables visible from 'PSModule' to the 'GitHub' repository.

        .OUTPUTS
        GitHubVariable[]

        .NOTES
        An array of GitHubVariable objects representing the environment variables.
        Each object contains Name, Value, CreatedAt, UpdatedAt, Owner, Repository, and Environment properties.

        .NOTES
        [List repository organization variables](https://docs.github.com/rest/actions/variables#list-repository-organization-variables)
    #>
    [OutputType([GitHubVariable[]])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/actions/organization-variables"
            PerPage     = $PerPage
            Context     = $Context
        }

        try {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                $_.Response.variables | ForEach-Object {
                    [GitHubVariable]::new($_, $Owner, $null, $null, $null)
                }
            }
        } catch {
            return $null
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableFromOrganization] - Done"
#endregion [functions] - [private] - [Variables] - [Get-GitHubVariableFromOrganization]
#region    [functions] - [private] - [Variables] - [Get-GitHubVariableOwnerByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableOwnerByName] - Importing"
function Get-GitHubVariableOwnerByName {
    <#
        .SYNOPSIS
        Get an organization variable.

        .DESCRIPTION
        Gets a specific variable in an organization.
        The authenticated user must have collaborator access to a repository to create, update, or read variables.
        OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private,
        OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubVariableOwnerByName -Owner 'PSModule' -Name 'SELECTEDVAR' -Context (Get-GitHubContext)

        Output:
        ```powershell
        Name                 : SELECTEDVAR
        Value                : Varselected
        Owner                : PSModule
        Repository           :
        Environment          :
        CreatedAt            : 3/17/2025 10:56:39 AM
        UpdatedAt            : 3/17/2025 10:56:39 AM
        Visibility           : selected
        SelectedRepositories : {Build-PSModule, Test-PSModule}
        ```

        Retrieves the specified variable from the specified organization.

        .NOTES
        [Get an organization variable](https://docs.github.com/rest/actions/variables#get-an-organization-variable)
    #>
    [OutputType([GitHubVariable])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Owner/actions/variables/$Name"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $selectedRepositories = @()
            if ($_.Response.visibility -eq 'selected') {
                $selectedRepositories = Get-GitHubVariableSelectedRepository -Owner $Owner -Name $_.Response.name -Context $Context
            }
            [GitHubVariable]::new($_.Response, $Owner, $Repository, $Environment, $selectedRepositories)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableOwnerByName] - Done"
#endregion [functions] - [private] - [Variables] - [Get-GitHubVariableOwnerByName]
#region    [functions] - [private] - [Variables] - [Get-GitHubVariableOwnerList]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableOwnerList] - Importing"
function Get-GitHubVariableOwnerList {
    <#
        .SYNOPSIS
        List organization variables

        .DESCRIPTION
        Lists all organization variables.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private,
        the `repo` scope is also required.

        .EXAMPLE
        Get-GitHubVariableOwnerList -Owner 'PSModule' -Context (Get-GitHubContext)

        Output:
        ```powershell
        Name                 : AVAILVAR
        Value                : ValueVar
        Owner                : PSModule
        Repository           :
        Environment          :
        CreatedAt            : 3/17/2025 10:56:22 AM
        UpdatedAt            : 3/17/2025 10:56:22 AM
        Visibility           : all
        SelectedRepositories : {}

        Name                 : SELECTEDVAR
        Value                : Varselected
        Owner                : PSModule
        Repository           :
        Environment          :
        CreatedAt            : 3/17/2025 10:56:39 AM
        UpdatedAt            : 3/17/2025 10:56:39 AM
        Visibility           : selected
        SelectedRepositories : {Build-PSModule, Test-PSModule}

        Name                 : TESTVAR
        Value                : VarTest
        Owner                : PSModule
        Repository           :
        Environment          :
        CreatedAt            : 3/17/2025 10:56:05 AM
        UpdatedAt            : 3/17/2025 10:56:05 AM
        Visibility           : private
        SelectedRepositories : {}
        ```

        Retrieves all variables from the specified organization.

        .OUTPUTS
        GitHubVariable[]

        .NOTES
        An array of GitHubVariable objects representing the environment variables.
        Each object contains Name, Value, CreatedAt, UpdatedAt, Owner, Repository, and Environment properties.

        .NOTES
        [List organization variables](https://docs.github.com/rest/actions/variables#list-organization-variables)
    #>
    [OutputType([GitHubVariable[]])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Owner/actions/variables"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response.variables | ForEach-Object {
                $selectedRepositories = @()
                if ($_.visibility -eq 'selected') {
                    $selectedRepositories = Get-GitHubVariableSelectedRepository -Owner $Owner -Name $_.name -Context $Context
                }
                [GitHubVariable]::new($_, $Owner, $Repository, $Environment, $selectedRepositories)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableOwnerList] - Done"
#endregion [functions] - [private] - [Variables] - [Get-GitHubVariableOwnerList]
#region    [functions] - [private] - [Variables] - [Get-GitHubVariableRepositoryByName]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableRepositoryByName] - Importing"
function Get-GitHubVariableRepositoryByName {
    <#
        .SYNOPSIS
        Get a repository variable

        .DESCRIPTION
        Gets a specific variable in a repository.
        The authenticated user must have collaborator access to the repository to use this endpoint.
        OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubVariableRepositoryByName -Owner 'PSModule' -Repository 'Hello-World' -Name 'EMAIL' -Context (Get-GitHubContext)

        Output:
        ```powershell
        Name                 : EMAIL
        Value                : John.Doe@example.com
        Owner                : octocat
        Repository           : Hello-World
        Environment          :
        ```

        Retrieves the specified variable from the specified repository.

        .NOTES
        [Get a repository variable](https://docs.github.com/rest/actions/variables#get-a-repository-variable)
    #>
    [OutputType([GitHubVariable])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/actions/variables/$Name"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubVariable]::new($_.Response, $Owner, $Repository, $null, $null)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableRepositoryByName] - Done"
#endregion [functions] - [private] - [Variables] - [Get-GitHubVariableRepositoryByName]
#region    [functions] - [private] - [Variables] - [Get-GitHubVariableRepositoryList]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableRepositoryList] - Importing"
function Get-GitHubVariableRepositoryList {
    <#
        .SYNOPSIS
        List repository variables.

        .DESCRIPTION
        Lists all repository variables.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Get-GitHubVariableRepositoryList -Owner 'PSModule' -Repository 'Hello-World' -Context (Get-GitHubContext)

        Output:
        ```powershell
        Name                 : NAME
        Value                : John Doe
        Owner                : octocat
        Repository           : Hello-World
        Environment          :

        Name                 : EMAIL
        Value                : John.Doe@example.com
        Owner                : octocat
        Repository           : Hello-World
        Environment          :
        ```

        Retrieves all variables for the specified repository.

        .OUTPUTS
        GitHubVariable[]

        .NOTES
        An array of GitHubVariable objects representing the environment variables.
        Each object contains Name, Value, CreatedAt, UpdatedAt, Owner, Repository, and Environment properties.

        .NOTES
        [List repository variables](https://docs.github.com/rest/actions/variables#list-repository-variables)
    #>
    [OutputType([GitHubVariable[]])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/actions/variables"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response.variables | ForEach-Object {
                [GitHubVariable]::new($_, $Owner, $Repository, $null, $null)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Get-GitHubVariableRepositoryList] - Done"
#endregion [functions] - [private] - [Variables] - [Get-GitHubVariableRepositoryList]
#region    [functions] - [private] - [Variables] - [New-GitHubVariableOnEnvironment]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [New-GitHubVariableOnEnvironment] - Importing"
function New-GitHubVariableOnEnvironment {
    <#
        .SYNOPSIS
        Create an environment variable.

        .DESCRIPTION
        Create an environment variable that you can reference in a GitHub Actions workflow.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        $params = @{
            Owner       = 'octocat'
            Repository  = 'Hello-World'
            Environment = 'dev'
            Name        = 'HOST_NAME'
            Value       = 'github.com'
            Context     = $GitHubContext
        }
        New-GitHubVariableOnEnvironment @params

        Creates a new environment variable named `HOST_NAME` with the value `github.com` in the specified environment.

        .NOTES
        [Create an environment variable](https://docs.github.com/rest/actions/variables#create-an-environment-variable)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the repository environment.
        [Parameter(Mandatory)]
        [string] $Environment,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The value of the variable.
        [Parameter(Mandatory)]
        [string] $Value,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            name  = $Name
            value = $Value
        }

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/repos/$Owner/$Repository/environments/$Environment/variables"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("variable [$Name] on [$Owner/$Repository/$Environment]", 'Create')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [New-GitHubVariableOnEnvironment] - Done"
#endregion [functions] - [private] - [Variables] - [New-GitHubVariableOnEnvironment]
#region    [functions] - [private] - [Variables] - [New-GitHubVariableOnOwner]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [New-GitHubVariableOnOwner] - Importing"
function New-GitHubVariableOnOwner {
    <#
        .SYNOPSIS
        Create an organization variable.

        .DESCRIPTION
        Creates an organization variable that you can reference in a GitHub Actions workflow.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private,
        OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        New-GitHubVariableOnOwner -Owner 'octocat' -Name 'HOST_NAME' -Value 'github.com' -Context $GitHubContext

        Creates a new organization variable named `HOST_NAME` with the value `github.com` in the specified organization.

        .NOTES
        [Create an organization variable](https://docs.github.com/rest/actions/variables#create-an-organization-variable)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The value of the variable.
        [Parameter(Mandatory)]
        [string] $Value,

        # The visibility of the variable. Can be `private`, `selected`, or `all`.
        # `private` - The variable is only available to the organization.
        # `selected` - The variable is available to selected repositories.
        # `all` - The variable is available to all repositories in the organization.
        [Parameter()]
        [ValidateSet('private', 'selected', 'all')]
        [string] $Visibility = 'private',

        # The IDs of the repositories to which the variable is available.
        # This parameter is only used when the `-Visibility` parameter is set to `selected`.
        # The IDs can be obtained from the `Get-GitHubRepository` function.
        [Parameter()]
        [UInt64[]] $SelectedRepositories,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            name       = $Name
            value      = $Value
            visibility = $Visibility
        }

        if ($Visibility -eq 'selected') {
            if (-not $SelectedRepositories) {
                throw 'You must specify the -SelectedRepositories parameter when using the -Visibility selected switch.'
            }
            $body['selected_repository_ids'] = $SelectedRepositories
        }

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/orgs/$Owner/actions/variables"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("variable [$Name] on [$Owner]", 'Create')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [New-GitHubVariableOnOwner] - Done"
#endregion [functions] - [private] - [Variables] - [New-GitHubVariableOnOwner]
#region    [functions] - [private] - [Variables] - [New-GitHubVariableOnRepository]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [New-GitHubVariableOnRepository] - Importing"
function New-GitHubVariableOnRepository {
    <#
        .SYNOPSIS
        Create a repository variable.

        .DESCRIPTION
        Creates a repository variable that you can reference in a GitHub Actions workflow.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        New-GitHubVariableOnRepository -Owner 'octocat' -Repository 'Hello-World' -Name 'HOST_NAME' -Value 'github.com' -Context $GitHubContext

        Creates a new repository variable named `HOST_NAME` with the value `github.com` in the specified repository.

        .NOTES
        [Create a repository variable](https://docs.github.com/rest/actions/variables#create-a-repository-variable)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The value of the variable.
        [Parameter(Mandatory)]
        [string] $Value,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            name  = $Name
            value = $Value
        }

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/repos/$Owner/$Repository/actions/variables"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("variable [$Name] on [$Owner/$Repository]", 'Create')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [New-GitHubVariableOnRepository] - Done"
#endregion [functions] - [private] - [Variables] - [New-GitHubVariableOnRepository]
#region    [functions] - [private] - [Variables] - [Remove-GitHubVariableFromEnvironment]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Remove-GitHubVariableFromEnvironment] - Importing"
function Remove-GitHubVariableFromEnvironment {
    <#
        .SYNOPSIS
        Delete an environment variable.

        .DESCRIPTION
        Deletes an environment variable using the variable name.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Remove-GitHubVariableFromEnvironment -Owner 'octocat' -Repository 'Hello-World' -Environment 'dev' -Name 'HOST_NAME' -Context $GitHubContext

        Deletes the specified variable from the specified environment.

        .NOTES
        [Delete an environment variable](https://docs.github.com/rest/actions/variables#delete-an-environment-variable)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the repository environment.
        [Parameter(Mandatory)]
        [string] $Environment,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/repos/$Owner/$Repository/environments/$Environment/variables/$Name"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("variable [$Name] on [$Owner/$Repository/$Environment]", 'Delete')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Remove-GitHubVariableFromEnvironment] - Done"
#endregion [functions] - [private] - [Variables] - [Remove-GitHubVariableFromEnvironment]
#region    [functions] - [private] - [Variables] - [Remove-GitHubVariableFromOwner]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Remove-GitHubVariableFromOwner] - Importing"
function Remove-GitHubVariableFromOwner {
    <#
        .SYNOPSIS
        Delete an organization variable.

        .DESCRIPTION
        Deletes an organization variable using the variable name.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth tokens and personal access tokens (classic) need the`admin:org` scope to use this endpoint. If the repository is private,
        OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Remove-GitHubVariableFromOwner -Owner 'octocat' -Name 'HOST_NAME' -Context $GitHubContext

        Deletes the specified variable from the specified organization.

        .NOTES
        [Delete an organization variable](https://docs.github.com/rest/actions/variables#delete-an-organization-variable)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/orgs/$Owner/actions/variables/$Name"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("variable [$Name] on [$Owner]", 'Delete')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Remove-GitHubVariableFromOwner] - Done"
#endregion [functions] - [private] - [Variables] - [Remove-GitHubVariableFromOwner]
#region    [functions] - [private] - [Variables] - [Remove-GitHubVariableFromRepository]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Remove-GitHubVariableFromRepository] - Importing"
function Remove-GitHubVariableFromRepository {
    <#
        .SYNOPSIS
        Delete a repository variable.

        .DESCRIPTION
        Deletes a repository variable using the variable name.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Remove-GitHubVariableFromRepository -Owner 'octocat' -Repository 'Hello-World' -Name 'HOST_NAME' -Context $GitHubContext

        Deletes the specified variable from the specified repository.

        .NOTES
        [Delete a repository variable](https://docs.github.com/rest/actions/variables#delete-a-repository-variable)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/repos/$Owner/$Repository/actions/variables/$Name"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("variable [$Name] on [$Owner/$Repository]", 'Delete')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Remove-GitHubVariableFromRepository] - Done"
#endregion [functions] - [private] - [Variables] - [Remove-GitHubVariableFromRepository]
#region    [functions] - [private] - [Variables] - [Update-GitHubVariableOnEnvironment]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Update-GitHubVariableOnEnvironment] - Importing"
function Update-GitHubVariableOnEnvironment {
    <#
        .SYNOPSIS
        Update an environment variable.

        .DESCRIPTION
        Updates an environment variable that you can reference in a GitHub Actions workflow.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.


        .EXAMPLE
        $params = @{
            Owner       = 'octocat'
            Repository  = 'Hello-World'
            Environment = 'dev'
            Name        = 'HOST_NAME'
            Value       = 'github.com'
            Context     = $GitHubContext
        }
        Update-GitHubVariableOnEnvironment @params

        Updates the environment variable named `HOST_NAME` with the value `github.com` in the specified environment.

        .NOTES
        [Update an environment variable](https://docs.github.com/rest/actions/variables#update-an-environment-variable)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the repository environment.
        [Parameter(Mandatory)]
        [string] $Environment,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The new name of the variable.
        [Parameter()]
        [string] $NewName,

        # The value of the variable.
        [Parameter()]
        [string] $Value,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{}
        if ($PSBoundParameters.ContainsKey('NewName')) {
            $body.name = $NewName
        }
        if ($PSBoundParameters.ContainsKey('Value')) {
            $body.value = $Value
        }

        $apiParams = @{
            Method      = 'PATCH'
            APIEndpoint = "/repos/$Owner/$Repository/environments/$Environment/variables/$Name"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("variable [$Name] on [$Owner/$Repository/$Environment]", 'Update')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Update-GitHubVariableOnEnvironment] - Done"
#endregion [functions] - [private] - [Variables] - [Update-GitHubVariableOnEnvironment]
#region    [functions] - [private] - [Variables] - [Update-GitHubVariableOnOwner]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Update-GitHubVariableOnOwner] - Importing"
function Update-GitHubVariableOnOwner {
    <#
        .SYNOPSIS
        Update an organization variable.

        .DESCRIPTION
        Updates an organization variable that you can reference in a GitHub Actions workflow.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private,
        the `repo` scope is also required.

        .EXAMPLE
        Update-GitHubVariableOnOwner -Owner 'octocat' -Name 'HOST_NAME' -Value 'github.com' -Context $GitHubContext

        Updates the organization variable named `HOST_NAME` with the value `github.com` in the specified organization.

        .NOTES
        [Update an organization variable](https://docs.github.com/rest/actions/variables#update-an-organization-variable)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The new name of the variable.
        [Parameter()]
        [string] $NewName,

        # The value of the variable.
        [Parameter()]
        [string] $Value,

        # The visibility of the variable. Can be `private`, `selected`, or `all`.
        # `private` - The variable is only available to the organization.
        # `selected` - The variable is available to selected repositories.
        # `all` - The variable is available to all repositories in the organization.
        [Parameter()]
        [ValidateSet('private', 'selected', 'all')]
        [string] $Visibility,

        # The IDs of the repositories to which the variable is available.
        # This parameter is only used when the `-Visibility` parameter is set to `selected`.
        # The IDs can be obtained from the `Get-GitHubRepository` function.
        [Parameter()]
        [UInt64[]] $SelectedRepositories,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{}
        if ($PSBoundParameters.ContainsKey('NewName')) {
            $body.name = $NewName
        }
        if ($PSBoundParameters.ContainsKey('Value')) {
            $body.value = $Value
        }
        if ($PSBoundParameters.ContainsKey('Visibility')) {
            $body.visibility = $Visibility
        }
        if ($PSBoundParameters.ContainsKey('SelectedRepositories')) {
            $body.selected_repository_ids = $SelectedRepositories
        }

        if ($Visibility -eq 'selected') {
            if (-not $SelectedRepositories) {
                throw 'You must specify the -SelectedRepositories parameter when using the -Visibility selected switch.'
            }
            $body['selected_repository_ids'] = $SelectedRepositories
        }

        $apiParams = @{
            Method      = 'PATCH'
            APIEndpoint = "/orgs/$Owner/actions/variables/$Name"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("variable [$Name] on [$Owner]", 'Update')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Update-GitHubVariableOnOwner] - Done"
#endregion [functions] - [private] - [Variables] - [Update-GitHubVariableOnOwner]
#region    [functions] - [private] - [Variables] - [Update-GitHubVariableOnRepository]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Update-GitHubVariableOnRepository] - Importing"
function Update-GitHubVariableOnRepository {
    <#
        .SYNOPSIS
        Update a repository variable.

        .DESCRIPTION
        Updates a repository variable that you can reference in a GitHub Actions workflow.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Update-GitHubVariableOnRepository -Owner 'octocat' -Repository 'Hello-World' -Name 'HOST_NAME' -Value 'github.com' -Context $GitHubContext

        Updates the repository variable named `HOST_NAME` with the value `github.com` in the specified repository.

        .NOTES
        [Update a repository variable](https://docs.github.com/rest/actions/variables#update-a-repository-variable)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The new name of the variable.
        [Parameter()]
        [string] $NewName,

        # The value of the variable.
        [Parameter()]
        [string] $Value,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{}
        if ($PSBoundParameters.ContainsKey('NewName')) {
            $body.name = $NewName
        }
        if ($PSBoundParameters.ContainsKey('Value')) {
            $body.value = $Value
        }

        $apiParams = @{
            Method      = 'PATCH'
            APIEndpoint = "/repos/$Owner/$Repository/actions/variables/$Name"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("variable [$Name] on [$Owner/$Repository]", 'Update')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - [Update-GitHubVariableOnRepository] - Done"
#endregion [functions] - [private] - [Variables] - [Update-GitHubVariableOnRepository]
Write-Debug "[$scriptName] - [functions] - [private] - [Variables] - Done"
#endregion [functions] - [private] - [Variables]
#region    [functions] - [private] - [Webhooks]
Write-Debug "[$scriptName] - [functions] - [private] - [Webhooks] - Processing folder"
#region    [functions] - [private] - [Webhooks] - [Get-GitHubAppWebhookDeliveryByID]
Write-Debug "[$scriptName] - [functions] - [private] - [Webhooks] - [Get-GitHubAppWebhookDeliveryByID] - Importing"
function Get-GitHubAppWebhookDeliveryByID {
    <#
        .SYNOPSIS
        Get a delivery for an app webhook

        .DESCRIPTION
        Returns a delivery for the webhook configured for a GitHub App.

        You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
        to access this endpoint.


        .EXAMPLE
        Get-GitHubAppWebhookDeliveryByID -ID 123456

        Returns the webhook configuration for the authenticated app.

        .OUTPUTS
        GitHubWebhookDelivery

        .NOTES
        [Get a delivery for an app webhook](https://docs.github.com/rest/apps/webhooks#get-a-delivery-for-an-app-webhook)
    #>
    [OutputType([GitHubWebhookDelivery])]
    [CmdletBinding()]
    param(
        # The ID of the delivery.
        [Parameter(Mandatory)]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType APP
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/app/hook/deliveries/$ID"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubWebhookDelivery]::new($_.Response)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Webhooks] - [Get-GitHubAppWebhookDeliveryByID] - Done"
#endregion [functions] - [private] - [Webhooks] - [Get-GitHubAppWebhookDeliveryByID]
#region    [functions] - [private] - [Webhooks] - [Get-GitHubAppWebhookDeliveryByList]
Write-Debug "[$scriptName] - [functions] - [private] - [Webhooks] - [Get-GitHubAppWebhookDeliveryByList] - Importing"
function Get-GitHubAppWebhookDeliveryByList {
    <#
        .SYNOPSIS
        List deliveries for an app webhook

        .DESCRIPTION
        Returns a list of webhook deliveries for the webhook configured for a GitHub App.

        You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
        to access this endpoint.

        .EXAMPLE
        Get-GitHubAppWebhookDeliveryByList

        Returns the webhook configuration for the authenticated app.

        .OUTPUTS
        GitHubWebhookDelivery

        .NOTES
        [List deliveries for an app webhook](https://docs.github.com/rest/apps/webhooks#list-deliveries-for-an-app-webhook)
    #>
    [OutputType([GitHubWebhookDelivery[]])]
    [CmdletBinding()]
    param(
        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType APP
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/app/hook/deliveries'
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response | ForEach-Object {
                [GitHubWebhookDelivery]@{
                    ID             = $_.id
                    GUID           = $_.guid
                    DeliveredAt    = $_.delivered_at
                    Redelivery     = $_.redelivery
                    Duration       = $_.duration
                    Status         = $_.status
                    StatusCode     = $_.status_code
                    Event          = $_.event
                    Action         = $_.action
                    InstallationID = $_.installation.id
                    RepositoryID   = $_.repository.id
                    ThrottledAt    = $_.throttled_at
                    URL            = $_.url
                    Request        = $_.request
                    Response       = $_.response
                }
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Webhooks] - [Get-GitHubAppWebhookDeliveryByList] - Done"
#endregion [functions] - [private] - [Webhooks] - [Get-GitHubAppWebhookDeliveryByList]
#region    [functions] - [private] - [Webhooks] - [Get-GitHubAppWebhookDeliveryToRedeliver]
Write-Debug "[$scriptName] - [functions] - [private] - [Webhooks] - [Get-GitHubAppWebhookDeliveryToRedeliver] - Importing"
function Get-GitHubAppWebhookDeliveryToRedeliver {
    <#
        .SYNOPSIS
        Short description

        .DESCRIPTION
        Long description

        .EXAMPLE
        An example

        .NOTES
        [Ttle](link)
    #>
    [CmdletBinding()]
    param(
        # The timespan to check for redeliveries in hours.
        [Parameter()]
        [int] $TimeSpan = -2,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        [Parameter(Mandatory)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Assert-GitHubContext -Context $Context -AuthType APP
    }

    process {
        $checkPoint = ([DateTime]::Now).AddHours($TimeSpan)
        Get-GitHubAppWebhookDeliveryByList -Context $Context -PerPage $PerPage | Where-Object { $_.DeliveredAt -gt $checkPoint } |
            Group-Object -Property GUID | Where-Object { $_.Group.Status -notcontains 'OK' } | ForEach-Object {
                $refObject = $_.Group | Sort-Object -Property DeliveredAt
                [GitHubWebhookDelivery]@{
                    Attempts       = $_.Count
                    GUID           = $_.Name
                    Status         = $refObject.Status
                    StatusCode     = $refObject.StatusCode
                    Event          = $refObject.Event
                    Action         = $refObject.Action
                    Duration       = $_.Group.Duration | Measure-Object -Average | Select-Object -ExpandProperty Average
                    ID             = $refObject.ID
                    DeliveredAt    = $refObject.DeliveredAt
                    Redelivery     = $refObject.Redelivery
                    InstallationID = $refObject.InstallationID
                    RepositoryID   = $refObject.RepositoryID
                    ThrottledAt    = $refObject.ThrottledAt
                    URL            = $refObject.URL
                    Request        = $refObject.Request
                    Response       = $refObject.Response
                }
            }
    }

    end {
        Write-Debug "[$commandName] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [private] - [Webhooks] - [Get-GitHubAppWebhookDeliveryToRedeliver] - Done"
#endregion [functions] - [private] - [Webhooks] - [Get-GitHubAppWebhookDeliveryToRedeliver]
Write-Debug "[$scriptName] - [functions] - [private] - [Webhooks] - Done"
#endregion [functions] - [private] - [Webhooks]
Write-Debug "[$scriptName] - [functions] - [private] - Done"
#endregion [functions] - [private]
#region    [functions] - [public]
Write-Debug "[$scriptName] - [functions] - [public] - Processing folder"
#region    [functions] - [public] - [Actions]
Write-Debug "[$scriptName] - [functions] - [public] - [Actions] - Processing folder"
#region    [functions] - [public] - [Actions] - [Data]
Write-Debug "[$scriptName] - [functions] - [public] - [Actions] - [Data] - Processing folder"
#region    [functions] - [public] - [Actions] - [Data] - [Get-GitHubEventData]
Write-Debug "[$scriptName] - [functions] - [public] - [Actions] - [Data] - [Get-GitHubEventData] - Importing"
function Get-GitHubEventData {
    <#
        .SYNOPSIS
        Gets data about the event that triggered the workflow.

        .DESCRIPTION
        Gets data about the event that triggered the workflow.

        .EXAMPLE
        Get-GitHubEventData

        .LINK
        https://psmodule.io/GitHub/Functions/Actions/Data/Get-GitHubEventData
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param()

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $script:GitHub.Event
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Actions] - [Data] - [Get-GitHubEventData] - Done"
#endregion [functions] - [public] - [Actions] - [Data] - [Get-GitHubEventData]
#region    [functions] - [public] - [Actions] - [Data] - [Get-GitHubRunnerData]
Write-Debug "[$scriptName] - [functions] - [public] - [Actions] - [Data] - [Get-GitHubRunnerData] - Importing"
function Get-GitHubRunnerData {
    <#
        .SYNOPSIS
        Gets data about the runner thats running the workflow.

        .DESCRIPTION
        Gets data about the runner thats running the workflow.

        .EXAMPLE
        Get-GitHubRunnerData

        .LINK
        https://psmodule.io/GitHub/Functions/Actions/Data/Get-GitHubRunnerData
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param()

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $script:GitHub.Runner
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Actions] - [Data] - [Get-GitHubRunnerData] - Done"
#endregion [functions] - [public] - [Actions] - [Data] - [Get-GitHubRunnerData]
Write-Debug "[$scriptName] - [functions] - [public] - [Actions] - [Data] - Done"
#endregion [functions] - [public] - [Actions] - [Data]
Write-Debug "[$scriptName] - [functions] - [public] - [Actions] - Done"
#endregion [functions] - [public] - [Actions]
#region    [functions] - [public] - [API]
Write-Debug "[$scriptName] - [functions] - [public] - [API] - Processing folder"
#region    [functions] - [public] - [API] - [Invoke-GitHubAPI]
Write-Debug "[$scriptName] - [functions] - [public] - [API] - [Invoke-GitHubAPI] - Importing"
#Requires -Modules @{ ModuleName = 'Uri'; RequiredVersion = '1.1.2' }
#Requires -Modules @{ ModuleName = 'Hashtable'; RequiredVersion = '1.1.6' }

function Invoke-GitHubAPI {
    <#
        .SYNOPSIS
        Calls the GitHub API using the provided parameters.

        .DESCRIPTION
        This function is a wrapper around Invoke-RestMethod tailored for calling GitHub's API.
        It automatically handles the endpoint URI construction, headers, and token authentication.

        .EXAMPLE
        Invoke-GitHubAPI -ApiEndpoint '/repos/user/repo/pulls' -Method GET

        Gets all open pull requests for the specified repository.

        .EXAMPLE
        Invoke-GitHubAPI -ApiEndpoint '/repos/user/repo/pulls' -Method GET -Body @{ state = 'open' }

        Gets all open pull requests for the specified repository, filtered by the 'state' parameter.

        .EXAMPLE
        Invoke-GitHubAPI -ApiEndpoint '/repos/user/repo/pulls' -Method GET -Body @{ state = 'open' } -Accept 'application/vnd.github.v3+json'

        Gets all open pull requests for the specified repository, filtered by the 'state' parameter, and using the specified 'Accept' header.

        .LINK
        https://psmodule.io/GitHub/Functions/API/Invoke-GitHubAPI
    #>
    [CmdletBinding(DefaultParameterSetName = 'ApiEndpoint')]
    param(
        # The HTTP method to be used for the API request. It can be one of the following: GET, POST, PUT, DELETE, or PATCH.
        [Parameter()]
        [ValidateSet('GET', 'POST', 'PUT', 'DELETE', 'PATCH')]
        $Method = 'GET',

        # The base URI for the GitHub API. This is usually `https://api.github.com`, but can be adjusted if necessary.
        [Parameter(
            ParameterSetName = 'ApiEndpoint'
        )]
        [string] $ApiBaseUri,

        # The specific endpoint for the API call, e.g., '/repos/user/repo/pulls'.
        [Parameter(
            Mandatory,
            ParameterSetName = 'ApiEndpoint'
        )]
        [string] $ApiEndpoint,

        # The body of the API request. This can be a hashtable or a string. If a hashtable is provided, it will be converted to JSON.
        [Parameter()]
        [Alias('Query')]
        [object] $Body,

        # The 'Accept' header for the API request. If not provided, the default will be used by GitHub's API.
        [Parameter()]
        [string] $Accept = 'application/vnd.github+json; charset=utf-8',

        # Specifies the HTTP version used for the request.
        [Parameter()]
        [string] $HttpVersion,

        # The file path to be used for the API request. This is used for uploading files.
        [Parameter()]
        [string] $UploadFilePath,

        # The full URI for the API request. This is used for custom API calls.
        [Parameter(
            Mandatory,
            ParameterSetName = 'Uri'
        )]
        [string] $Uri,

        # The 'Content-Type' header for the API request. The default is 'application/vnd.github+json'.
        [Parameter()]
        [string] $ContentType = 'application/vnd.github+json; charset=utf-8',

        # The GitHub API version to be used. By default, it pulls from a configuration script variable.
        [Parameter()]
        [string] $ApiVersion,

        # Specifies how many times PowerShell retries a connection when a failure code between 400 and 599, inclusive or 304 is received.
        [Parameter()]
        [System.Nullable[int]] $RetryCount,

        # Specifies the interval between retries for the connection when a failure code between 400 and 599, inclusive or 304 is received.
        # When the failure code is 429 and the response includes the Retry-After property in its headers, the cmdlet uses that value for the retry
        # interval, even if this parameter is specified.
        [Parameter()]
        [System.Nullable[int]] $RetryInterval,

        # The number of results per page for paginated GitHub API responses.
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter()]
        [switch] $Anonymous,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $debug = $DebugPreference -eq 'Continue'
        $Context = Resolve-GitHubContext -Context $Context -Anonymous $Anonymous
        if ($debug) {
            Write-Debug 'Invoking GitHub API...'
            Write-Debug 'Parent function parameters:'
            Get-FunctionParameter -Scope 1 | Format-List | Out-String -Stream | ForEach-Object { Write-Debug $_ }
            Write-Debug 'Parameters:'
            Get-FunctionParameter | Format-List | Out-String -Stream | ForEach-Object { Write-Debug $_ }
        }
    }

    process {
        $Token = $Context.Token
        $HttpVersion = Resolve-GitHubContextSetting -Name 'HttpVersion' -Value $HttpVersion -Context $Context
        $ApiBaseUri = Resolve-GitHubContextSetting -Name 'ApiBaseUri' -Value $ApiBaseUri -Context $Context
        $ApiVersion = Resolve-GitHubContextSetting -Name 'ApiVersion' -Value $ApiVersion -Context $Context
        $RetryCount = Resolve-GitHubContextSetting -Name 'RetryCount' -Value $RetryCount -Context $Context
        $RetryInterval = Resolve-GitHubContextSetting -Name 'RetryInterval' -Value $RetryInterval -Context $Context
        $TokenType = Resolve-GitHubContextSetting -Name 'TokenType' -Value $TokenType -Context $Context
        if ($debug) {
            [pscustomobject]@{
                Token       = $Token
                HttpVersion = $HttpVersion
                ApiBaseUri  = $ApiBaseUri
                ApiVersion  = $ApiVersion
                TokenType   = $TokenType
            } | Format-List | Out-String -Stream | ForEach-Object { Write-Debug $_ }
        }

        $headers = @{
            Accept                 = $Accept
            'X-GitHub-Api-Version' = $ApiVersion
            'User-Agent'           = $script:UserAgent
        }
        $headers | Remove-HashtableEntry -NullOrEmptyValues

        if (-not $Uri) {
            $Uri = New-Uri -BaseUri $ApiBaseUri -Path $ApiEndpoint -AsString
            $Uri = $Uri -replace '//$', '/'
        }

        $APICall = @{
            Uri               = $Uri
            Method            = [string]$Method
            Headers           = $Headers
            ContentType       = $ContentType
            InFile            = $UploadFilePath
            HttpVersion       = [string]$HttpVersion
            MaximumRetryCount = $RetryCount
            RetryIntervalSec  = $RetryInterval
        }
        $APICall | Remove-HashtableEntry -NullOrEmptyValues

        if (-not $Anonymous -and $Context.Name -ne 'Anonymous') {
            $APICall['Authentication'] = 'Bearer'
            $APICall['Token'] = $Token
        }

        if ($Method -eq 'GET') {
            if (-not $Body) {
                $Body = @{}
            }
            $Body['per_page'] = Resolve-GitHubContextSetting -Name 'PerPage' -Value $PerPage -Context $Context
            $APICall.Uri = New-Uri -BaseUri $Uri -Query $Body -AsString
        } elseif (($Method -eq 'POST') -and -not [string]::IsNullOrEmpty($UploadFilePath)) {
            $APICall.Uri = New-Uri -BaseUri $Uri -Query $Body -AsString
        } elseif ($Body) {
            if ($Body -is [hashtable]) {
                $APICall.Body = $Body | ConvertTo-Json -Depth 100
            } else {
                $APICall.Body = $Body
            }
        }

        try {
            if ($debug) {
                Write-Debug '----------------------------------'
                Write-Debug 'Request:'
                [pscustomobject]$APICall | Select-Object -ExcludeProperty Body, Headers | Format-List |
                    Out-String -Stream | ForEach-Object { Write-Debug $_ }
                Write-Debug '----------------------------------'
                Write-Debug 'Request headers:'
                [pscustomobject]$APICall.Headers | Select-Object * | Format-List | Out-String -Stream | ForEach-Object { Write-Debug $_ }
                Write-Debug '----------------------------------'
                Write-Debug 'Request body:'
                ($APICall.Body | Out-String).Split('\n') -split '\n' | ForEach-Object { Write-Debug $_ }
                Write-Debug '----------------------------------'
            }
            do {
                $response = Invoke-WebRequest @APICall -ProgressAction 'SilentlyContinue' -Debug:$false -Verbose:$false

                $headers = @{}
                foreach ($item in $response.Headers.GetEnumerator()) {
                    $headers[$item.Key] = ($item.Value).Trim() -join ', '
                }
                $headers = [pscustomobject]$headers
                $sortedProperties = $headers.PSObject.Properties.Name | Sort-Object
                $headers = $headers | Select-Object $sortedProperties
                if ($headers.'x-ratelimit-reset') {
                    $headers.'x-ratelimit-reset' = [DateTime]::UnixEpoch.AddSeconds(
                        $headers.'x-ratelimit-reset'
                    ).ToLocalTime().ToString('s')
                }
                if ($headers.'Date') {
                    $headers.'Date' = [DateTime]::Parse(
                        ($headers.'Date').Replace('UTC', '').Trim()
                    ).ToLocalTime().ToString('s')
                }
                if ($headers.'github-authentication-token-expiration') {
                    $headers.'github-authentication-token-expiration' = [DateTime]::Parse(
                        ($headers.'github-authentication-token-expiration').Replace('UTC', '').Trim()
                    ).ToLocalTime().ToString('s')
                }
                if ($debug) {
                    Write-Debug '----------------------------------'
                    Write-Debug 'Response:'
                    $response | Select-Object -ExcludeProperty Content, Headers | Out-String -Stream | ForEach-Object { Write-Debug $_ }
                    Write-Debug '---------------------------'
                    Write-Debug 'Response headers:'
                    $headers | Out-String -Stream | ForEach-Object { Write-Debug $_ }
                    Write-Debug '---------------------------'
                }
                switch -Regex ($headers.'Content-Type') {
                    'application/.*json' {
                        $results = $response.Content | ConvertFrom-Json
                    }
                    'application/octocat-stream' {
                        [byte[]]$byteArray = $response.Content
                        $results = [System.Text.Encoding]::UTF8.GetString($byteArray)
                    }
                    default {
                        $results = $response.Content
                    }
                }

                if ($debug) {
                    Write-Debug 'Response content:'
                    $results | ConvertTo-Json -Depth 5 -WarningAction SilentlyContinue | Out-String -Stream | ForEach-Object {
                        $content = $_
                        $content = $content -split '\n'
                        $content = $content.Split('\n')
                        foreach ($item in $content) {
                            Write-Debug $item
                        }
                    }
                    Write-Debug '---------------------------'
                }

                [pscustomobject]@{
                    Request           = $APICall
                    Response          = $results
                    Headers           = $headers
                    StatusCode        = $response.StatusCode
                    StatusDescription = $response.StatusDescription
                }
                $APICall['Uri'] = $response.RelationLink.next
            } while ($APICall['Uri'])
        } catch {
            $failure = $_
            if ($debug) {
                Write-Debug '----------------------------------'
                Write-Debug 'Failure:'
                $failure | Out-String -Stream | ForEach-Object { Write-Debug $_ }
                Write-Debug '----------------------------------'
            }
            $headers = @{}
            if ($failure.Exception.Response.Headers) {
                foreach ($item in $failure.Exception.Response.Headers.GetEnumerator()) {
                    $headers[$item.Key] = ($item.Value).Trim() -join ', '
                }
                $headers = [pscustomobject]$headers
                if ($headers.'x-ratelimit-reset') {
                    $headers.'x-ratelimit-reset' = [DateTime]::UnixEpoch.AddSeconds(
                        $headers.'x-ratelimit-reset'
                    ).ToLocalTime().ToString('s')
                }
                if ($headers.'Date') {
                    $headers.'Date' = [DateTime]::Parse(
                        ($headers.'Date').Replace('UTC', '').Trim()
                    ).ToLocalTime().ToString('s')
                }
                if ($headers.'github-authentication-token-expiration') {
                    $headers.'github-authentication-token-expiration' = [DateTime]::Parse(
                        ($headers.'github-authentication-token-expiration').Replace('UTC', '').Trim()
                    ).ToLocalTime().ToString('s')
                }
                $sortedProperties = $headers.PSObject.Properties.Name | Sort-Object
                $headers = $headers | Select-Object $sortedProperties
                if ($debug) {
                    Write-Debug 'Response headers:'
                    $headers | Out-String -Stream | ForEach-Object { Write-Debug $_ }
                    Write-Debug '---------------------------'
                }
            }
            $errordetails = $failure.ErrorDetails | ConvertFrom-Json -AsHashtable
            $errors = $errordetails.errors
            $errorResult = [pscustomobject]@{
                Message     = $errordetails.message
                Resource    = $errors.resource
                Code        = $errors.code
                Details     = $errors.message
                Information = $errordetails.documentation_url
                Status      = $failure.Exception.Message
                StatusCode  = $errordetails.status
                ErrorTime   = Get-Date -Format 's'
            }

            $exception = @"

----------------------------------
Context:
$($Context | Format-List | Out-String)
----------------------------------
Request:
$([pscustomobject]$APICall | Select-Object -ExcludeProperty Body, Headers | Format-List | Out-String)
----------------------------------
Request headers:
$([pscustomobject]$APICall.Headers | Format-List | Out-String)
----------------------------------
Request body:
$("$($APICall.Body | Out-String -Stream)".Split('\n') -split '\n')
----------------------------------
Response headers:
$($headers | Format-List | Out-String)
----------------------------------
Error:
$($errorResult | Format-List | Out-String)
----------------------------------

"@
            $PSCmdlet.ThrowTerminatingError(
                [System.Management.Automation.ErrorRecord]::new(
                    [System.Exception]::new($exception),
                    'GitHubAPIError',
                    [System.Management.Automation.ErrorCategory]::InvalidOperation,
                    $errorResult
                )
            )
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [API] - [Invoke-GitHubAPI] - Done"
#endregion [functions] - [public] - [API] - [Invoke-GitHubAPI]
#region    [functions] - [public] - [API] - [Invoke-GitHubGraphQLQuery]
Write-Debug "[$scriptName] - [functions] - [public] - [API] - [Invoke-GitHubGraphQLQuery] - Importing"
function Invoke-GitHubGraphQLQuery {
    <#
        .SYNOPSIS
        Invoke a GraphQL requests against the GitHub GraphQL API

        .DESCRIPTION
        Use this function to invoke a GraphQL query and mutations against the GitHub GraphQL API with proper error handling.

        .EXAMPLE
        Invoke-GitHubGraphQLQuery -Query $query -Variables $Variables

        .LINK
        https://psmodule.io/GitHub/Functions/API/Invoke-GitHubGraphQLQuery

        .NOTES
        [GitHub GraphQL API documentation](https://docs.github.com/graphql)
    #>
    [CmdletBinding()]
    param(
        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter(Mandatory)]
        [string] $Query,

        # Variables to pass to the GraphQL query.
        [Parameter()]
        [hashtable] $Variables,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            query     = $Query
            variables = $Variables
        }

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = '/graphql'
            Body        = $body
            Context     = $Context
        }

        try {
            $apiResponse = Invoke-GitHubAPI @apiParams
            $graphQLResponse = $apiResponse.Response
            # Handle GraphQL-specific errors (200 OK with errors in response)
            if ($graphQLResponse.errors) {
                $errorMessages = @()
                $queryLines = $Query -split "`n" | ForEach-Object { $_.Trim() }
                foreach ($errorItem in $graphQLResponse.errors) {
                    $errorMessages += @"

GraphQL errors occurred:
Full Error:
$($errorItem | ConvertTo-Json -Depth 10 | Out-String)

GraphQL Error [$($errorItem.type)]:
Message:    $($errorItem.message)
Path:       $($errorItem.path -join '/')
Locations:
$($errorItem.locations | ForEach-Object { " - [$($_.line):$($_.column)] - $($queryLines[$_.line - 1])" })

"@

                }
                $PSCmdlet.ThrowTerminatingError(
                    [System.Management.Automation.ErrorRecord]::new(
                        [System.Exception]::new($errorMessages),
                        'GraphQLError',
                        [System.Management.Automation.ErrorCategory]::InvalidOperation,
                        $graphQLResponse
                    )
                )
            }

            $graphQLResponse.data
        } catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [API] - [Invoke-GitHubGraphQLQuery] - Done"
#endregion [functions] - [public] - [API] - [Invoke-GitHubGraphQLQuery]
Write-Debug "[$scriptName] - [functions] - [public] - [API] - Done"
#endregion [functions] - [public] - [API]
#region    [functions] - [public] - [Apps]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - Processing folder"
#region    [functions] - [public] - [Apps] - [GitHub App]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App] - Processing folder"
#region    [functions] - [public] - [Apps] - [GitHub App] - [Get-GitHubApp]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App] - [Get-GitHubApp] - Importing"
filter Get-GitHubApp {
    <#
        .SYNOPSIS
        Get the authenticated app or a specific app by its slug.

        .DESCRIPTION
        Returns a GitHub App associated with the authentication credentials used or the provided app-slug.

        .EXAMPLE
        Get-GitHubApp

        Get the authenticated app.

        .EXAMPLE
        Get-GitHubApp -Name 'github-actions'

        Get the GitHub App with the slug 'github-actions'.

        .OUTPUTS
        GitHubApp

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App/Get-GitHubApp

        .NOTES
        [Get an app](https://docs.github.com/rest/apps/apps#get-an-app)
        [Get the authenticated app | GitHub Docs](https://docs.github.com/rest/apps/apps#get-the-authenticated-app)
    #>
    [OutputType([GitHubApp])]
    [CmdletBinding(DefaultParameterSetName = 'Get the authenticated app')]
    param(
        # The AppSlug is just the URL-friendly name of a GitHub App.
        # You can find this on the settings page for your GitHub App (e.g., <https://github.com/settings/apps/{app_slug}>).
        # Example: 'github-actions'
        [Parameter(
            Mandatory,
            ParameterSetName = 'Get an app by slug',
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Slug,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'Get an app by slug' {
                Get-GitHubAppBySlug -Slug $Slug -Context $Context
            }
            default {
                Get-GitHubAuthenticatedApp -Context $Context
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App] - [Get-GitHubApp] - Done"
#endregion [functions] - [public] - [Apps] - [GitHub App] - [Get-GitHubApp]
#region    [functions] - [public] - [Apps] - [GitHub App] - [Get-GitHubAppInstallationRequest]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App] - [Get-GitHubAppInstallationRequest] - Importing"
filter Get-GitHubAppInstallationRequest {
    <#
        .SYNOPSIS
        List installation requests for the authenticated app.

        .DESCRIPTION
        Lists all the pending installation requests for the authenticated GitHub App.

        .EXAMPLE
        Get-GitHubAppInstallationRequest

        Lists all the pending installation requests for the authenticated GitHub App.

        .NOTES
        [List installation requests for the authenticated app](https://docs.github.com/rest/apps/apps#list-installation-requests-for-the-authenticated-app)

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App/Get-GitHubAppInstallationRequest
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '', Justification = 'Contains a long link.'
    )]
    [OutputType([GitHubAppInstallationRequest])]
    [CmdletBinding()]
    param(
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType APP
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/app/installation-requests'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response | ForEach-Object {
                [GitHubAppInstallationRequest]::new($_)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App] - [Get-GitHubAppInstallationRequest] - Done"
#endregion [functions] - [public] - [Apps] - [GitHub App] - [Get-GitHubAppInstallationRequest]
#region    [functions] - [public] - [Apps] - [GitHub App] - [Install-GitHubApp]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App] - [Install-GitHubApp] - Importing"
function Install-GitHubApp {
    <#
        .SYNOPSIS
        Install an app

        .DESCRIPTION
        Installs the provided GitHub App on the specified target.

        .EXAMPLE
        Install-GitHubApp -Enterprise 'msx' -Organization 'org' -ClientID '123456' -RepositorySelection 'selected' -Repositories 'repo1', 'repo2'

        Install the GitHub App with
        - the client ID '123456'
        - the repository selection 'selected'
        - the repositories 'repo1' and 'repo2'
        on the organization 'org' in the enterprise 'msx'.

        .EXAMPLE
        Install-GitHubApp -Enterprise 'msx' -Organization 'org' -ClientID '123456' -RepositorySelection 'all'

        Install the GitHub App with
        - the client ID '123456'
        - the repository selection 'all'
        on the organization 'org' in the enterprise 'msx'.

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App/Install-GitHubApp
    #>
    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]
    param(
        # The enterprise slug or ID.
        [Parameter(
            Mandatory,
            ParameterSetName = 'EnterpriseOrganization',
            ValueFromPipelineByPropertyName
        )]
        [string] $Enterprise,

        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ParameterSetName = 'EnterpriseOrganization',
            ValueFromPipelineByPropertyName
        )]
        [string] $Organization,

        # The client ID of the GitHub App to install.
        [Parameter(Mandatory)]
        [string] $ClientID,

        # The repository selection for the GitHub App. Can be one of:
        # - all - all repositories that the authenticated GitHub App installation can access.
        # - selected - select specific repositories.
        [Parameter()]
        [ValidateSet('all', 'selected')]
        [string] $RepositorySelection = 'selected',

        # The names of the repositories to which the installation will be granted access.
        [Parameter()]
        [string[]] $Repositories = @(),

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, UAT
        #enterprise_organization_installations=write
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'EnterpriseOrganization' {
                $params = @{
                    Enterprise          = $Enterprise
                    Organization        = $Organization
                    ClientID            = $ClientID
                    RepositorySelection = $RepositorySelection
                    Repositories        = $Repositories
                    Context             = $Context
                }
                Install-GitHubAppOnEnterpriseOrganization @params
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App] - [Install-GitHubApp] - Done"
#endregion [functions] - [public] - [Apps] - [GitHub App] - [Install-GitHubApp]
#region    [functions] - [public] - [Apps] - [GitHub App] - [Uninstall-GitHubApp]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App] - [Uninstall-GitHubApp] - Importing"
function Uninstall-GitHubApp {
    <#
        .SYNOPSIS
        Uninstall a GitHub App.

        .DESCRIPTION
        Uninstalls the provided GitHub App on the specified target.

        .EXAMPLE
        Uninstall-GitHubApp -Enterprise 'msx' -Organization 'org' -InstallationID '123456'

        Uninstall the GitHub App with the installation ID '123456' from the organization 'org' in the enterprise 'msx'.

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App/Uninstall-GitHubApp
    #>
    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]
    param(
        # The enterprise slug or ID.
        [Parameter(
            Mandatory,
            ParameterSetName = 'EnterpriseOrganization',
            ValueFromPipelineByPropertyName
        )]
        [string] $Enterprise,

        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ParameterSetName = 'EnterpriseOrganization',
            ValueFromPipelineByPropertyName
        )]
        [string] $Organization,

        # The client ID of the GitHub App to install.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('installation_id', 'InstallationID')]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'EnterpriseOrganization' {
                $params = @{
                    Enterprise   = $Enterprise
                    Organization = $Organization
                    ID           = $ID
                    Context      = $Context
                }
                Uninstall-GitHubAppOnEnterpriseOrganization @params
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App] - [Uninstall-GitHubApp] - Done"
#endregion [functions] - [public] - [Apps] - [GitHub App] - [Uninstall-GitHubApp]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App] - Done"
#endregion [functions] - [public] - [Apps] - [GitHub App]
#region    [functions] - [public] - [Apps] - [GitHub App Installations]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - Processing folder"
#region    [functions] - [public] - [Apps] - [GitHub App Installations] - [Add-GitHubAppInstallationRepositoryAccess]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - [Add-GitHubAppInstallationRepositoryAccess] - Importing"
function Add-GitHubAppInstallationRepositoryAccess {
    <#
        .SYNOPSIS
        Grant repository access to an organization installation.

        .DESCRIPTION
        Grant repository access to an organization installation.

        .EXAMPLE
        $params = @{
            Enterprise          = 'msx'
            Organization        = 'PSModule'
            InstallationID      = 12345678
            Repositories        = 'repo1', 'repo2'
        }
        Add-GitHubAppInstallationRepositoryAccess @params

        Grant access to the repositories 'repo1' and 'repo2' for the installation
        with the ID '12345678' on the organization 'PSModule' in the enterprise 'msx'.

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App%20Installations/Add-GitHubAppInstallationRepositoryAccess
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The enterprise slug or ID.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Enterprise,

        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Organization,

        # The unique identifier of the installation.
        # Example: '12345678'
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('installation_id', 'InstallationID')]
        [int] $ID,

        # The names of the repositories to which the installation will be granted access.
        [Parameter()]
        [string[]] $Repositories = @(),

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, UAT
        #enterprise_organization_installation_repositories=write
        #enterprise_organization_installations=write
    }

    process {
        $body = @{
            repositories = $Repositories
        }

        $apiParams = @{
            Method      = 'PATCH'
            APIEndpoint = "/enterprises/$Enterprise/apps/organizations/$Organization/installations/$ID/repositories/add"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("$Enterprise/$Organization", 'Add repo access to installation')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - [Add-GitHubAppInstallationRepositoryAccess] - Done"
#endregion [functions] - [public] - [Apps] - [GitHub App Installations] - [Add-GitHubAppInstallationRepositoryAccess]
#region    [functions] - [public] - [Apps] - [GitHub App Installations] - [Get-GitHubAppAccessibleRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - [Get-GitHubAppAccessibleRepository] - Importing"
function Get-GitHubAppAccessibleRepository {
    <#
        .SYNOPSIS
        Get repositories belonging to an enterprise owned organization that can be made accessible to a GitHub App

        .DESCRIPTION
        List the repositories belonging to an enterprise owned organization that can be made accessible to a GitHub App installed on that
        organization.

        The authenticated GitHub App must be installed on the enterprise and be granted the Enterprise/enterprise_organization_installations (read)
        permission.

        .EXAMPLE
        $params = @{
            Enterprise   = 'msx'
            Organization = 'PSModule'
        }
        Get-GitHubAppAccessibleRepository @params

        Get the repositories that can be made accessible to a GitHub App installed on the organization 'PSModule' in the enterprise 'msx'.

        .OUTPUTS
        GitHubRepository[]

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App%20Installations/Get-GitHubAppAccessibleRepository
    #>
    [OutputType([GitHubRepository[]])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The enterprise slug or ID.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Enterprise,

        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Organization,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, UAT
        # Enterprise organization installations (read)
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/enterprises/$Enterprise/apps/installable_organizations/$Organization/accessible_repositories"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($repo in $_.Response) {
                [GitHubRepository]@{
                    ID       = $repo.id
                    Name     = $repo.name
                    Owner    = [GitHubOwner]@{
                        Name = $Organization
                    }
                    FullName = $repo.full_name
                }
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - [Get-GitHubAppAccessibleRepository] - Done"
#endregion [functions] - [public] - [Apps] - [GitHub App Installations] - [Get-GitHubAppAccessibleRepository]
#region    [functions] - [public] - [Apps] - [GitHub App Installations] - [Get-GitHubAppInstallation]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - [Get-GitHubAppInstallation] - Importing"
function Get-GitHubAppInstallation {
    <#
        .SYNOPSIS
        List installations for the authenticated app, on organization or enterprise organization.

        .DESCRIPTION
        Lists the installations for the authenticated app.
        If the app is installed on an enterprise, the installations for the enterprise are returned.
        If the app is installed on an organization, the installations for the organization are returned.

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App%20Installations/Get-GitHubAppInstallation
    #>
    [OutputType([GitHubAppInstallation[]])]
    [CmdletBinding(DefaultParameterSetName = 'List installations for the authenticated app')]
    param(
        # The enterprise slug or ID.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName,
            ParameterSetName = 'List installations on an Enterprise'
        )]
        [string] $Enterprise,

        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName,
            ParameterSetName = 'List installations on an Enterprise'
        )]
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName,
            ParameterSetName = 'List installations on an Organization'
        )]
        [string] $Organization,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
    }

    process {
        $params = @{
            PerPage = $PerPage
            Context = $Context
        }
        Write-Debug "ParamSet: $($PSCmdlet.ParameterSetName)"
        switch ($PSCmdlet.ParameterSetName) {
            'List installations on an Enterprise' {
                $params += @{
                    Enterprise   = $Enterprise
                    Organization = $Organization
                }
                Get-GitHubEnterpriseOrganizationAppInstallation @params
            }
            'List installations on an Organization' {
                $params += @{
                    Organization = $Organization
                }
                Get-GitHubOrganizationAppInstallation @params
            }
            'List installations for the authenticated app' {
                Get-GitHubAppInstallationForAuthenticatedApp @params
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - [Get-GitHubAppInstallation] - Done"
#endregion [functions] - [public] - [Apps] - [GitHub App Installations] - [Get-GitHubAppInstallation]
#region    [functions] - [public] - [Apps] - [GitHub App Installations] - [Get-GitHubAppInstallationRepositoryAccess]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - [Get-GitHubAppInstallationRepositoryAccess] - Importing"
function Get-GitHubAppInstallationRepositoryAccess {
    <#
        .SYNOPSIS
        Get the repositories accessible to a given GitHub App installation.

        .DESCRIPTION
        Lists the repositories accessible to a given GitHub App installation on an enterprise-owned organization.

        The authenticated GitHub App must be installed on the enterprise and be granted the Enterprise/organization_installations (read) permission.

        .EXAMPLE
        $params = @{
            Enterprise          = 'msx'
            Organization        = 'PSModule'
            InstallationID      = 12345678
        }
        Get-GitHubAppInstallationRepositoryAccess @params

        Get the repositories accessible to the GitHub App installation
        with the ID '12345678' on the organization 'PSModule' in the enterprise 'msx'.

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App%20Installations/Get-GitHubAppInstallationRepositoryAccess
    #>
    [CmdletBinding()]
    param(
        # The enterprise slug or ID.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Enterprise,

        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Organization,

        # The unique identifier of the installation.
        # Example: '12345678'
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('installation_id', 'InstallationID')]
        [int] $ID,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, UAT
        #enterprise_organization_installation_repositories=read
        #enterprise_organization_installations=read
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/enterprises/$Enterprise/apps/organizations/$Organization/installations/$ID/repositories"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - [Get-GitHubAppInstallationRepositoryAccess] - Done"
#endregion [functions] - [public] - [Apps] - [GitHub App Installations] - [Get-GitHubAppInstallationRepositoryAccess]
#region    [functions] - [public] - [Apps] - [GitHub App Installations] - [Remove-GitHubAppInstallationRepositoryAccess]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - [Remove-GitHubAppInstallationRepositoryAccess] - Importing"
function Remove-GitHubAppInstallationRepositoryAccess {
    <#
        .SYNOPSIS
        Remove repository access to an organization installation.

        .DESCRIPTION
        Remove repository access to an organization installation.

        .EXAMPLE
        $params = @{
            Enterprise          = 'msx'
            Organization        = 'PSModule'
            InstallationID      = 12345678
            Repositories        = 'repo1', 'repo2'
        }
        Remove-GitHubAppInstallationRepositoryAccess @params

        Remove access to the repositories 'repo1' and 'repo2' for the installation
        with the ID '12345678' on the organization 'PSModule' in the enterprise 'msx'.

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App%20Installations/Remove-GitHubAppInstallationRepositoryAccess
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The enterprise slug or ID.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Enterprise,

        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Organization,

        # The unique identifier of the installation.
        # Example: '12345678'
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('installation_id', 'InstallationID')]
        [int] $ID,

        # The names of the repositories to which the installation will be granted access.
        [Parameter()]
        [string[]] $Repositories = @(),

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, UAT
        #enterprise_organization_installation_repositories=write
        #enterprise_organization_installations=write
    }

    process {
        $body = @{
            repositories = $Repositories
        }

        $apiParams = @{
            Method      = 'PATCH'
            APIEndpoint = "/enterprises/$Enterprise/apps/organizations/$Organization/installations/$ID/repositories/remove"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("$Enterprise/$Organization - $Repositories", 'Remove repository access')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - [Remove-GitHubAppInstallationRepositoryAccess] - Done"
#endregion [functions] - [public] - [Apps] - [GitHub App Installations] - [Remove-GitHubAppInstallationRepositoryAccess]
#region    [functions] - [public] - [Apps] - [GitHub App Installations] - [Update-GitHubAppInstallationRepositoryAccess]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - [Update-GitHubAppInstallationRepositoryAccess] - Importing"
function Update-GitHubAppInstallationRepositoryAccess {
    <#
        .SYNOPSIS
        Update the installation repository access between all repositories and selected repositories.

        .DESCRIPTION
        Update repository access for a GitHub App installation between all repositories and selected repositories.

        .EXAMPLE
        Update-GitHubAppInstallationRepositoryAccess -Enterprise 'msx' -Organization 'PSModule' -InstallationID 12345678 -RepositorySelection 'all'

        Update the repository access for the GitHub App installation with the ID '12345678'
        to all repositories on the organization 'PSModule' in the enterprise 'msx'.

        .EXAMPLE
        $params = @{
            Enterprise          = 'msx'
            Organization        = 'PSModule'
            InstallationID      = 12345678
            RepositorySelection = 'selected'
            Repositories        = 'repo1', 'repo2'
        }
        Update-GitHubAppInstallationRepositoryAccess @params

        Update the repository access for the GitHub App installation with the ID '12345678'
        to the repositories 'repo1' and 'repo2' on the organization 'PSModule' in the enterprise 'msx'.

        .LINK
        https://psmodule.io/GitHub/Functions/Apps/GitHub%20App%20Installations/Update-GitHubAppInstallationRepositoryAccess
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The enterprise slug or ID.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Enterprise,

        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName)]
        [string] $Organization,

        # The unique identifier of the installation.
        # Example: '12345678'
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('installation_id', 'InstallationID')]
        [int] $ID,

        # The repository selection for the GitHub App. Can be one of:
        # - all - all repositories that the authenticated GitHub App installation can access.
        # - selected - select specific repositories.
        [Parameter(Mandatory)]
        [ValidateSet('all', 'selected')]
        [string] $RepositorySelection,

        # The names of the repositories to which the installation will be granted access.
        [Parameter()]
        [string[]] $Repositories = @(),

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, UAT
        #enterprise_organization_installation_repositories=write
        #enterprise_organization_installations=write
    }

    process {
        $body = @{
            repository_selection = $RepositorySelection
            repositories         = $Repositories
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'PATCH'
            APIEndpoint = "/enterprises/$Enterprise/apps/organizations/$Organization/installations/$ID/repositories"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("$Enterprise/$Organization", 'Update repository access')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - [Update-GitHubAppInstallationRepositoryAccess] - Done"
#endregion [functions] - [public] - [Apps] - [GitHub App Installations] - [Update-GitHubAppInstallationRepositoryAccess]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - [GitHub App Installations] - Done"
#endregion [functions] - [public] - [Apps] - [GitHub App Installations]
Write-Debug "[$scriptName] - [functions] - [public] - [Apps] - Done"
#endregion [functions] - [public] - [Apps]
#region    [functions] - [public] - [Artifacts]
Write-Debug "[$scriptName] - [functions] - [public] - [Artifacts] - Processing folder"
#region    [functions] - [public] - [Artifacts] - [Get-GitHubArtifact]
Write-Debug "[$scriptName] - [functions] - [public] - [Artifacts] - [Get-GitHubArtifact] - Importing"
function Get-GitHubArtifact {
    <#
        .SYNOPSIS
        Retrieves GitHub Actions artifacts from a repository or workflow run.

        .DESCRIPTION
        This function fetches GitHub Actions artifacts by artifact ID, workflow run ID, or directly from a repository.
        It supports filtering by artifact name (with wildcards) and can optionally retrieve all versions of the artifacts.
        Artifacts contain metadata such as name, size, ID, and creation date. The function supports multiple parameter sets:
        - ById: Retrieve a specific artifact by its ID.
        - FromWorkflowRun: Retrieve artifacts from a specific workflow run.
        - FromRepository: Retrieve artifacts from a repository, optionally by name or with all versions.

        .EXAMPLE
        Get-GitHubArtifact -Owner 'octocat' -Repository 'Hello-World' -ID '123456'

        Output:
        ```powershell
        Name        : artifact-1
        ID          : 123456
        SizeInBytes : 2048
        CreatedAt   : 2024-12-01T10:00:00Z
        ```

        Retrieves a single GitHub Actions artifact using its unique artifact ID.

        .EXAMPLE
        Get-GitHubArtifact -Owner 'octocat' -Repository 'Hello-World' -WorkflowRunID '987654321'

        Output:
        ```powershell
        Name        : test-results
        ID          : 456789
        SizeInBytes : 4096
        CreatedAt   : 2025-01-15T15:25:00Z
        ```

        Retrieves the latest version of all artifacts from the specified workflow run.

        .EXAMPLE
        Get-GitHubArtifact -Owner 'octocat' -Repository 'Hello-World' -WorkflowRunID '987654321' -AllVersions

        Output:
        ```powershell
        Name        : test-results
        ID          : 4564584673
        SizeInBytes : 4096
        CreatedAt   : 2025-01-15T14:25:00Z

        Name        : test-results
        ID          : 4564584674
        SizeInBytes : 4096
        CreatedAt   : 2025-01-15T15:25:00Z
        ```

        Retrieves all versions of all artifacts from the specified workflow run.

        .EXAMPLE
        Get-GitHubArtifact -Owner 'octocat' -Repository 'Hello-World'

        Output:
        ```powershell
        Name        : build-artifact
        ID          : 998877
        SizeInBytes : 8192
        CreatedAt   : 2025-02-01T09:45:00Z
        ```

        Retrieves the latest version of all artifacts from the specified repository.

        .OUTPUTS
        GitHubArtifact[]

        .LINK
        https://psmodule.io/GitHub/Functions/Artifacts/Get-GitHubArtifact/
    #>

    [OutputType([GitHubArtifact[]])]
    [CmdletBinding(DefaultParameterSetName = 'FromRepository')]
    param(
        # The owner of the repository (GitHub user or org name).
        [Parameter(Mandatory, ParameterSetName = 'ById', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'FromWorkflowRun', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'FromRepository', ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension.
        [Parameter(Mandatory, ParameterSetName = 'ById', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'FromWorkflowRun', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'FromRepository', ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # Retrieves a single artifact by its unique ID.
        [Parameter(Mandatory, ParameterSetName = 'ById')]
        [string] $ID,

        # Retrieves artifacts from a specific workflow run.
        [Parameter(Mandatory, ParameterSetName = 'FromWorkflowRun', ValueFromPipelineByPropertyName)]
        [Alias('WorkflowRun')]
        [string] $WorkflowRunID,

        # Retrieves artifacts by name or all artifacts across a repo.
        [Parameter(ParameterSetName = 'FromRepository')]
        [Parameter(ParameterSetName = 'FromWorkflowRun')]
        [SupportsWildcards()]
        [string] $Name,

        # Return all versions of artifacts.
        [Parameter(ParameterSetName = 'FromRepository')]
        [Parameter(ParameterSetName = 'FromWorkflowRun')]
        [switch] $AllVersions,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $params = @{
            Owner      = $Owner
            Repository = $Repository
            Context    = $Context
        }
        switch ($PSCmdlet.ParameterSetName) {
            'ById' {
                Get-GitHubArtifactById @params -ID $ID
            }
            'FromWorkflowRun' {
                if ($Name.Contains('*')) {
                    Get-GitHubArtifactFromWorkflowRun @params -ID $WorkflowRunID -AllVersions:$AllVersions |
                        Where-Object { $_.Name -like $Name }
                } else {
                    Get-GitHubArtifactFromWorkflowRun @params -ID $WorkflowRunID -Name $Name -AllVersions:$AllVersions
                }
            }
            'FromRepository' {
                if ($Name.Contains('*')) {
                    Get-GitHubArtifactFromRepository @params -AllVersions:$AllVersions |
                        Where-Object { $_.Name -like $Name }
                } else {
                    Get-GitHubArtifactFromRepository @params -Name $Name -AllVersions:$AllVersions
                }
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Artifacts] - [Get-GitHubArtifact] - Done"
#endregion [functions] - [public] - [Artifacts] - [Get-GitHubArtifact]
#region    [functions] - [public] - [Artifacts] - [Remove-GitHubArtifact]
Write-Debug "[$scriptName] - [functions] - [public] - [Artifacts] - [Remove-GitHubArtifact] - Importing"
function Remove-GitHubArtifact {
    <#
        .SYNOPSIS
        Deletes an artifact from a GitHub repository by its unique ID.

        .DESCRIPTION
        Deletes an artifact associated with a workflow run in a GitHub repository.
        The user must provide the repository owner, repository name, and the artifact ID.
        OAuth tokens and personal access tokens (classic) must have the `repo` scope to use this endpoint.
        The function uses the GitHub REST API to perform the deletion and supports `ShouldProcess` for safe execution.

        .EXAMPLE
        Remove-GitHubArtifact -Owner 'octocat' -Repository 'demo-repo' -ID '123456'

        Deletes the artifact with ID 123456 from the repository 'demo-repo' owned by 'octocat'.

        .INPUTS
        GitHubArtifact

        .OUTPUTS
        void

        .NOTES
        This function does not return any output.
        It performs a delete operation against the GitHub REST API and is silent on success.

        .LINK
        https://psmodule.io/GitHub/Functions/Artifacts/Remove-GitHubArtifact

        .NOTES
        [Delete an artifact](https://docs.github.com/rest/actions/artifacts#delete-an-artifact)
    #>
    [OutputType([GitHubArtifact])]
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The unique identifier of the artifact.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/repos/$Owner/$Repository/actions/artifacts/$ID"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("artifact [$Owner/$Repository/$ID]", 'Remove')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Artifacts] - [Remove-GitHubArtifact] - Done"
#endregion [functions] - [public] - [Artifacts] - [Remove-GitHubArtifact]
#region    [functions] - [public] - [Artifacts] - [Save-GitHubArtifact]
Write-Debug "[$scriptName] - [functions] - [public] - [Artifacts] - [Save-GitHubArtifact] - Importing"
function Save-GitHubArtifact {
    <#
        .SYNOPSIS
        Downloads a GitHub Actions artifact.

        .DESCRIPTION
        Downloads an artifact from a repository. The artifact is downloaded as a ZIP file to the specified path
        or the current directory by default. Users must have read access to the repository. For private repositories,
        personal access tokens (classic) or OAuth tokens with the `repo` scope are required.

        .EXAMPLE
        Save-GitHubArtifact -Owner 'octocat' -Repository 'Hello-World' -ID '123456' -Path 'C:\Artifacts'

        Output:
        ```powershell
        Directory: C:\Artifacts

        Mode                 LastWriteTime         Length Name
        ----                 -------------         ------ ----
        d-----        03/31/2025     12:00                artifact-123456.zip
        ```

        Downloads artifact ID '123456' from the 'Hello-World' repository owned by 'octocat' to the specified path.

        .EXAMPLE
        Save-GitHubArtifact -Owner 'octocat' -Repository 'Hello-World' -Name 'module' -Path 'C:\Artifacts\module' -Expand -Force

        Output:
        ```powershell
        Directory: C:\Artifacts

        Mode                 LastWriteTime         Length Name
        ----                 -------------         ------ ----
        d-----        03/31/2025     12:00                artifact-123456.zip
        ```

        Downloads artifact ID 123456 from the 'Hello-World' repository owned by 'octocat' to the specified path,
        overwriting existing files during download and extraction.

        .INPUTS
        GitHubArtifact

        .OUTPUTS
        System.IO.FileSystemInfo[]

        .NOTES
        Contains the extracted file or folder information from the downloaded artifact.
        This output can include directories or files depending on the artifact content.

        .LINK
        https://psmodule.io/GitHub/Functions/Artifacts/Save-GitHubArtifact/

        .NOTES
        [Get an artifact](https://docs.github.com/rest/actions/artifacts#get-an-artifact)
    #>
    [OutputType([System.IO.FileSystemInfo[]])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The unique identifier of the artifact.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $ID,

        # Path to the file or folder for the download. Accepts relative or absolute paths.
        [Parameter()]
        [string] $Path = $PWD.Path,

        # When specified, the ZIP file is extracted to the same directory it was downloaded to.
        [Parameter()]
        [Alias('Extract')]
        [switch] $Expand,

        # When specified, overwrites existing files during download and extraction.
        [Parameter()]
        [switch] $Force,

        # When specified, the ZIP file or the folder where the ZIP file was extracted to is returned.
        [Parameter()]
        [switch] $PassThru,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/actions/artifacts/$ID/zip"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $headers = $_.Headers
            $itemType = $Path.EndsWith('.zip') ? 'File' : 'Directory'
            $isAbsolute = [System.IO.Path]::IsPathRooted($Path)
            Write-Debug "Path:        [$Path]"
            Write-Debug "Type:        [$itemType]"
            Write-Debug "Is absolute: [$isAbsolute]"

            if ($itemType -eq 'Directory') {
                if ($headers.'Content-Disposition' -match 'filename="(?<filename>[^"]+)"') {
                    $filename = $matches['filename']
                } else {
                    Write-Debug 'No filename found in Content-Disposition header. Getting artifact name.'
                    $artifactName = (Get-GitHubArtifact -Owner $Owner -Repository $Repository -ID $ID -Context $Context).Name
                    $filename = "$artifactName.zip"
                }
                $Path = Join-Path -Path $Path -ChildPath $filename
            }

            $folderPath = [System.IO.Path]::GetDirectoryName($Path)
            $folder = New-Item -Path $folderPath -ItemType Directory -Force
            Write-Debug "Resolved final download path: [$Path]"
            [System.IO.File]::WriteAllBytes($Path, $_.Response)

            if ($Expand) {
                Write-Debug "Expanding artifact to [$folder]"
                Expand-Archive -LiteralPath $Path -DestinationPath $folder -Force:$Force
                Write-Debug "Removing ZIP file [$Path]"
                Remove-Item -LiteralPath $Path -Force
                if ($PassThru) {
                    return $folder
                }
            }
            if ($PassThru) {
                return Get-Item -Path $Path
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Artifacts] - [Save-GitHubArtifact] - Done"
#endregion [functions] - [public] - [Artifacts] - [Save-GitHubArtifact]
Write-Debug "[$scriptName] - [functions] - [public] - [Artifacts] - Done"
#endregion [functions] - [public] - [Artifacts]
#region    [functions] - [public] - [Auth]
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - Processing folder"
#region    [functions] - [public] - [Auth] - [Connect-GitHubAccount]
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Connect-GitHubAccount] - Importing"
function Connect-GitHubAccount {
    <#
        .SYNOPSIS
        Connects to GitHub.

        .DESCRIPTION
        Connects to GitHub using one of the following logon methods:
        - a personal access token
        - device code login (interactive user login)
        - a system access token (for GitHub Actions)
        - a GitHub App using JWT or installation access token

        For device flow / device code login:
        PowerShell requests device and user verification codes and gets the authorization URL where you will enter the user verification code.
        In GitHub you will be asked to enter a user verification code at <https://github.com/login/device>.
        PowerShell will keep polling GitHub for the user authentication status. Once you have authorized the device,
        the app will be able to make API calls with a new access token.

        .EXAMPLE
        Connect-GitHubAccount

        Connects to GitHub using a device flow login.
        If the user has already logged in, the access token will be refreshed.

        .EXAMPLE
        $env:GH_TOKEN = '***'
        Connect-GitHubAccount

        Connects to GitHub using the access token from environment variable, assuming unattended mode.

        .EXAMPLE
        Connect-GitHubAccount -UseAccessToken
        ! Enter your personal access token: *************

        User gets prompted for the access token and stores it in the context.
        The token is used when connecting to GitHub.

        .EXAMPLE
        Connect-GitHubAccount -Mode 'OAuthApp' -Scope 'gist read:org repo workflow'

        Connects to GitHub using a device flow login and sets the scope of the access token.

        .NOTES
        [Authenticating to the REST API](https://docs.github.com/rest/overview/other-authentication-methods#authenticating-for-saml-sso)

        .LINK
        https://psmodule.io/GitHub/Functions/Auth/Connect-GitHubAccount
    #>
    [Alias('Connect-GitHub')]
    [OutputType([void])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '',
        Justification = 'Long links for documentation.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '',
        Justification = 'Is the CLI part of the module.'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingConvertToSecureStringWithPlainText', '',
        Justification = 'The tokens are received as clear text. Mitigating exposure by removing variables and performing garbage collection.'
    )]
    [CmdletBinding(DefaultParameterSetName = 'UAT')]
    param(
        # Choose between authentication methods, either OAuthApp or GitHubApp.
        # For more info about the types of authentication visit:
        # [Differences between GitHub Apps and OAuth apps](https://docs.github.com/apps/oauth-apps/building-oauth-apps/differences-between-github-apps-and-oauth-apps)
        [Parameter(ParameterSetName = 'UAT')]
        [ValidateSet('OAuthApp', 'GitHubApp')]
        [string] $Mode = 'GitHubApp',

        # The scope of the access token, when using OAuth authentication.
        # Provide the list of scopes as space-separated values.
        # For more information on scopes visit:
        # [Scopes for OAuth apps](https://docs.github.com/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps)
        [Parameter(ParameterSetName = 'UAT')]
        [string] $Scope = 'gist read:org repo workflow',


        # The user will be prompted to enter the token.
        [Parameter(Mandatory, ParameterSetName = 'PAT')]
        [switch] $UseAccessToken,

        # An access token to use for authentication. Can be both a string or a SecureString.
        # Supports both personal access tokens (PAT) and GitHub App installation access tokens (IAT).
        # Example: 'ghp_1234567890abcdef'
        # Example: 'ghs_1234567890abcdef'
        [Parameter(Mandatory, ParameterSetName = 'Token')]
        [object] $Token,

        # The client ID for the GitHub App to use for authentication.
        [Parameter(ParameterSetName = 'UAT')]
        [Parameter(Mandatory, ParameterSetName = 'GitHub App using a PrivateKey')]
        [Parameter(Mandatory, ParameterSetName = 'GitHub App using a KeyVault Key Reference')]
        [string] $ClientID,

        # The private key that is used to sign JWTs for the GitHub App.
        [Parameter(Mandatory, ParameterSetName = 'GitHub App using a PrivateKey')]
        [object] $PrivateKey,

        # The KeyVault Key Reference that can sign JWTs for the GitHub App.
        [Parameter(Mandatory, ParameterSetName = 'GitHub App using a KeyVault Key Reference')]
        [ValidateScript({
                if ($_ -notlike 'https://*.vault.azure.net/keys/*') {
                    throw "Invalid Key Vault key reference format: $_"
                }
                return $true
            })]
        [string] $KeyVaultKeyReference,

        # Automatically load installations for the GitHub App.
        [Parameter(ParameterSetName = 'GitHub App using a PrivateKey')]
        [Parameter(ParameterSetName = 'GitHub App using a KeyVault Key Reference')]
        [switch] $AutoloadInstallations,

        # The default enterprise to use in commands.
        [Parameter()]
        [string] $Enterprise,

        # Set the default owner to use in commands.
        [Parameter()]
        [Alias('Organization')]
        [string] $Owner,

        # Set the default repository to use in commands.
        [Parameter()]
        [string] $Repository,

        # The host to connect to. Can use $env:GITHUB_SERVER_URL to set the host, as the protocol is removed automatically.
        # Example: github.com, github.enterprise.com, msx.ghe.com
        [Parameter()]
        [Alias('Host')]
        [Alias('Server')]
        [string] $HostName,

        # Suppresses the output of the function.
        [Parameter()]
        [Alias('Quiet')]
        [switch] $Silent,

        # Make the connected context NOT the default context.
        [Parameter()]
        [switch] $NotDefault,

        # Passes the context object to the pipeline.
        [Parameter()]
        [switch] $PassThru
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Initialize-GitHubConfig
    }

    process {
        try {
            if ($Token -is [System.Security.SecureString]) {
                $Token = ConvertFrom-SecureString $Token -AsPlainText
            }

            if (-not $HostName) {
                $HostName = $script:GitHub.Config.HostName
            }
            $httpVersion = $script:GitHub.Config.HttpVersion
            $perPage = $script:GitHub.Config.PerPage
            $ApiVersion = $script:GitHub.Config.ApiVersion
            $HostName = $HostName -replace '^https?://'
            $ApiBaseUri = "https://api.$HostName"

            # If running on GitHub Actions and no access token is provided, use the GitHub token.
            if ($script:IsGitHubActions -and $PSCmdlet.ParameterSetName -notin @('GitHub App using a PrivateKey', 'GitHub App using a KeyVault Key Reference')) {
                $customTokenProvided = -not [string]::IsNullOrEmpty($Token)
                $gitHubTokenPresent = Test-GitHubToken
                Write-Verbose "A token was provided:  [$customTokenProvided]"
                Write-Verbose "Detected GitHub token: [$gitHubTokenPresent]"
                $usingGitHubToken = $gitHubTokenPresent -and -not $customTokenProvided
                if ($usingGitHubToken) {
                    $authType = 'Token'
                    $Token = Get-GitHubToken
                }
            }

            $context = @{
                ApiBaseUri  = [string]$ApiBaseUri
                ApiVersion  = [string]$ApiVersion
                HostName    = [string]$HostName
                HttpVersion = [string]$httpVersion
                PerPage     = [int]$perPage
                Enterprise  = [string]$Enterprise
                Owner       = [string]$Owner
                Repository  = [string]$Repository
            }

            $context | Format-Table | Out-String -Stream | ForEach-Object { Write-Verbose $_ }

            switch ($PSCmdlet.ParameterSetName) {
                'UAT' {
                    Write-Verbose 'Logging in using device flow...'
                    if (-not [string]::IsNullOrEmpty($ClientID)) {
                        Write-Verbose "Using provided ClientID: [$ClientID]"
                        $authClientID = $ClientID
                    } else {
                        switch ($Mode) {
                            'GitHubApp' {
                                Write-Verbose "Using default ClientID: [$($script:GitHub.Config.GitHubAppClientID)]"
                                $authClientID = $($script:GitHub.Config.GitHubAppClientID)
                            }
                            'OAuthApp' {
                                Write-Verbose "Using default ClientID: [$($script:GitHub.Config.OAuthAppClientID)]"
                                $authClientID = $($script:GitHub.Config.OAuthAppClientID)
                            }
                            default {
                                Write-Warning '⚠ ' -ForegroundColor Yellow -NoNewline
                                Write-Warning "Unexpected authentication mode: $Mode"
                                return
                            }
                        }
                    }
                    Write-Verbose "Using $Mode authentication..."
                    $tokenResponse = Invoke-GitHubDeviceFlowLogin -ClientID $authClientID -Scope $Scope -HostName $HostName

                    switch ($Mode) {
                        'GitHubApp' {
                            $context += @{
                                AuthType              = 'UAT'
                                Token                 = ConvertTo-SecureString -AsPlainText $tokenResponse.access_token
                                TokenExpiresAt        = ([DateTime]::Now).AddSeconds($tokenResponse.expires_in)
                                TokenType             = $tokenResponse.access_token -replace $script:GitHub.TokenPrefixPattern
                                AuthClientID          = $authClientID
                                DeviceFlowType        = $Mode
                                RefreshToken          = ConvertTo-SecureString -AsPlainText $tokenResponse.refresh_token
                                RefreshTokenExpiresAt = ([DateTime]::Now).AddSeconds($tokenResponse.refresh_token_expires_in)
                                Scope                 = $tokenResponse.scope
                            }
                        }
                        'OAuthApp' {
                            $context += @{
                                AuthType       = 'UAT'
                                Token          = ConvertTo-SecureString -AsPlainText $tokenResponse.access_token
                                TokenType      = $tokenResponse.access_token -replace $script:GitHub.TokenPrefixPattern
                                AuthClientID   = $authClientID
                                DeviceFlowType = $Mode
                                Scope          = $tokenResponse.scope
                            }
                        }
                        default {
                            Write-Host '⚠ ' -ForegroundColor Yellow -NoNewline
                            Write-Host "Unexpected authentication mode: $Mode"
                            return
                        }
                    }
                }
                'GitHub App using a PrivateKey' {
                    Write-Verbose 'Logging in as a GitHub App using PrivateKey...'
                    if (-not($PrivateKey -is [System.Security.SecureString])) {
                        $PrivateKey = $PrivateKey | ConvertTo-SecureString -AsPlainText
                    }
                    $context += @{
                        AuthType   = 'APP'
                        PrivateKey = $PrivateKey
                        TokenType  = 'JWT'
                        ClientID   = $ClientID
                    }
                }
                'GitHub App using a KeyVault Key Reference' {
                    Write-Verbose 'Logging in as a GitHub App using KeyVault Key Reference...'
                    $context += @{
                        AuthType             = 'APP'
                        KeyVaultKeyReference = $KeyVaultKeyReference
                        TokenType            = 'JWT'
                        ClientID             = $ClientID
                    }
                }
                'PAT' {
                    Write-Debug "UseAccessToken is set to [$UseAccessToken]. Using provided access token..."
                    Write-Verbose 'Logging in using personal access token...'
                    Write-Host '! ' -ForegroundColor DarkYellow -NoNewline
                    Start-Process "https://$HostName/settings/tokens"
                    $accessTokenValue = Read-Host -Prompt 'Enter your personal access token' -AsSecureString
                    $Token = ConvertFrom-SecureString $accessTokenValue -AsPlainText
                    $tokenType = $Token -replace $script:GitHub.TokenPrefixPattern
                    $context += @{
                        AuthType  = 'PAT'
                        Token     = ConvertTo-SecureString -AsPlainText $Token
                        TokenType = $tokenType
                    }
                }
                'Token' {
                    $tokenType = $Token -replace $script:GitHub.TokenPrefixPattern
                    switch -Regex ($tokenType) {
                        'ghp|github_pat' {
                            Write-Verbose 'Logging in using a user access token...'
                            $context += @{
                                Token     = ConvertTo-SecureString -AsPlainText $Token
                                TokenType = $tokenType
                            }
                            $context['AuthType'] = 'PAT'
                        }
                        'ghs' {
                            Write-Verbose 'Logging in using an installation access token...'
                            $context += @{
                                Token     = ConvertTo-SecureString -AsPlainText $Token
                                TokenType = $tokenType
                            }
                            $context['AuthType'] = 'IAT'
                        }
                        default {
                            Write-Host '⚠ ' -ForegroundColor Yellow -NoNewline
                            Write-Host "Unexpected token type: $tokenType"
                            throw "Unexpected token type: $tokenType"
                        }
                    }
                }
                default {}
            }
            $contextObj = Set-GitHubContext -Context $context -Default:(!$NotDefault) -PassThru
            $contextObj | Format-List | Out-String -Stream | ForEach-Object { Write-Verbose $_ }
            if (-not $Silent) {
                $name = $contextObj.Username
                if ($script:IsGitHubActions) {
                    $green = $PSStyle.Foreground.Green
                    $reset = $PSStyle.Reset
                    Write-Host "$green✓$reset Logged in as $name!"
                } else {
                    Write-Host '✓ ' -ForegroundColor Green -NoNewline
                    Write-Host "Logged in as $name!"
                }
            }
            if ($PassThru) {
                Write-Debug "Passing context [$contextObj] to the pipeline."
                $contextObj
            }

            if ($authType -eq 'App' -and $AutoloadInstallations) {
                Write-Verbose 'Loading GitHub App Installation contexts...'
                Connect-GitHubApp -Silent:$Silent
            }

        } catch {
            Write-Error $_
            Write-Error (Get-PSCallStack | Format-Table | Out-String)
            throw 'Failed to connect to GitHub.'
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Connect-GitHubAccount] - Done"
#endregion [functions] - [public] - [Auth] - [Connect-GitHubAccount]
#region    [functions] - [public] - [Auth] - [Connect-GitHubApp_completer]
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Connect-GitHubApp_completer] - Importing"
Register-ArgumentCompleter -CommandName Connect-GitHubApp -ParameterName User -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter

    Get-GitHubAppInstallation -Verbose:$false | Where-Object { $_.Type -eq 'User' -and $_.Target.Name -like "$wordToComplete*" } |
        ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_.Target.Name, $_.Target.Name, 'ParameterValue', $_.Target.Name)
        }
}
Register-ArgumentCompleter -CommandName Connect-GitHubApp -ParameterName Organization -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter

    Get-GitHubAppInstallation -Verbose:$false | Where-Object { $_.Type -eq 'Organization' -and $_.Target.Name -like "$wordToComplete*" } |
        ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_.Target.Name, $_.Target.Name, 'ParameterValue', $_.Target.Name)
        }
}
Register-ArgumentCompleter -CommandName Connect-GitHubApp -ParameterName Enterprise -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter

    Get-GitHubAppInstallation -Verbose:$false | Where-Object { $_.Type -eq 'Enterprise' -and $_.Target.Name -like "$wordToComplete*" } |
        ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_.Target.Name, $_.Target.Name, 'ParameterValue', $_.Target.Name)
        }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Connect-GitHubApp_completer] - Done"
#endregion [functions] - [public] - [Auth] - [Connect-GitHubApp_completer]
#region    [functions] - [public] - [Auth] - [Connect-GitHubApp]
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Connect-GitHubApp] - Importing"
function Connect-GitHubApp {
    <#
        .SYNOPSIS
        Connects to GitHub as a installation using a GitHub App.

        .DESCRIPTION
        Connects to GitHub using a GitHub App to generate installation access tokens and create contexts for targets.

        Available target types:
        - User
        - Organization
        - Enterprise

        .EXAMPLE
        Connect-GitHubApp

        Connects to GitHub as all available targets using the logged in GitHub App.

        .EXAMPLE
        Connect-GitHubApp -User 'octocat'

        Connects to GitHub as the user 'octocat' using the logged in GitHub App.

        .EXAMPLE
        Connect-GitHubApp -Organization 'psmodule' -Default

        Connects to GitHub as the organization 'psmodule' using the logged in GitHub App and sets it as the default context.

        .EXAMPLE
        Connect-GitHubApp -Enterprise 'msx'

        Connects to GitHub as the enterprise 'msx' using the logged in GitHub App.

        .NOTES
        [Authenticating to the REST API](https://docs.github.com/rest/overview/other-authentication-methods#authenticating-for-saml-sso)

        .LINK
        https://psmodule.io/GitHub/Functions/Auth/Connect-GitHubApp
    #>
    [OutputType([void])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingWriteHost', '', Justification = 'Is the CLI part of the module.')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingConvertToSecureStringWithPlainText', '',
        Justification = 'The tokens are received as clear text. Mitigating exposure by removing variables and performing garbage collection.')]
    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]
    param(
        # The user account to connect to.
        [Parameter(ParameterSetName = 'Filtered')]
        [SupportsWildcards()]
        [string[]] $User,

        # The organization to connect to.
        [Parameter(ParameterSetName = 'Filtered')]
        [SupportsWildcards()]
        [string[]] $Organization,

        # The enterprise to connect to.
        [Parameter(ParameterSetName = 'Filtered')]
        [SupportsWildcards()]
        [string[]] $Enterprise,

        # Passes the context object to the pipeline.
        [Parameter()]
        [switch] $PassThru,

        # Suppresses the output of the function.
        [Parameter()]
        [Alias('Quiet')]
        [switch] $Silent,

        # Set as the default context.
        [Parameter()]
        [switch] $Default,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType App
    }

    process {
        $installations = Get-GitHubAppInstallation -Context $Context
        $selectedInstallations = @()
        Write-Verbose "Found [$($installations.Count)] installations."
        switch ($PSCmdlet.ParameterSetName) {
            'Filtered' {
                $User | ForEach-Object {
                    $userItem = $_
                    Write-Verbose "User filter:         [$userItem]."
                    $selectedInstallations += $installations | Where-Object {
                        $_.Type -eq 'User' -and $_.Target.Name -like $userItem
                    }
                }
                $Organization | ForEach-Object {
                    $organizationItem = $_
                    Write-Verbose "Organization filter: [$organizationItem]."
                    $selectedInstallations += $installations | Where-Object {
                        $_.Type -eq 'Organization' -and $_.Target.Name -like $organizationItem
                    }
                }
                $Enterprise | ForEach-Object {
                    $enterpriseItem = $_
                    Write-Verbose "Enterprise filter:   [$enterpriseItem]."
                    $selectedInstallations += $installations | Where-Object {
                        $_.Type -eq 'Enterprise' -and $_.Target.Name -like $enterpriseItem
                    }
                }
            }
            default {
                Write-Verbose 'No target specified. Connecting to all installations.'
                $selectedInstallations = $installations
            }
        }

        Write-Verbose "Found [$($selectedInstallations.Count)] installations for the target."
        $selectedInstallations | ForEach-Object {
            $installation = $_
            Write-Verbose "Processing installation [$($installation.Target.Name)] [$($installation.id)]"
            $token = New-GitHubAppInstallationAccessToken -Context $Context -ID $installation.id

            $contextParams = @{
                AuthType         = [string]'IAT'
                TokenType        = [string]'ghs'
                DisplayName      = [string]$Context.DisplayName
                ApiBaseUri       = [string]$Context.ApiBaseUri
                ApiVersion       = [string]$Context.ApiVersion
                HostName         = [string]$Context.HostName
                HttpVersion      = [string]$Context.HttpVersion
                PerPage          = [int]$Context.PerPage
                ClientID         = [string]$Context.ClientID
                InstallationID   = [string]$installation.id
                Permissions      = [pscustomobject]$installation.permissions
                Events           = [string[]]$installation.events
                InstallationType = [string]$installation.Type
                Token            = [securestring]$token.Token
                TokenExpiresAt   = [datetime]$token.ExpiresAt
            }

            switch ($installation.Type) {
                'User' {
                    $contextParams['InstallationName'] = [string]$installation.Target.Name
                    $contextParams['Owner'] = [string]$installation.Target.Name
                }
                'Organization' {
                    $contextParams['InstallationName'] = [string]$installation.Target.Name
                    $contextParams['Owner'] = [string]$installation.Target.Name
                }
                'Enterprise' {
                    $contextParams['InstallationName'] = [string]$installation.Target.Name
                    $contextParams['Enterprise'] = [string]$installation.Target.Name
                }
            }
            Write-Verbose 'Logging in using a managed installation access token...'
            $contextParams | Format-Table | Out-String -Stream | ForEach-Object { Write-Verbose $_ }
            $contextObj = [GitHubAppInstallationContext]::new((Set-GitHubContext -Context $contextParams.Clone() -PassThru -Default:$Default))
            $contextObj | Format-List | Out-String -Stream | ForEach-Object { Write-Verbose $_ }
            if (-not $Silent) {
                $name = $contextObj.Name
                if ($script:IsGitHubActions) {
                    $green = $PSStyle.Foreground.Green
                    $reset = $PSStyle.Reset
                    Write-Host "$green✓$reset Connected $name!"
                } else {
                    Write-Host '✓ ' -ForegroundColor Green -NoNewline
                    Write-Host "Connected $name!"
                }
            }
            if ($PassThru) {
                Write-Debug "Passing context [$contextObj] to the pipeline."
                Write-Output $contextObj
            }
            $contextParams.Clear()
        }

    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Connect-GitHubApp] - Done"
#endregion [functions] - [public] - [Auth] - [Connect-GitHubApp]
#region    [functions] - [public] - [Auth] - [Disconnect-GitHubAccount]
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Disconnect-GitHubAccount] - Importing"
function Disconnect-GitHubAccount {
    <#
        .SYNOPSIS
        Disconnects from GitHub and removes the GitHub context.

        .DESCRIPTION
        Disconnects from GitHub and removes the GitHub context. Optionally revokes the access token
        to ensure it cannot be used after disconnection.

        .EXAMPLE
        Disconnect-GitHubAccount

        Disconnects from GitHub and removes the default GitHub context.

        .EXAMPLE
        Disconnect-GithubAccount -Context 'github.com/Octocat'

        Disconnects from GitHub and removes the context 'github.com/Octocat'.

        .EXAMPLE
        Disconnect-GitHubAccount -RevokeToken

        Disconnects from GitHub, revokes the access token, and removes the default GitHub context.

        .EXAMPLE
        Disconnect-GithubAccount -Context 'github.com/Octocat' -RevokeToken

        Disconnects from GitHub, revokes the access token, and removes the context 'github.com/Octocat'.

        .LINK
        https://psmodule.io/GitHub/Functions/Auth/Disconnect-GitHubAccount
    #>
    [Alias('Disconnect-GitHub')]
    [OutputType([void])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingWriteHost', '', Justification = 'Is the CLI part of the module.')]
    [CmdletBinding()]
    param(
        # Suppresses the output of the function.
        [Parameter()]
        [Alias('Quiet')]
        [switch] $Silent,

        # The context to run the command with.
        # Can be either a string or a GitHubContext object.
        [Parameter(ValueFromPipeline)]
        [object[]] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if (-not $Context) {
            $Context = Get-GitHubContext
        }
        foreach ($contextItem in $Context) {
            $contextItem = Resolve-GitHubContext -Context $contextItem

            $contextToken = Get-GitHubAccessToken -Context $contextItem -AsPlainText
            $isGitHubToken = $contextToken -eq (Get-GitHubToken | ConvertFrom-SecureString -AsPlainText)
            if (-not $isGitHubToken -and $contextItem.AuthType -eq 'IAT') {
                Revoke-GitHubAppInstallationAccessToken -Context $contextItem
            }

            Remove-GitHubContext -Context $contextItem.ID
            $isDefaultContext = $contextItem.Name -eq $script:GitHub.Config.DefaultContext
            if ($isDefaultContext) {
                Remove-GitHubConfig -Name 'DefaultContext'
                if (-not $Silent) {
                    Write-Warning 'There is no longer a default context!'
                    Write-Warning "Please set a new default context using 'Switch-GitHubContext -Name <context>'"
                }
            }

            if (-not $Silent) {
                if ($script:IsGitHubActions) {
                    $green = $PSStyle.Foreground.Green
                    $reset = $PSStyle.Reset
                    Write-Host "$green✓$reset Logged out of GitHub! [$contextItem]"
                } else {
                    Write-Host '✓ ' -ForegroundColor Green -NoNewline
                    Write-Host "Logged out of GitHub! [$contextItem]"
                }
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Disconnect-GitHubAccount] - Done"
#endregion [functions] - [public] - [Auth] - [Disconnect-GitHubAccount]
#region    [functions] - [public] - [Auth] - [Get-GitHubAccessToken]
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Get-GitHubAccessToken] - Importing"
function Get-GitHubAccessToken {
    <#
        .SYNOPSIS
        Retrieves the GitHub access token from the specified context.

        .DESCRIPTION
        Returns the access token from the provided context.
        If the -AsPlainText switch is specified, the token is returned as a plain text string;
        otherwise, the original secure string or string value is returned as stored in the context.
        Use this function to extract authentication tokens for subsequent API requests.

        .EXAMPLE
        Get-GitHubAccessToken

        Output:
        ```powershell
        System.Security.SecureString
        ```

        Retrieves the access token from the default context as a secure string.

        .EXAMPLE
        Get-GitHubAccessToken -Context $myGitHubContext -AsPlainText

        Output:
        ```powershell
        ghp_exampletoken1234567890
        ```

        Retrieves the access token from a specified context as a plain text string.

        .OUTPUTS
        System.Security.SecureString

        .OUTPUTS
        System.String

        .LINK
        https://psmodule.io/GitHub/Functions/Get-GitHubAccessToken/
    #>
    [OutputType([System.Security.SecureString], ParameterSetName = 'Get access token as SecureString')]
    [OutputType([System.String], ParameterSetName = 'Get access token as plain text')]
    [CmdletBinding(DefaultParameterSetName = 'Get access token as SecureString')]
    param(
        # If specified, the token will be returned as plain text.
        [Parameter(Mandatory, ParameterSetName = 'Get access token as plain text')]
        [switch] $AsPlainText,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
    }

    process {
        if ($AsPlainText) {
            return $Context.Token | ConvertFrom-SecureString -AsPlainText
        }

        return $Context.Token
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Get-GitHubAccessToken] - Done"
#endregion [functions] - [public] - [Auth] - [Get-GitHubAccessToken]
#region    [functions] - [public] - [Auth] - [Get-GitHubViewer]
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Get-GitHubViewer] - Importing"
function Get-GitHubViewer {
    <#
        .SYNOPSIS
        Gets the currently authenticated user.

        .DESCRIPTION
        Gets the currently authenticated user.

        .EXAMPLE
        Get-GithubViewer

        Gets the currently authenticated user.

        .NOTES
        [GraphQL API - Queries - Viewer](https://docs.github.com/graphql/reference/queries#viewer)

        .LINK
        https://psmodule.io/GitHub/Functions/Auth/Get-GitHubViewer
    #>
    [CmdletBinding()]
    param(
        # The fields to return.
        [Parameter()]
        [string[]] $Fields = @('name', 'login', 'id', 'databaseId'),

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
    }

    process {
        $query = @"
query {
  viewer {
    $($Fields -join "`n")
  }
}
"@
        $data = Invoke-GitHubGraphQLQuery -Query $query -Context $Context

        $data.viewer
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Get-GitHubViewer] - Done"
#endregion [functions] - [public] - [Auth] - [Get-GitHubViewer]
#region    [functions] - [public] - [Auth] - [Revoke-GitHubAccessToken]
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Revoke-GitHubAccessToken] - Importing"
function Revoke-GitHubAccessToken {
    <#
        .SYNOPSIS
        Revoke a list of tokens.

        .DESCRIPTION
        Submit a list of credentials to be revoked. This endpoint is intended to revoke credentials the caller does not own and may have found
        exposed on GitHub.com or elsewhere. It can also be used for credentials associated with an old user account that you no longer have access to.
        Credential owners will be notified of the revocation.

        .LINK
        https://psmodule.io/GitHub/Functions/Auth/Revoke-GitHubAccessToken/

        .NOTES
        [Revoke a list of credentials](https://docs.github.com/rest/credentials/revoke#revoke-a-list-of-credentials)
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # An array of tokens to revoke.
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [string[]] $Token
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $tokenList = [System.Collections.ArrayList]::new()
    }

    process {
        $Token | ForEach-Object {
            $tokenList.Add($_)
        }
    }

    end {
        for ($i = 0; $i -lt $tokenList.Count; $i += 1000) {
            $batch = $tokenList[$i..([Math]::Min($i + 999, $tokenList.Count - 1))]
            $body = @{ credentials = $batch }
            $InputObject = @{
                Method      = 'POST'
                APIEndpoint = '/credentials/revoke'
                Body        = $body
                Anonymous   = $true
            }
            if ($PSCmdlet.ShouldProcess('Tokens', 'Revoke')) {
                $null = Invoke-GitHubAPI @InputObject
            }
        }
        Write-Debug "[$stackPath] - End"
    }
}
#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Revoke-GitHubAccessToken] - Done"
#endregion [functions] - [public] - [Auth] - [Revoke-GitHubAccessToken]
#region    [functions] - [public] - [Auth] - [Context]
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Context] - Processing folder"
#region    [functions] - [public] - [Auth] - [Context] - [Get-GitHubContext]
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Context] - [Get-GitHubContext] - Importing"
function Get-GitHubContext {
    <#
        .SYNOPSIS
        Get the current GitHub context.

        .DESCRIPTION
        Get the current GitHub context.

        .EXAMPLE
        Get-GitHubContext

        Gets the current GitHub context.

        .LINK
        https://psmodule.io/GitHub/Functions/Auth/Context/Get-GitHubContext
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingConvertToSecureStringWithPlainText', '',
        Justification = 'Encapsulated in a function. Never leaves as a plain text.'
    )]
    [OutputType([GitHubContext])]
    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]
    param(
        # The name of the context.
        [Parameter(
            Mandatory,
            ParameterSetName = 'NamedContext'
        )]
        [Alias('Name')]
        [string] $Context,

        # List all available contexts.
        [Parameter(
            Mandatory,
            ParameterSetName = 'ListAvailableContexts'
        )]
        [switch] $ListAvailable
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $null = Get-GitHubConfig
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'NamedContext' {
                Write-Debug "NamedContext: [$Context]"
                $ID = $Context
            }
            'ListAvailableContexts' {
                Write-Debug "ListAvailable: [$ListAvailable]"
                $ID = '*'
            }
            default {
                Write-Debug 'Getting default context.'
                $ID = $script:GitHub.Config.DefaultContext
                if ([string]::IsNullOrEmpty($ID)) {
                    $msg = "No default GitHub context found. Please run 'Switch-GitHubContext' or 'Connect-GitHub' to configure a GitHub context."
                    Write-Warning $msg
                    return
                }
            }
        }
        Write-Verbose "Getting the context: [$ID]"

        Get-Context -ID $ID -Vault $script:GitHub.ContextVault | Where-Object { $_.ID -ne $script:GitHub.DefaultConfig.ID } | ForEach-Object {
            $contextObj = $_
            Write-Verbose 'Context:'
            $contextObj | Select-Object * | Out-String -Stream | ForEach-Object { Write-Verbose $_ }

            Write-Verbose "Converting to: [GitHub$($contextObj.Type)Context]"
            switch ($contextObj.Type) {
                'User' {
                    [GitHubUserContext]::new([pscustomobject]$contextObj)
                }
                'App' {
                    [GitHubAppContext]::new([pscustomobject]$contextObj)
                }
                'Installation' {
                    [GitHubAppInstallationContext]::new([pscustomobject]$contextObj)
                }
                default {
                    throw "Unknown context type: [$($contextObj.Type)]"
                }
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
#Requires -Modules @{ ModuleName = 'Context'; RequiredVersion = '8.1.0' }
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Context] - [Get-GitHubContext] - Done"
#endregion [functions] - [public] - [Auth] - [Context] - [Get-GitHubContext]
#region    [functions] - [public] - [Auth] - [Context] - [Switch-GitHubContext]
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Context] - [Switch-GitHubContext] - Importing"
function Switch-GitHubContext {
    <#
        .SYNOPSIS
        Set the default context.

        .DESCRIPTION
        Set the default context for the GitHub module.

        .EXAMPLE
        Switch-GitHubContext -Context 'github.com/Octocat'

        .LINK
        https://psmodule.io/GitHub/Functions/Auth/Context/Switch-GitHubContext
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter(ValueFromPipeline)]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        Write-Debug "Setting default context to [$Context]"
        $Context = Resolve-GitHubContext -Context $Context
        if ($PSCmdlet.ShouldProcess("$Context", 'Set default context')) {
            Set-GitHubConfig -Name 'DefaultContext' -Value $Context.Name
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Context] - [Switch-GitHubContext] - Done"
#endregion [functions] - [public] - [Auth] - [Context] - [Switch-GitHubContext]
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - [Context] - Done"
#endregion [functions] - [public] - [Auth] - [Context]
Write-Debug "[$scriptName] - [functions] - [public] - [Auth] - Done"
#endregion [functions] - [public] - [Auth]
#region    [functions] - [public] - [Commands]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - Processing folder"
#region    [functions] - [public] - [Commands] - [Add-GitHubMask]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Add-GitHubMask] - Importing"
filter Add-GitHubMask {
    <#
        .SYNOPSIS
        Masks a value in a log

        .DESCRIPTION
        Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is
        replaced with the * character. You can use an environment variable or string for the mask's value. When you mask a value,
        it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to
        set that value as an output.

        .EXAMPLE
        Add-Mask $SecretValue

        Masks the value of $SecretValue so that its printed like ***.

        .EXAMPLE
        $SecretValue1, $SecretValue2 | Mask

        Masks the value of $SecretValue1 and $SecretValue2 so that its printed like ***, using the pipeline

        .NOTES
        [Masking a value in a log](https://docs.github.com/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions#masking-a-value-in-a-log)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Add-GitHubMask
    #>
    [Alias('Mask', 'Add-Mask')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '', Scope = 'Function',
        Justification = 'Long documentation URL'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseShouldProcessForStateChangingFunctions', '', Scope = 'Function',
        Justification = 'Does not change state'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '', Scope = 'Function',
        Justification = 'Intended for logging in Github Runners which does support Write-Host'
    )]
    [CmdletBinding()]
    param(
        # The value to mask
        [Parameter(
            Mandatory,
            ValueFromPipeline
        )]
        [AllowNull()]
        [string[]] $Value
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        foreach ($item in $Value) {
            Write-Host "::add-mask::$item"
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Add-GitHubMask] - Done"
#endregion [functions] - [public] - [Commands] - [Add-GitHubMask]
#region    [functions] - [public] - [Commands] - [Add-GitHubSystemPath]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Add-GitHubSystemPath] - Importing"
function Add-GitHubSystemPath {
    <#
        .SYNOPSIS
        Adds a system path to the GitHub Actions environment

        .DESCRIPTION
        Prepends a directory to the system PATH variable and automatically makes it available to all subsequent actions in the current job;
        the currently running action cannot access the updated path variable. To see the currently defined paths for your job, you can use
        echo "$env:PATH" in a step or an action.

        .EXAMPLE
        Add-GitHubSystemPath -Path '$HOME/.local/bin'

        .NOTES
        [Adding a system path](https://docs.github.com/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions#adding-a-system-path)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Add-GitHubSystemPath
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '', Scope = 'Function',
        Justification = 'Long documentation URL'
    )]
    [OutputType([void])]
    [CmdletBinding()]
    param(
        # The system path to add.
        [Parameter(Mandatory, Position = 0)]
        [string]$Path
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        Write-Verbose "Current PATH: $env:PATH"
        Write-Verbose "Adding system path: $Path"

        $Path | Out-File -FilePath $env:GITHUB_PATH -Append
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Add-GitHubSystemPath] - Done"
#endregion [functions] - [public] - [Commands] - [Add-GitHubSystemPath]
#region    [functions] - [public] - [Commands] - [Disable-GitHubCommand]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Disable-GitHubCommand] - Importing"
function Disable-GitHubCommand {
    <#
        .SYNOPSIS
        Stops workflow commands

        .DESCRIPTION
        Stops processing any workflow commands. This special command allows you to log anything without accidentally running a workflow command.
        For example, you could stop logging to output an entire script that has comments.

        To stop the processing of workflow commands, pass a unique string to the function. To resume processing workflow commands, pass the same string
        that you used to stop workflow commands to the Enable-GitHubCommand.

        .EXAMPLE
        Disable-GitHubCommand "123"

        Stops processing any workflow commands.

        .NOTES
        [Stopping and starting workflow commands](https://docs.github.com/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions#stopping-and-starting-workflow-commands)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Disable-GitHubCommand
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '', Scope = 'Function',
        Justification = 'Long doc links'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '', Scope = 'Function',
        Justification = 'Intended for logging in Github Runners which does support Write-Host'
    )]
    [OutputType([void])]
    [CmdletBinding()]
    param(
        # The unique string to stop the processing of workflow commands
        [Parameter(Mandatory)]
        [string] $String
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $String = $String.ToLower()

        if ($env:GITHUB_ACTIONS -eq 'true') {
            Write-Host "::stop-commands::$String"
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Disable-GitHubCommand] - Done"
#endregion [functions] - [public] - [Commands] - [Disable-GitHubCommand]
#region    [functions] - [public] - [Commands] - [Enable-GitHubCommand]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Enable-GitHubCommand] - Importing"
function Enable-GitHubCommand {
    <#
        .SYNOPSIS
        Resumes workflow commands

        .DESCRIPTION
        Resumes processing any workflow commands.

        To stop the processing of workflow commands, pass a unique string to the function. To resume processing workflow commands, pass the same string
        that you used to stop workflow commands to the Enable-GitHubCommand.

        .EXAMPLE
        Enable-GitHubCommand "123"

        Resumes processing any workflow commands.

        .NOTES
        [Stopping and starting workflow commands](https://docs.github.com/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions#stopping-and-starting-workflow-commands)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Enable-GitHubCommand
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '', Scope = 'Function',
        Justification = 'Long doc links'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '', Scope = 'Function',
        Justification = 'Intended for logging in Github Runners which does support Write-Host'
    )]
    [OutputType([void])]
    [CmdletBinding()]
    param(
        # The unique string to resume the processing of workflow commands
        [Parameter(Mandatory)]
        [string] $String
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $String = $String.ToLower()

        if ($env:GITHUB_ACTIONS -eq 'true') {
            Write-Host "::$String::"
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Enable-GitHubCommand] - Done"
#endregion [functions] - [public] - [Commands] - [Enable-GitHubCommand]
#region    [functions] - [public] - [Commands] - [Get-GitHubOutput]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Get-GitHubOutput] - Importing"
function Get-GitHubOutput {
    <#
        .SYNOPSIS
        Gets the GitHub output.

        .DESCRIPTION
        Gets the GitHub output from $env:GITHUB_OUTPUT and creates an object with key-value pairs, supporting both single-line and multi-line values

        .EXAMPLE
        Get-GitHubOutput
        MY_VALUE         result                       zen
        --------         ------                       ---
        qwe…             @{"MyOutput":"Hello, World!"} something else

        Gets the GitHub output and returns an object with key-value pairs.

        .EXAMPLE
        Get-GitHubOutput -AsHashtable

        Name                           Value
        ----                           -----
        MyArray                        1 2 3
        MyOutput                       Hello, World!
        zen                            something else
        result                         {[thisisatest, a simple value]}
        mystuff                        {[MyOutput, Hello, World!]}
        MY_VALUE                       qwe…

        Gets the GitHub output and returns a hashtable.

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Get-GitHubOutput
    #>
    [OutputType([hashtable])]
    [CmdletBinding()]
    param(
        # Returns the output as a hashtable.
        [Parameter()]
        [switch] $AsHashtable,

        # The path to the GitHub output file.
        [Parameter()]
        [string] $Path = $env:GITHUB_OUTPUT
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if (-not $Path) {
            throw 'The path to the GitHub output file is not set. Please set the path to the GitHub output file using the -Path parameter.'
        }
        Write-Debug "[$stackPath] - Output path"
        Write-Debug $Path
        if (-not (Test-Path -Path $Path)) {
            throw "File not found: $Path"
        }

        $outputContent = Get-Content -Path $Path -Raw
        ConvertFrom-GitHubOutput -OutputContent $outputContent -AsHashtable:$AsHashtable

    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Get-GitHubOutput] - Done"
#endregion [functions] - [public] - [Commands] - [Get-GitHubOutput]
#region    [functions] - [public] - [Commands] - [Reset-GitHubOutput]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Reset-GitHubOutput] - Importing"
function Reset-GitHubOutput {
    <#
        .SYNOPSIS
        Resets the GitHub output.

        .DESCRIPTION
        Resets the GitHub output by clearing the contents of $env:GITHUB_OUTPUT.

        .EXAMPLE
        Reset-GitHubOutput

        Resets the content in the GitHub output file.

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Reset-GitHubOutput
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The path to the GitHub output file.
        [Parameter()]
        [string] $Path = $env:GITHUB_OUTPUT
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if (-not $Path) {
            throw 'The path to the GitHub output file is not set. Please set the path to the GitHub output file using the -Path parameter.'
        }
        Write-Debug "[$stackPath] - Output path"
        Write-Debug $Path
        if (-not (Test-Path -Path $Path)) {
            throw "File not found: $Path"
        }

        if ($PSCmdlet.ShouldProcess('GitHub Output' , 'Reset')) {
            '' | Set-Content -Path $Path -Force
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Reset-GitHubOutput] - Done"
#endregion [functions] - [public] - [Commands] - [Reset-GitHubOutput]
#region    [functions] - [public] - [Commands] - [Set-GitHubEnvironmentVariable]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Set-GitHubEnvironmentVariable] - Importing"
function Set-GitHubEnvironmentVariable {
    <#
        .SYNOPSIS
        Setting an environment variable

        .DESCRIPTION
        Set a GitHub environment variable

        .EXAMPLE
        Set-GitHubEnv -Name 'MyVariable' -Value 'MyValue'

        .NOTES
        [Setting an environment variable](https://docs.github.com/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions#setting-an-environment-variable)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Set-GitHubEnvironmentVariable
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '', Scope = 'Function',
        Justification = 'Long doc links'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseShouldProcessForStateChangingFunctions', '', Scope = 'Function',
        Justification = 'Does not change system state significantly'
    )]
    [OutputType([void])]
    [CmdletBinding()]
    param(
        # Name of the variable
        [Parameter(Mandatory)]
        [string] $Name,

        # Value of the variable to set. Can be null.
        [Parameter()]
        [AllowNull()]
        [string] $Value
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        Write-Verbose "Env: [$Name] = [$Value]"

        $guid = [guid]::NewGuid().Guid
        $content = @"
$Name<<$guid
$Value
$guid
"@
        $content | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Set-GitHubEnvironmentVariable] - Done"
#endregion [functions] - [public] - [Commands] - [Set-GitHubEnvironmentVariable]
#region    [functions] - [public] - [Commands] - [Set-GitHubLogGroup]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Set-GitHubLogGroup] - Importing"
function Set-GitHubLogGroup {
    <#
        .SYNOPSIS
        Encapsulates commands with a log group in GitHub Actions

        .DESCRIPTION
        DSL approach for GitHub Action commands.
        Allows for colapsing of code in IDE for code that belong together.

        .EXAMPLE
        Set-GitHubLogGroup -Name 'MyGroup' -ScriptBlock {
            Write-Host 'Hello, World!'
        }

        Creates a new log group named 'MyGroup' and writes 'Hello, World!' to the output.

        .EXAMPLE
        LogGroup 'MyGroup' {
            Write-Host 'Hello, World!'
        }

        Uses the alias 'LogGroup' to create a new log group named 'MyGroup' and writes 'Hello, World!' to the output.

        .NOTES
        [GitHub - Grouping log lines](https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#grouping-log-lines)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Set-GitHubLogGroup
    #>
    [Alias('LogGroup')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseShouldProcessForStateChangingFunctions', '', Scope = 'Function',
        Justification = 'Does not change state'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '', Scope = 'Function',
        Justification = 'Intended for logging in Github Runners which does support Write-Host'
    )]
    [CmdletBinding()]
    param(
        # The name of the log group
        [Parameter(Mandatory)]
        [string] $Name,

        # The script block to execute
        [Parameter(Mandatory)]
        [scriptblock] $ScriptBlock
    )

    Write-Host "::group::$Name"
    . $ScriptBlock
    Write-Host '::endgroup::'
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Set-GitHubLogGroup] - Done"
#endregion [functions] - [public] - [Commands] - [Set-GitHubLogGroup]
#region    [functions] - [public] - [Commands] - [Set-GitHubNoCommandGroup]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Set-GitHubNoCommandGroup] - Importing"
function Set-GitHubNoCommandGroup {
    <#
        .SYNOPSIS
        Disables workflow commands for a block of code.

        .DESCRIPTION
        DSL approach for GitHub Action commands.
        Allows for colapsing of code in IDE for code that belong together.

        .EXAMPLE
        Set-GitHubNoCommandGroup {
            Write-Host 'Hello, World!'
            Write-GithubError 'This is an error'
        }

        Groups commands where no workflow commands are run.

        .EXAMPLE
        NoLogGroup 'MyGroup' {
            Write-Host 'Hello, World!'
            Write-GithubError 'This is an error'
        }

        Groups commands where no workflow commands are run, using an alias and DSL approach.

        .NOTES
        [Stopping and starting workflow commands](https://docs.github.com/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions#stopping-and-starting-workflow-commands)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Set-GitHubNoCommandGroup
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '', Scope = 'Function',
        Justification = 'Long doc links'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseShouldProcessForStateChangingFunctions', '', Scope = 'Function',
        Justification = 'Does not change state'
    )]
    [CmdletBinding()]
    [Alias('NoLogGroup')]
    param(
        # The script block to execute
        [Parameter(Mandatory)]
        [scriptblock] $ScriptBlock
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $guid = [string][guid]::NewGuid().Guid

        Disable-GitHubCommand -String $guid
        . $ScriptBlock
        Enable-GitHubCommand -String $guid
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Set-GitHubNoCommandGroup] - Done"
#endregion [functions] - [public] - [Commands] - [Set-GitHubNoCommandGroup]
#region    [functions] - [public] - [Commands] - [Set-GitHubOutput]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Set-GitHubOutput] - Importing"
function Set-GitHubOutput {
    <#
        .SYNOPSIS
        Sets the GitHub output for a given key and value.

        .DESCRIPTION
        This function appends key-value pairs to the GitHub Actions output file specified by $env:GITHUB_OUTPUT.
        It handles two scenarios:
        - Normal shell execution: Appends the key-value pair directly.
        - GitHub composite action via [GitHub-Script](https://github.com/PSModule/GitHub-Script):
            Accumulates key-value pairs under the 'result' key as a JSON object.

        The Value parameter accepts null values, which will be correctly preserved and set as the output.

        .EXAMPLE
        Set-GitHubOutput -Name 'ID' -Value '123123123'

        Sets the output variable 'ID' to '123123123' in the GitHub Actions output file.

        .EXAMPLE
        Set-GitHubOutput -Name 'result' -Value @{
            ID   = '123123123'
            name = 'test'
        }

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Set-GitHubOutput
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The name of the output variable to set.
        [Parameter(Mandatory)]
        [string] $Name,

        # The value of the output variable to set. Can be null.
        [Parameter()]
        [AllowNull()]
        [object] $Value,

        # The path to the GitHub output file.
        [Parameter()]
        [string] $Path = $env:GITHUB_OUTPUT
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if (-not (Test-Path -Path $Path)) {
            throw "File not found: $Path"
        }

        $outputs = Get-GitHubOutput -Path $Path -AsHashtable

        if ([string]::IsNullOrEmpty($env:GITHUB_ACTION)) {
            Write-Warning 'Cannot create output as the step has no ID.'
        }

        if ($null -eq $value) {
            Write-Debug "Property value type: null"
        } elseif ($value.GetType().Name -eq 'SecureString') {
            $Value = $Value | ConvertFrom-SecureString -AsPlainText
            Add-GitHubMask -Value $Value
        }

        Write-Verbose "Output: [$Name] = [$Value]"

        # If the script is running in a GitHub composite action, accumulate the output under the 'result' key,
        # else append the key-value pair directly.
        if ($env:PSMODULE_GITHUB_SCRIPT) {
            if ($Value -isnot [string]) {
                $Value = $Value | ConvertTo-Json -Depth 100
            }
            Write-Debug "[$stackPath] - Running in GitHub-Script composite action"
            if (-not $outputs.ContainsKey('result')) {
                $outputs['result'] = @{}
            }
            $outputs['result'][$Name] = $Value
        } else {
            Write-Debug "[$stackPath] - Running in a custom action"
            $outputs[$Name] = $Value
        }

        if ($PSCmdlet.ShouldProcess('GitHub Output', 'Set')) {
            $outputs | ConvertTo-GitHubOutput | Set-Content -Path $Path
        }

    }

    end {
        if ($env:PSMODULE_GITHUB_SCRIPT) {
            Write-Verbose "Output: [$Name] available as '`${{ fromJson(steps.$env:GITHUB_ACTION.outputs.result).$Name }}'"
        } else {
            Write-Verbose "Output: [$Name] available as '`${{ steps.$env:GITHUB_ACTION.outputs.$Name }}'"
        }
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Set-GitHubOutput] - Done"
#endregion [functions] - [public] - [Commands] - [Set-GitHubOutput]
#region    [functions] - [public] - [Commands] - [Set-GitHubStepSummary]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Set-GitHubStepSummary] - Importing"
function Set-GitHubStepSummary {
    <#
        .SYNOPSIS
        Set a summary for the step in GitHub Actions

        .DESCRIPTION
        You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run.
        You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing
        the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures.

        Job summaries support GitHub flavored Markdown, and you can add your Markdown content for a step to the `GITHUB_STEP_SUMMARY`
        environment file. `GITHUB_STEP_SUMMARY` is unique for each step in a job. For more information about the per-step file that
        `GITHUB_STEP_SUMMARY` references, see [Environment files](https://docs.github.com/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?utm_source=chatgpt.com#environment-files).

        When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the
        workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time.

        .EXAMPLE
        Set-GitHubStepSummary -Summary 'Hello, World!'

        .NOTES
        [Adding a job summary](https://docs.github.com/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?utm_source=chatgpt.com#adding-a-job-summary)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Set-GitHubStepSummary
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '', Scope = 'Function',
        Justification = 'Long doc links'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseShouldProcessForStateChangingFunctions', '', Scope = 'Function',
        Justification = 'Does not change system state significantly'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '', Scope = 'Function',
        Justification = 'Intended for logging in Github Runners which does support Write-Host'
    )]
    [OutputType([void])]
    [Alias('Summary')]
    [CmdletBinding()]
    param(
        # Summary of the step
        [Parameter(
            Mandatory,
            ValueFromPipeline
        )]
        [AllowNull()]
        [string] $Summary,

        # Whether to overwrite the existing summary
        [switch] $Overwrite
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        Write-Verbose 'Step summary:'
        Write-Verbose $Summary

        $Append = -not $Overwrite
        if ($env:GITHUB_ACTIONS -eq 'true') {
            $Summary | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append:$Append
            return
        }
        Write-Host "$Summary"
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Set-GitHubStepSummary] - Done"
#endregion [functions] - [public] - [Commands] - [Set-GitHubStepSummary]
#region    [functions] - [public] - [Commands] - [Start-GitHubLogGroup]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Start-GitHubLogGroup] - Importing"
function Start-GitHubLogGroup {
    <#
        .SYNOPSIS
        Starts a log group in GitHub Actions

        .EXAMPLE
        New-LogGroup 'MyGroup'

        Starts a new log group named 'MyGroup'

        .NOTES
        [GitHub - Grouping log lines](https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#grouping-log-lines)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Start-GitHubLogGroup
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseShouldProcessForStateChangingFunctions', '', Scope = 'Function',
        Justification = 'Does not change state'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '', Scope = 'Function',
        Justification = 'Intended for logging in Github Runners which does support Write-Host'
    )]
    [CmdletBinding()]
    [Alias('Start-LogGroup')]
    param(
        # The name of the log group
        [Parameter(Mandatory)]
        [string] $Name
    )

    if ($env:GITHUB_ACTIONS -eq 'true') {
        Write-Host "::group::$Name"
    }

}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Start-GitHubLogGroup] - Done"
#endregion [functions] - [public] - [Commands] - [Start-GitHubLogGroup]
#region    [functions] - [public] - [Commands] - [Stop-GitHubLogGroup]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Stop-GitHubLogGroup] - Importing"
function Stop-GitHubLogGroup {
    <#
        .SYNOPSIS
        Stops the current log group in GitHub Actions

        .EXAMPLE
        Stop-LogGroup

        Starts a new log group named 'MyGroup'

        .NOTES
        [GitHub - Grouping log lines](https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#grouping-log-lines)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Stop-GitHubLogGroup
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseShouldProcessForStateChangingFunctions', '', Scope = 'Function',
        Justification = 'Does not change state'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '', Scope = 'Function',
        Justification = 'Intended for logging in Github Runners'
    )]
    [CmdletBinding()]
    [Alias('Stop-LogGroup')]
    param()

    if ($env:GITHUB_ACTIONS -eq 'true') {
        Write-Host '::endgroup::'
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Stop-GitHubLogGroup] - Done"
#endregion [functions] - [public] - [Commands] - [Stop-GitHubLogGroup]
#region    [functions] - [public] - [Commands] - [Write-GitHubDebug]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Write-GitHubDebug] - Importing"
function Write-GitHubDebug {
    <#
        .SYNOPSIS
        Write a debug message in GitHub Actions

        .DESCRIPTION
        Write a debug message in GitHub Actions. The message will only be displayed if the action is running in debug mode.
        To run in debug mode, you must create a secret or variable named ACTIONS_STEP_DEBUG with the value `true` to see the debug messages set by
        this command in the log. For more information, see [Enabling debug logging](https://docs.github.com/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/enabling-debug-logging).

        If both the secret and variable are set, the value of the secret takes precedence over the variable.

        .EXAMPLE
        Write-GitHubDebug -Message 'Hello, World!'

        Writes a debug message 'Hello, World!'.

        .NOTES
        [Enabling debug logging](https://docs.github.com/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions#setting-a-debug-message)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Write-GitHubDebug
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '', Scope = 'Function',
        Justification = 'Long doc links'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '', Scope = 'Function',
        Justification = 'Intended for logging in Github Runners'
    )]
    [OutputType([void])]
    [Alias('Debug')]
    [CmdletBinding()]
    param(
        # Message to write
        [Parameter(Mandatory)]
        [string] $Message
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if ($env:GITHUB_ACTIONS -eq 'true') {
            Write-Host "::debug::$Message"
            return
        }
        Write-Debug "$Message"
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Write-GitHubDebug] - Done"
#endregion [functions] - [public] - [Commands] - [Write-GitHubDebug]
#region    [functions] - [public] - [Commands] - [Write-GitHubError]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Write-GitHubError] - Importing"
function Write-GitHubError {
    <#
        .SYNOPSIS
        Write a error message in GitHub Actions

        .DESCRIPTION
        Write a error message in GitHub Actions. The message will be displayed in the GitHub Actions log.

        .EXAMPLE
        Write-GitHubError -Message 'Hello, World!'

        Writes a error message 'Hello, World!'.

        .NOTES
        [Enabling debug logging](https://docs.github.com/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions#setting-an-error-message)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Write-GitHubError
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '', Scope = 'Function',
        Justification = 'Long doc links'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '', Scope = 'Function',
        Justification = 'Intended for logging in Github Runners'
    )]
    [OutputType([void])]
    [Alias('Error')]
    [CmdletBinding()]
    param(
        # Message to write
        [Parameter(Mandatory)]
        [string] $Message,

        # The name of the file that this error is related to
        [Parameter()]
        [string] $Name,

        # The line number that this error is related to
        [Parameter()]
        [int] $Line,

        # The column number that this error is related to
        [Parameter()]
        [int] $Column,

        # The end column number that this error is related to
        [Parameter()]
        [int] $EndColumn,

        # The end line number that this error is related to
        [Parameter()]
        [int] $EndLine,

        # The title of the error
        [Parameter()]
        [string] $Title
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if ($env:GITHUB_ACTIONS -eq 'true') {
            Write-Host "::error file=$Name,line=$Line,col=$Column,endColumn=$EndColumn,endLine=$EndLine,title=$Title::$Message"
            return
        }
        Write-Error $Message
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Write-GitHubError] - Done"
#endregion [functions] - [public] - [Commands] - [Write-GitHubError]
#region    [functions] - [public] - [Commands] - [Write-GitHubLog]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Write-GitHubLog] - Importing"
function Write-GitHubLog {
    <#
        .SYNOPSIS
        Write a colored message in GitHub Actions or locally

        .DESCRIPTION
        Write a colored message in GitHub Actions or locally with ANSI color support.
        When running in GitHub Actions, uses ANSI color codes for text formatting.
        When not running in GitHub Actions, uses standard Write-Host.

        .EXAMPLE
        Write-GitHubLog -Message 'Hello, World!'

        Writes 'Hello, World!' to the log.

        .EXAMPLE
        Write-GitHubLog -Message 'Error occurred!' -ForegroundColor Red

        Writes 'Error occurred!' in red text.

        .EXAMPLE
        Write-GitHubLog -Message 'Success!' -ForegroundColor Green -BackgroundColor Black

        Writes 'Success!' in green text on a black background.

        .NOTES
        Uses PowerShell's $PSStyle for ANSI color rendering when supported.

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Write-GitHubLog
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '', Scope = 'Function',
        Justification = 'Intended for logging in Github Runners'
    )]
    [OutputType([void])]
    [Alias('Log')]
    [CmdletBinding()]
    param(
        # The message to display
        [Parameter(Mandatory, Position = 0, ValueFromPipeline)]
        [string] $Message,

        # Foreground color for the message
        [Parameter()]
        [System.ConsoleColor] $ForegroundColor,

        # Background color for the message
        [Parameter()]
        [System.ConsoleColor] $BackgroundColor
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if ($env:GITHUB_ACTIONS -eq 'true') {
            $ansiString = ''
            if ($ForegroundColor) {
                $ansiString += $PSStyle.Foreground.$ForegroundColor
            }
            if ($BackgroundColor) {
                $ansiString += $PSStyle.Background.$BackgroundColor
            }
            $ansiReset = $PSStyle.Reset
            $outputMessage = "$ansiString$Message$ansiReset"
            Write-Host $($outputMessage | Out-String)
            return
        }
        Write-Host $Message -ForegroundColor $ForegroundColor -BackgroundColor $BackgroundColor
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Write-GitHubLog] - Done"
#endregion [functions] - [public] - [Commands] - [Write-GitHubLog]
#region    [functions] - [public] - [Commands] - [Write-GitHubNotice]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Write-GitHubNotice] - Importing"
function Write-GitHubNotice {
    <#
        .SYNOPSIS
        Write a notice message in GitHub Actions

        .DESCRIPTION
        Write a notice message in GitHub Actions. The message will be displayed in the GitHub Actions log.

        .EXAMPLE
        Write-GitHubNotice -Message 'Hello, World!'

        Writes a notice message 'Hello, World!'.

        .NOTES
        [Enabling debug logging](https://docs.github.com/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/enabling-debug-logging)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Write-GitHubNotice
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '', Scope = 'Function',
        Justification = 'Long doc links'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '', Scope = 'Function',
        Justification = 'Intended for logging in Github Runners'
    )]
    [OutputType([void])]
    [Alias('Notice')]
    [CmdletBinding()]
    param(
        # Message to write
        [Parameter(Mandatory)]
        [string] $Message,

        # The name of the file that this notice is related to
        [Parameter()]
        [string] $Name,

        # The line number that this notice is related to
        [Parameter()]
        [int] $Line,

        # The column number that this notice is related to
        [Parameter()]
        [int] $Column,

        # The end column number that this notice is related to
        [Parameter()]
        [int] $EndColumn,

        # The end line number that this notice is related to
        [Parameter()]
        [int] $EndLine,

        # The title of the notice
        [Parameter()]
        [string] $Title
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if ($env:GITHUB_ACTIONS -eq 'true') {
            Write-Host "::notice file=$Name,line=$Line,col=$Column,endColumn=$EndColumn,endLine=$EndLine,title=$Title::$Message"
            return
        }
        Write-Host $Message
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Write-GitHubNotice] - Done"
#endregion [functions] - [public] - [Commands] - [Write-GitHubNotice]
#region    [functions] - [public] - [Commands] - [Write-GitHubWarning]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Write-GitHubWarning] - Importing"
function Write-GitHubWarning {
    <#
        .SYNOPSIS
        Write a warning message in GitHub Actions

        .DESCRIPTION
        Write a warning message in GitHub Actions. The message will be displayed in the GitHub Actions log.

        .EXAMPLE
        Write-GitHubWarning -Message 'Hello, World!'

        Writes a warning message 'Hello, World!'.

        .NOTES
        [Enabling debug logging](https://docs.github.com/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/enabling-debug-logging)

        .LINK
        https://psmodule.io/GitHub/Functions/Commands/Write-GitHubWarning
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '', Scope = 'Function',
        Justification = 'Long doc links'
    )]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidUsingWriteHost', '', Scope = 'Function',
        Justification = 'Intended for logging in Github Runners'
    )]
    [OutputType([void])]
    [Alias('Warning')]
    [CmdletBinding()]
    param(
        # Message to write
        [Parameter(Mandatory)]
        [string] $Message,

        # The name of the file that this warning is related to
        [Parameter()]
        [string] $Name,

        # The line number that this warning is related to
        [Parameter()]
        [int] $Line,

        # The column number that this warning is related to
        [Parameter()]
        [int] $Column,

        # The end column number that this warning is related to
        [Parameter()]
        [int] $EndColumn,

        # The end line number that this warning is related to
        [Parameter()]
        [int] $EndLine,

        # The title of the warning
        [Parameter()]
        [string] $Title
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if ($env:GITHUB_ACTIONS -eq 'true') {
            Write-Host "::warning file=$Name,line=$Line,col=$Column,endColumn=$EndColumn,endLine=$EndLine,title=$Title::$Message"
            return
        }
        Write-Warning $Message
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - [Write-GitHubWarning] - Done"
#endregion [functions] - [public] - [Commands] - [Write-GitHubWarning]
Write-Debug "[$scriptName] - [functions] - [public] - [Commands] - Done"
#endregion [functions] - [public] - [Commands]
#region    [functions] - [public] - [Config]
Write-Debug "[$scriptName] - [functions] - [public] - [Config] - Processing folder"
#region    [functions] - [public] - [Config] - [completers]
Write-Debug "[$scriptName] - [functions] - [public] - [Config] - [completers] - Importing"
Register-ArgumentCompleter -CommandName Set-GitHubConfig, Get-GitHubConfig, Remove-GitHubConfig -ParameterName Name -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter

    ([GitHubConfig]).GetProperties().Name | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_ )
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Config] - [completers] - Done"
#endregion [functions] - [public] - [Config] - [completers]
#region    [functions] - [public] - [Config] - [Get-GitHubConfig]
Write-Debug "[$scriptName] - [functions] - [public] - [Config] - [Get-GitHubConfig] - Importing"
function Get-GitHubConfig {
    <#
        .SYNOPSIS
        Get a GitHub module configuration.

        .DESCRIPTION
        Get a GitHub module configuration.

        .EXAMPLE
        Get-GitHubConfig -Name DefaultContext

        Get the DefaultContext value from the GitHub module configuration.



        .LINK
        https://psmodule.io/GitHub/Functions/Config/Get-GitHubConfig
    #>
    [OutputType([GitHubConfig], ParameterSetName = 'Get the module configuration')]
    [OutputType([object], ParameterSetName = 'Get a specific configuration item')]
    [CmdletBinding(DefaultParameterSetName = 'Get the module configuration')]
    param(
        # The name of the configuration to get.
        [Parameter(Mandatory, ParameterSetName = 'Get a specific configuration item')]
        [string] $Name
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Initialize-GitHubConfig
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'Get the module configuration' {
                $item = Get-Context -ID $script:GitHub.Config.ID -Vault $script:GitHub.ContextVault | Select-Object -ExcludeProperty ID
                [GitHubConfig]::new($item)
            }
            'Get a specific configuration item' {
                $script:GitHub.Config.$Name
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
#Requires -Modules @{ ModuleName = 'Context'; RequiredVersion = '8.1.0' }
Write-Debug "[$scriptName] - [functions] - [public] - [Config] - [Get-GitHubConfig] - Done"
#endregion [functions] - [public] - [Config] - [Get-GitHubConfig]
#region    [functions] - [public] - [Config] - [Remove-GitHubConfig]
Write-Debug "[$scriptName] - [functions] - [public] - [Config] - [Remove-GitHubConfig] - Importing"
function Remove-GitHubConfig {
    <#
        .SYNOPSIS
        Remove a GitHub module configuration.

        .DESCRIPTION
        Remove a GitHub module configuration.

        .EXAMPLE
        Remove-GitHubConfig -Name DefaultUser

        Removes the 'DefaultUser' item in the GitHub module configuration.

        .LINK
        https://psmodule.io/GitHub/Functions/Config/Remove-GitHubConfig
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # Set the access token type.
        [Parameter()]
        [string] $Name
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Initialize-GitHubConfig
    }

    process {
        try {
            if ($PSCmdlet.ShouldProcess('ContextSetting', 'Remove')) {
                $script:GitHub.Config.$Name = $null
            }
        } catch {
            Write-Error $_
            Write-Error (Get-PSCallStack | Format-Table | Out-String)
            throw 'Failed to connect to GitHub.'
        }
        Set-Context -Context $script:GitHub.Config -Vault $script:GitHub.ContextVault
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
#Requires -Modules @{ ModuleName = 'Context'; RequiredVersion = '8.1.0' }
Write-Debug "[$scriptName] - [functions] - [public] - [Config] - [Remove-GitHubConfig] - Done"
#endregion [functions] - [public] - [Config] - [Remove-GitHubConfig]
#region    [functions] - [public] - [Config] - [Reset-GitHubConfig]
Write-Debug "[$scriptName] - [functions] - [public] - [Config] - [Reset-GitHubConfig] - Importing"
function Reset-GitHubConfig {
    <#
        .SYNOPSIS
        Re-initializes the GitHub module configuration.

        .DESCRIPTION
        Re-initializes the GitHub module configuration.

        .EXAMPLE
        Reset-GitHubConfig

        Re-initializes the GitHub module configuration.

        .LINK
        https://psmodule.io/GitHub/Functions/Config/Reset-GitHubConfig
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param ()

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        if ($PSCmdlet.ShouldProcess('GitHubConfig', 'Reset')) {
            Initialize-GitHubConfig -Force
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Config] - [Reset-GitHubConfig] - Done"
#endregion [functions] - [public] - [Config] - [Reset-GitHubConfig]
#region    [functions] - [public] - [Config] - [Set-GitHubConfig]
Write-Debug "[$scriptName] - [functions] - [public] - [Config] - [Set-GitHubConfig] - Importing"
function Set-GitHubConfig {
    <#
        .SYNOPSIS
        Set a GitHub module configuration.

        .DESCRIPTION
        Set a GitHub module configuration.

        .EXAMPLE
        Set-GitHubConfig -Name DefaultUser -Value 'Octocat'

        Sets the value of DefaultUser to 'Octocat' in the GitHub module configuration.

        .OUTPUTS
        GitHubConfig

        .LINK
        https://psmodule.io/GitHub/Functions/Config/Set-GitHubConfig
    #>
    [OutputType([GitHubConfig])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # Set the access token type.
        [Parameter()]
        [string] $Name,

        # Set the access token type.
        [Parameter()]
        [string] $Value,

        # Pass the context through the pipeline.
        [Parameter()]
        [switch] $PassThru
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        Initialize-GitHubConfig
    }

    process {
        Write-Verbose "Setting [$Name] to [$Value]"
        $script:GitHub.Config.$Name = $Value
        if ($PSCmdlet.ShouldProcess('ContextSetting', 'Set')) {
            $item = Set-Context -Context $script:GitHub.Config -Vault $script:GitHub.ContextVault -PassThru:$PassThru
            if ($PassThru) {
                [GitHubConfig]::new($item)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
#Requires -Modules @{ ModuleName = 'Context'; RequiredVersion = '8.1.0' }
Write-Debug "[$scriptName] - [functions] - [public] - [Config] - [Set-GitHubConfig] - Done"
#endregion [functions] - [public] - [Config] - [Set-GitHubConfig]
Write-Debug "[$scriptName] - [functions] - [public] - [Config] - Done"
#endregion [functions] - [public] - [Config]
#region    [functions] - [public] - [Emojis]
Write-Debug "[$scriptName] - [functions] - [public] - [Emojis] - Processing folder"
#region    [functions] - [public] - [Emojis] - [Get-GitHubEmoji]
Write-Debug "[$scriptName] - [functions] - [public] - [Emojis] - [Get-GitHubEmoji] - Importing"
filter Get-GitHubEmoji {
    <#
        .SYNOPSIS
        Get emojis

        .DESCRIPTION
        Lists all the emojis available to use on GitHub.
        If you pass the `Path` parameter, the emojis will be downloaded to the specified destination.

        .EXAMPLE
        Get-GitHubEmoji

        Gets all the emojis available to use on GitHub.

        .EXAMPLE
        Get-GitHubEmoji -Path 'C:\Users\user\Documents\GitHub\Emojis'

        Downloads all the emojis available to use on GitHub to the specified destination.

        .NOTES
        [Get emojis](https://docs.github.com/rest/reference/emojis#get-emojis)

        .LINK
        https://psmodule.io/GitHub/Functions/Emojis/Get-GitHubEmoji
    #>
    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]
    param(
        # The path to the directory where the emojis will be downloaded.
        [Parameter(
            Mandatory,
            ParameterSetName = 'Download'
        )]
        [string] $Path,

        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter()]
        [switch] $Anonymous,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context -Anonymous $Anonymous
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/emojis'
            Context     = $Context
        }

        $response = Invoke-GitHubAPI @apiParams | Select-Object -ExpandProperty Response

        switch ($PSCmdlet.ParameterSetName) {
            'Download' {
                $failedEmojis = @()
                if (-not (Test-Path -Path $Path)) {
                    $null = New-Item -Path $Path -ItemType Directory -Force
                }
                $failedEmojis = $response.PSObject.Properties | ForEach-Object -ThrottleLimit ([System.Environment]::ProcessorCount) -Parallel {
                    $emoji = $_
                    Write-Verbose "Downloading [$($emoji.Name).png] from [$($emoji.Value)] -> [$using:Path/$($emoji.Name).png]"
                    try {
                        Invoke-WebRequest -Uri $emoji.Value -OutFile "$using:Path/$($emoji.Name).png" -RetryIntervalSec 1 -MaximumRetryCount 5
                    } catch {
                        Write-Warning "Could not download [$($emoji.Name).png] from [$($emoji.Value)] -> [$using:Path/$($emoji.Name).png]"
                    }
                }
                if ($failedEmojis.Count -gt 0) {
                    Write-Warning 'Failed to download the following emojis:'
                    $failedEmojis | Out-String -Stream | ForEach-Object { Write-Warning $_ }
                }
            }
            default {
                $response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Emojis] - [Get-GitHubEmoji] - Done"
#endregion [functions] - [public] - [Emojis] - [Get-GitHubEmoji]
Write-Debug "[$scriptName] - [functions] - [public] - [Emojis] - Done"
#endregion [functions] - [public] - [Emojis]
#region    [functions] - [public] - [Enterprise]
Write-Debug "[$scriptName] - [functions] - [public] - [Enterprise] - Processing folder"
#region    [functions] - [public] - [Enterprise] - [Get-GitHubEnterprise]
Write-Debug "[$scriptName] - [functions] - [public] - [Enterprise] - [Get-GitHubEnterprise] - Importing"
function Get-GitHubEnterprise {
    <#
        .SYNOPSIS
        Retrieves GitHub Enterprise instance details for the authenticated user.

        .DESCRIPTION
        Retrieves detailed information about GitHub Enterprise instances available to the authenticated user.
        By default, the command lists all accessible instances, including metadata such as the enterprise name, slug, URL, and creation date. If a
        specific enterprise name is provided, details about that single instance are returned.

        .EXAMPLE
        Get-GitHubEnterprise

        Output:
        ```powershell
        Name              : My Enterprise
        Slug              : my-enterprise
        URL               : https://github.com/enterprises/my-enterprise
        CreatedAt         : 2022-01-01T00:00:00Z

        Name              : Another Enterprise
        Slug              : another-enterprise
        URL               : https://github.com/enterprises/another-enterprise
        CreatedAt         : 2022-01-01T00:00:00Z
        ```

        Retrieves details about all GitHub Enterprise instances for the user.

        .EXAMPLE
        Get-GitHubEnterprise -Name 'my-enterprise'

        Output:
        ```powershell
        Name              : My Enterprise
        Slug              : my-enterprise
        URL               : https://github.com/enterprises/my-enterprise
        CreatedAt         : 2022-01-01T00:00:00Z
        ```

        Retrieves details about the GitHub Enterprise instance named 'my-enterprise'.

        .OUTPUTS
        GitHubEnterprise

        .NOTES
        An object containing detailed information about the GitHub Enterprise instance, including billing info, URLs, and metadata.

        .LINK
        https://psmodule.io/GitHub/Functions/Enterprise/Get-GitHubEnterprise/
    #>
    [OutputType([GitHubEnterprise])]
    [CmdletBinding(DefaultParameterSetName = 'List enterprises for the authenticated user')]
    param(
        # The name (slug) of the GitHub Enterprise instance to retrieve.
        [Parameter(Mandatory, ParameterSetName = 'Get enterprise by name')]
        [Alias('Slug')]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        Write-Debug "ParameterSet: $($PSCmdlet.ParameterSetName)"
        switch ($PSCmdlet.ParameterSetName) {
            'Get enterprise by name' {
                Get-GitHubEnterpriseByName -Name $Name -Context $Context
                break
            }
            default {
                Get-GitHubEnterpriseList -Context $Context
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Enterprise] - [Get-GitHubEnterprise] - Done"
#endregion [functions] - [public] - [Enterprise] - [Get-GitHubEnterprise]
#region    [functions] - [public] - [Enterprise] - [Get-GitHubEnterpriseOrganization]
Write-Debug "[$scriptName] - [functions] - [public] - [Enterprise] - [Get-GitHubEnterpriseOrganization] - Importing"
function Get-GitHubEnterpriseOrganization {
    <#
        .SYNOPSIS
        Get the list of organizations in a GitHub Enterprise instance.

        .DESCRIPTION
        Use this function to retrieve the list of organizations in a GitHub Enterprise instance.

        .EXAMPLE
        Get-GitHubEnterpriseOrganization -Enterprise 'msx'

        .LINK
        https://psmodule.io/GitHub/Functions/Enterprise/Get-GitHubEnterpriseOrganization
    #>
    [CmdletBinding()]
    param(
        [Parameter()]
        [string] $Enterprise,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
        if ([string]::IsNullOrEmpty($Enterprise)) {
            $Enterprise = $Context.Enterprise
        }
        Write-Debug "Enterprise: [$Enterprise]"
    }

    process {
        $query = @"
query(`$enterpriseSlug: String!, `$first: Int = 100, `$after: String) {
  enterprise(slug: `$enterpriseSlug) {
    organizations(first: `$first, after: `$after) {
      edges {
        node {
          name
          login
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
}
"@

        # Initialize pagination variables
        $variables = @{
            'enterpriseSlug' = $Enterprise
            'first'          = 100
            'after'          = $null
        }
        $allOrgs = @()

        # Loop through pages to retrieve all organizations
        do {
            $data = Invoke-GitHubGraphQLQuery -Query $query -Variables $variables -Context $Context

            # Extract organization names and add to the list
            foreach ($org in $data.enterprise.organizations.edges) {
                $allOrgs += $org.node.name
            }

            # Update pagination cursor
            $pageInfo = $data.enterprise.organizations.pageInfo
            $variables.after = $pageInfo.endCursor

        } while ($pageInfo.hasNextPage -eq $true)

        # Output the list of organization names
        $allOrgs | ForEach-Object { Write-Output $_ }

    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Enterprise] - [Get-GitHubEnterpriseOrganization] - Done"
#endregion [functions] - [public] - [Enterprise] - [Get-GitHubEnterpriseOrganization]
Write-Debug "[$scriptName] - [functions] - [public] - [Enterprise] - Done"
#endregion [functions] - [public] - [Enterprise]
#region    [functions] - [public] - [Environments]
Write-Debug "[$scriptName] - [functions] - [public] - [Environments] - Processing folder"
#region    [functions] - [public] - [Environments] - [completers]
Write-Debug "[$scriptName] - [functions] - [public] - [Environments] - [completers] - Importing"
# Complete the Name parameter for all *GitHubEnvironment commands
Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport |
        Where-Object { $_ -like '*GitHubEnvironment' }) -ParameterName Name -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter

    $params = @{
        Owner      = $fakeBoundParameter.Owner
        Repository = $fakeBoundParameter.Repository
        Context    = $fakeBoundParameter.Context
    }
    $params | Remove-HashtableEntry -NullOrEmptyValues
    Get-GitHubEnvironment @params | Where-Object { $_.Name -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Name)
    }
}

# Complete the Environment parameter for all functions in the module
Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport) -ParameterName Environment -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter

    $params = @{
        Owner      = $fakeBoundParameter.Owner
        Repository = $fakeBoundParameter.Repository
        Context    = $fakeBoundParameter.Context
    }
    $params | Remove-HashtableEntry -NullOrEmptyValues
    Get-GitHubEnvironment @params | Where-Object { $_.Name -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Name)
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Environments] - [completers] - Done"
#endregion [functions] - [public] - [Environments] - [completers]
#region    [functions] - [public] - [Environments] - [Get-GitHubEnvironment]
Write-Debug "[$scriptName] - [functions] - [public] - [Environments] - [Get-GitHubEnvironment] - Importing"
filter Get-GitHubEnvironment {
    <#
        .SYNOPSIS
        Retrieves details of a specified GitHub environment or lists all environments for a repository.

        .DESCRIPTION
        This function retrieves details of a specific environment in a GitHub repository when the `-Name` parameter
        is provided. Otherwise, it lists all available environments for the specified repository.

        Anyone with read access to the repository can use this function.
        OAuth app tokens and personal access tokens (classic) need the `repo` scope
        to use this function with a private repository.

        .EXAMPLE
        Get-GitHubEnvironment -Owner 'PSModule' -Repository 'EnvironmentTest' -Name 'test'

        Output:
        ```pwsh
        id                       : 5944178128
        node_id                  : EN_kwDOOJqfM88AAAABYkz10A
        name                     : test
        url                      : https://api.github.com/repos/PSModule/EnvironmentTest/environments/test
        html_url                 : https://github.com/PSModule/EnvironmentTest/deployments/activity_log?environments_filter=test
        created_at               : 3/16/2025 11:17:52 PM
        updated_at               : 3/16/2025 11:17:52 PM
        can_admins_bypass        : True
        protection_rules         : {@{id=30352888; node_id=GA_kwDOOJqfM84BzyX4; type=required_reviewers; prevent_self_review=False;
                                   reviewers=System.Object[]}, @{id=30352889; node_id=GA_kwDOOJqfM84BzyX5; type=wait_timer; wait_timer=100},
                                   @{id=30352890; node_id=GA_kwDOOJqfM84BzyX6; type=branch_policy}}
        deployment_branch_policy : @{protected_branches=False; custom_branch_policies=True}
        ```

        Retrieves details of the "test" environment in the specified repository.

        .EXAMPLE
        Get-GitHubEnvironment -Owner 'PSModule' -Repository 'EnvironmentTest'

        Output:
        ```pwsh
        id                       : 5944178128
        node_id                  : EN_kwDOOJqfM88AAAABYkz10A
        name                     : test
        url                      : https://api.github.com/repos/PSModule/EnvironmentTest/environments/test
        html_url                 : https://github.com/PSModule/EnvironmentTest/deployments/activity_log?environments_filter=test
        created_at               : 3/16/2025 11:17:52 PM
        updated_at               : 3/16/2025 11:17:52 PM
        can_admins_bypass        : True
        protection_rules         : {@{id=30352888; node_id=GA_kwDOOJqfM84BzyX4; type=required_reviewers; prevent_self_review=False;
                                   reviewers=System.Object[]}, @{id=30352889; node_id=GA_kwDOOJqfM84BzyX5; type=wait_timer; wait_timer=100},
                                   @{id=30352890; node_id=GA_kwDOOJqfM84BzyX6; type=branch_policy}}
        deployment_branch_policy : @{protected_branches=False; custom_branch_policies=True}
        ```

        Lists all environments available in the "EnvironmentTest" repository owned by "PSModule".

        .INPUTS
        GitHubRepository

        .OUTPUTS
        GitHubEnvironment[]

        .NOTES
        Returns details of a GitHub environment or a list of environments for a repository.

        .LINK
        https://psmodule.io/GitHub/Functions/Environments/Get-GitHubEnvironment/
    #>
    [OutputType([GitHubEnvironment[]])]
    [CmdletBinding()]
    param(
        # The name of the organization.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the Repository.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the environment.
        [Parameter(ValueFromPipelineByPropertyName)]
        [SupportsWildcards()]
        [string] $Name = '*',

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $params = @{
            Owner      = $Owner
            Repository = $Repository
            Context    = $Context
        }
        if ($Name.Contains('*')) {
            Get-GitHubEnvironmentList @params -PerPage $PerPage -Context $Context |
                Where-Object { $_.Name -like $Name }
        } else {
            Get-GitHubEnvironmentByName @params -Name $Name -Context $Context
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Environments] - [Get-GitHubEnvironment] - Done"
#endregion [functions] - [public] - [Environments] - [Get-GitHubEnvironment]
#region    [functions] - [public] - [Environments] - [Remove-GitHubEnvironment]
Write-Debug "[$scriptName] - [functions] - [public] - [Environments] - [Remove-GitHubEnvironment] - Importing"
filter Remove-GitHubEnvironment {
    <#
        .SYNOPSIS
        Deletes an environment from a repository.

        .DESCRIPTION
        Removes a specified environment from a given repository on GitHub. This action is irreversible.
        The function supports ShouldProcess for confirmation before execution.

        .EXAMPLE
        Remove-GitHubEnvironment -Owner 'PSModule' -Repository 'GitHub' -Name 'Production'

        Deletes the 'Production' environment from the 'PSModule/GitHub' repository.

        .LINK
        https://psmodule.io/GitHub/Functions/Environments/Remove-GitHubEnvironment/

        .NOTES
        [Delete environments](https://docs.github.com/rest/deployments/environments?#delete-an-environment)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        # The name of the organization.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the environment to delete.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $encodedName = [System.Uri]::EscapeDataString($Name)
        $apiParams = @{
            Method  = 'DELETE'
            Uri     = $Context.ApiBaseUri + "/repos/$Owner/$Repository/environments/$encodedName"
            Context = $Context
        }

        if ($PSCmdlet.ShouldProcess("Environment [$Owner/$Repository/$Name]", 'Delete')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Environments] - [Remove-GitHubEnvironment] - Done"
#endregion [functions] - [public] - [Environments] - [Remove-GitHubEnvironment]
#region    [functions] - [public] - [Environments] - [Set-GitHubEnvironment]
Write-Debug "[$scriptName] - [functions] - [public] - [Environments] - [Set-GitHubEnvironment] - Importing"
filter Set-GitHubEnvironment {
    <#
        .SYNOPSIS
        Create or update an environment.

        .DESCRIPTION
        Create or update an environment with protection rules, such as required reviewers. For more information about
        environment protection rules, see "[Environments](https://docs.github.com/actions/reference/environments#environment-protection-rules)."

        To create or update name patterns that branches must match in order to deploy to this environment, see
        "[Deployment branch policies](https://docs.github.com/rest/deployments/branch-policies)."

        To create or update secrets for an environment, see "[GitHub Actions secrets](https://docs.github.com/rest/actions/secrets)."

        OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        $params = @{
            Owner                  = "my-org"
            Repository             = "my-repo"
            Name                   = "staging"
            WaitTimer              = 30
            Reviewers              = @{ type = $user.Type; id = $user.ID }, @{ type = 'team'; id = $team.ID }
            DeploymentBranchPolicy = 'CustomBranchPolicies'
        }
        Set-GitHubEnvironment @params

        Output:
        ```powershell
        id                       : 5944178128
        node_id                  : EN_kwDOOJqfM88AAAABYkz10A
        name                     : test
        url                      : https://api.github.com/repos/PSModule/EnvironmentTest/environments/test
        html_url                 : https://github.com/PSModule/EnvironmentTest/deployments/activity_log?environments_filter=test
        created_at               : 3/16/2025 11:17:52 PM
        updated_at               : 3/16/2025 11:17:52 PM
        can_admins_bypass        : True
        protection_rules         : {@{id=30352888; node_id=GA_kwDOOJqfM84BzyX4; type=required_reviewers; prevent_self_review=False;
                                   reviewers=System.Object[]},@{id=30352889; node_id=GA_kwDOOJqfM84BzyX5; type=wait_timer; wait_timer=100},
                                   @{id=30352890; node_id=GA_kwDOOJqfM84BzyX6; type=branch_policy}}
        deployment_branch_policy : @{protected_branches=False; custom_branch_policies=True}
        ```

        Creates or updates the "staging" environment with a 30-minute wait timer.

        .OUTPUTS
        GitHubEnvironment

        .NOTES
        Returns the response object from the GitHub API call.

        .LINK
        https://psmodule.io/GitHub/Functions/Environments/Set-GitHubEnvironment/

        .NOTES
        [Create or update an environment](https://docs.github.com/rest/deployments/environments#create-or-update-an-environment)
    #>
    [OutputType([GitHubEnvironment])]
    [CmdletBinding(SupportsShouldProcess, DefaultParameterSetName = 'Default')]
    param(
        # The name of the organization.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'WithReviewers')]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the Repository.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'WithReviewers')]
        [string] $Repository,

        # The name of the environment.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'WithReviewers')]
        [string] $Name,

        # The amount of time to delay a job after the job is initially triggered.
        # The time (in minutes) must be an integer between 0 and 43,200 (30 days).
        [Parameter(ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
        [Parameter(ValueFromPipelineByPropertyName, ParameterSetName = 'WithReviewers')]
        [Alias('wait_timer')]
        [ValidateRange(0, 43200)]
        [int] $WaitTimer = 0,

        # The people or teams that may review jobs that reference the environment.
        # Must be an object with the following properties:
        # - ID: The ID of the user or team.
        # - Type: The type of reviewer. Can be either 'User' or 'Team'.
        # Example:
        # $Reviewers = @(
        #     @{ ID = 123456789; Type = 'User' },
        #     @{ ID = 987654321; Type = 'Team' }
        # )
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'WithReviewers')]
        [array] $Reviewers,

        # Whether or not a user who created the job is prevented from approving their own job.
        [Parameter(ValueFromPipelineByPropertyName, ParameterSetName = 'WithReviewers')]
        [Alias('prevent_self_review')]
        [switch] $PreventSelfReview,

        # The type of deployment branch policy for this environment.
        [Parameter(ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
        [Parameter(ValueFromPipelineByPropertyName, ParameterSetName = 'WithReviewers')]
        [Alias('deployment_branch_policy')]
        [ValidateSet('ProtectedBranches', 'CustomBranchPolicies')]
        [string] $DeploymentBranchPolicy,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $deploymentBranchPolicyValue = switch ($DeploymentBranchPolicy) {
            'ProtectedBranches' {
                @{
                    protected_branches     = $true
                    custom_branch_policies = $false
                }
            }
            'CustomBranchPolicies' {
                @{
                    protected_branches     = $false
                    custom_branch_policies = $true
                }
            }
            default {
                $null
            }
        }

        $body = @{
            wait_timer               = $WaitTimer
            deployment_branch_policy = $DeploymentBranchPolicyValue
        }
        if ($PSBoundParameters.ContainsKey('Reviewers')) {
            # loop through the reviewers and ensure type is User or Team. If either (case-insensitive) is found, ensure casing is User or Team.
            $reviewerList = [System.Collections.Generic.List[Object]]::new()
            foreach ($reviewer in $Reviewers) {
                switch ($reviewer.Type) {
                    'User' {
                        $reviewer.Type = 'User'
                    }
                    'Team' {
                        $reviewer.Type = 'Team'
                    }
                    default {
                        $PSCmdlet.ThrowTerminatingError(
                            [System.Management.Automation.ErrorRecord]::new(
                                [System.Exception]::new(
                                    "Invalid type '$($reviewer.Type)' for reviewer '$($reviewer.ID)'. Must be either 'User' or 'Team'."
                                ),
                                'InvalidReviewerType',
                                [System.Management.Automation.ErrorCategory]::InvalidArgument,
                                $_
                            )
                        )
                    }
                }
                $reviewerList.Add($reviewer)
            }
            $body['reviewers'] = $reviewerList
            $body['prevent_self_review'] = [bool]$PreventSelfReview
        }

        $encodedName = [System.Uri]::EscapeDataString($Name)
        $apiParams = @{
            Method  = 'PUT'
            Uri     = $Context.ApiBaseUri + "/repos/$Owner/$Repository/environments/$encodedName"
            Body    = $body
            Context = $Context
        }

        if ($PSCmdlet.ShouldProcess("Environment [$Owner/$Repository/$Name]", 'Set')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                [GitHubEnvironment]::new($_.Response, $Owner, $Repository, $Context)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Environments] - [Set-GitHubEnvironment] - Done"
#endregion [functions] - [public] - [Environments] - [Set-GitHubEnvironment]
Write-Debug "[$scriptName] - [functions] - [public] - [Environments] - Done"
#endregion [functions] - [public] - [Environments]
#region    [functions] - [public] - [Git]
Write-Debug "[$scriptName] - [functions] - [public] - [Git] - Processing folder"
#region    [functions] - [public] - [Git] - [Get-GitHubGitConfig]
Write-Debug "[$scriptName] - [functions] - [public] - [Git] - [Get-GitHubGitConfig] - Importing"
function Get-GitHubGitConfig {
    <#
        .SYNOPSIS
        Gets the global Git configuration.

        .DESCRIPTION
        Gets the global Git configuration.

        .EXAMPLE
        Get-GitHubGitConfig

        Gets the global Git configuration.

        .LINK
        https://psmodule.io/GitHub/Functions/Git/Get-GitHubGitConfig
    #>
    [OutputType([object[]])]
    [CmdletBinding()]
    param(
        [Parameter()]
        [ValidateSet('local', 'global', 'system')]
        [string] $Scope = 'local'
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $gitExists = Get-Command -Name 'git' -ErrorAction SilentlyContinue
        Write-Debug "GITEXISTS: $gitExists"
        if (-not $gitExists) {
            Write-Verbose 'Git is not installed. Cannot get git configuration.'
            return
        }

        $cmdresult = git rev-parse --is-inside-work-tree 2>&1
        Write-Debug "LASTEXITCODE: $LASTEXITCODE"
        Write-Debug "CMDRESULT:    $cmdresult"
        if ($LASTEXITCODE -ne 0) {
            Write-Verbose 'Not a git repository. Cannot get git configuration.'
            $Global:LASTEXITCODE = 0
            Write-Debug "Resetting LASTEXITCODE: $LASTEXITCODE"
            return
        }

        $config = @()
        $configList = git config --$Scope --list 2>&1
        if ($LASTEXITCODE -ne 0) {
            Write-Verbose "Failed to get git configuration for [$Scope]."
            $global:LASTEXITCODE = 0
            Write-Debug "Resetting LASTEXITCODE: $LASTEXITCODE"
            return $config
        }

        $configList = $configList | Sort-Object
        $configList | ForEach-Object {
            Write-Debug "CONFIG: $_"
            $name, $value = $_ -split '=', 2
            $name = ('' + $name).Trim()
            $value = ('' + $value).Trim()
            $config += @{
                $name = $value
            }
        }
        $config

    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Git] - [Get-GitHubGitConfig] - Done"
#endregion [functions] - [public] - [Git] - [Get-GitHubGitConfig]
#region    [functions] - [public] - [Git] - [Set-GitHubGitConfig]
Write-Debug "[$scriptName] - [functions] - [public] - [Git] - [Set-GitHubGitConfig] - Importing"
function Set-GitHubGitConfig {
    <#
        .SYNOPSIS
        Set the Git configuration for the GitHub context.

        .DESCRIPTION
        Sets the Git configuration for the GitHub context. This command sets the `user.name`, `user.email`, and `url.<host>.insteadOf` git configs.

        .EXAMPLE
        Set-GitHubGitConfig

        Sets the Git configuration for the default GitHub context.

        .EXAMPLE
        Set-GitHubGitConfig -Context 'MyContext'

        Sets the Git configuration for the GitHub context named 'MyContext'.

        .LINK
        https://psmodule.io/GitHub/Functions/Git/Set-GitHubGitConfig
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $gitExists = Get-Command -Name 'git' -ErrorAction SilentlyContinue
        Write-Debug "GITEXISTS: $gitExists"
        if (-not $gitExists) {
            Write-Verbose 'Git is not installed. Cannot configure git.'
            return
        }

        $cmdresult = git rev-parse --is-inside-work-tree 2>&1
        Write-Debug "LASTEXITCODE: $LASTEXITCODE"
        Write-Debug "CMDRESULT:    $cmdresult"
        if ($LASTEXITCODE -ne 0) {
            Write-Verbose 'Not a git repository. Cannot configure git.'
            $Global:LASTEXITCODE = 0
            Write-Debug "Resetting LASTEXITCODE: $LASTEXITCODE"
            return
        }

        $username = $Context.UserName
        $id = $Context.DatabaseID
        $token = $Context.Token | ConvertFrom-SecureString -AsPlainText
        $hostName = $Context.HostName
        $installationName = $Context.InstallationName
        $sshUser = $Context.Enterprise ?? 'git'

        if ($PSCmdlet.ShouldProcess("$username on $installationName", 'Set Git configuration')) {
            $git = 'git'
            @(
                @('config', '--global', 'user.name', "$username"),
                @('config', '--global', 'user.email', "$id+$username@users.noreply.github.com"),
                @('config', '--global', '--add', "url.https://oauth2:$token@$hostName/$installationName.insteadOf",
                    "ssh://$sshUser@$hostName`:$installationName"),
                @('config', '--global', '--add', "url.https://oauth2:$token@$hostName/$installationName.insteadOf",
                    "https://$hostName/$installationName")
            ) | ForEach-Object {
                Write-Verbose "$git $($_ -join ' ')"
                & $git $_
                if ($LASTEXITCODE -ne 0) {
                    throw "Failed to run git command. ($LASTEXITCODE)"
                }
            }
        }

    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Git] - [Set-GitHubGitConfig] - Done"
#endregion [functions] - [public] - [Git] - [Set-GitHubGitConfig]
Write-Debug "[$scriptName] - [functions] - [public] - [Git] - Done"
#endregion [functions] - [public] - [Git]
#region    [functions] - [public] - [Gitignore]
Write-Debug "[$scriptName] - [functions] - [public] - [Gitignore] - Processing folder"
#region    [functions] - [public] - [Gitignore] - [Get-GitHubGitignore]
Write-Debug "[$scriptName] - [functions] - [public] - [Gitignore] - [Get-GitHubGitignore] - Importing"
filter Get-GitHubGitignore {
    <#
        .SYNOPSIS
        Get a gitignore template or list of all gitignore templates names

        .DESCRIPTION
        If no parameters are specified, the function will return a list of all gitignore templates names.
        If the Name parameter is specified, the function will return the gitignore template for the specified name.

        .EXAMPLE
        Get-GitHubGitignoreList

        Get all gitignore templates

        .EXAMPLE
        Get-GitHubGitignore -Name 'VisualStudio'

        Get a gitignore template for VisualStudio

        .NOTES
        [Get a gitignore template](https://docs.github.com/rest/gitignore/gitignore#get-a-gitignore-template)
        [Get all gitignore templates](https://docs.github.com/rest/gitignore/gitignore#get-all-gitignore-templates)

        .LINK
        https://psmodule.io/GitHub/Functions/Gitignore/Get-GitHubGitignore
    #>
    [CmdletBinding(DefaultParameterSetName = 'List')]
    param(
        [Parameter(
            Mandatory,
            ParameterSetName = 'Name'
        )]
        [string] $Name,

        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter()]
        [switch] $Anonymous,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context -Anonymous $Anonymous
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $params = @{
            Context   = $Context
        }
        switch ($PSCmdlet.ParameterSetName) {
            'List' {
                Get-GitHubGitignoreList @params
            }
            'Name' {
                Get-GitHubGitignoreByName @params -Name $Name
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

Register-ArgumentCompleter -CommandName Get-GitHubGitignore -ParameterName Name -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter
    Get-GitHubGitignore -Anonymous | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Gitignore] - [Get-GitHubGitignore] - Done"
#endregion [functions] - [public] - [Gitignore] - [Get-GitHubGitignore]
Write-Debug "[$scriptName] - [functions] - [public] - [Gitignore] - Done"
#endregion [functions] - [public] - [Gitignore]
#region    [functions] - [public] - [Issues]
Write-Debug "[$scriptName] - [functions] - [public] - [Issues] - Processing folder"
#region    [functions] - [public] - [Issues] - [ConvertFrom-IssueForm]
Write-Debug "[$scriptName] - [functions] - [public] - [Issues] - [ConvertFrom-IssueForm] - Importing"
function ConvertFrom-IssueForm {
    <#
        .SYNOPSIS
        Converts the issue form content into a hashtable or object.

        .DESCRIPTION
        Aligns with the issue form content structure and converts it into a hashtable or object.
        Section titles become keys and their content becomes values.

        .EXAMPLE
        @'
        ### Section 1
        Content 1
        Content 2

        ### Section 2
        - [ ] Item 1
        - [x] Item 2
        '@ | ConvertFrom-IssueForm
        Section 1            Section 2
        ---------            ---------
        Content 1…           {[Item 2, True], [Item 1, False]}

        Converts the issue form content into a hashtable.

        .LINK
        https://psmodule.io/GitHub/Functions/Issues/ConvertFrom-IssueForm
    #>
    [OutputType([PSCustomObject])]
    [OutputType([hashtable])]
    [CmdletBinding()]
    param(
        # The issue form content to parse.
        [Parameter(
            Mandatory,
            ValueFromPipeline
        )]
        [string] $IssueForm,

        # If set, the output will be a hashtable instead of an object.
        [Parameter()]
        [switch] $AsHashtable
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        # Properly remove HTML comments
        $content = $IssueForm -replace '(?s)<!--.*?-->'
        $content = $content -split '\r?\n' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }

        $results = @()
        $currentHeader = ''
        $currentParagraph = @()

        foreach ($line in $content) {
            Write-Verbose "Processing line: [$line]"

            if ($line -match '^### (.+)$') {
                Write-Verbose ' - Is header'
                if ($currentHeader -ne '') {
                    $results += [PSCustomObject]@{
                        Header    = $currentHeader
                        Paragraph = $currentParagraph
                    }
                }

                $currentHeader = $matches[1]
                $currentParagraph = @()
            } else {
                $currentParagraph += $line
            }
        }

        if ($currentHeader -ne '') {
            $results += [PSCustomObject]@{
                Header    = $currentHeader
                Paragraph = $currentParagraph
            }
        }

        $data = @{}
        foreach ($entry in $results) {
            $header = $entry.Header
            $paragraph = $entry.Paragraph

            if ($paragraph -match '^\s*-\s*\[.\]\s+') {
                $checkboxHashTable = @{}
                foreach ($line in $paragraph) {
                    if ($line -match '^\s*-\s*\[(x| )\]\s*(.+)$') {
                        $checked = $matches[1] -eq 'x'
                        $item = $matches[2]
                        $checkboxHashTable[$item] = $checked
                    }
                }
                $data[$header] = $checkboxHashTable
            } else {
                $data[$header] = $paragraph -join [System.Environment]::NewLine
            }
        }

        if ($AsHashtable) {
            return $data
        }

        [PSCustomObject]$data
    }


    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Issues] - [ConvertFrom-IssueForm] - Done"
#endregion [functions] - [public] - [Issues] - [ConvertFrom-IssueForm]
Write-Debug "[$scriptName] - [functions] - [public] - [Issues] - Done"
#endregion [functions] - [public] - [Issues]
#region    [functions] - [public] - [License]
Write-Debug "[$scriptName] - [functions] - [public] - [License] - Processing folder"
#region    [functions] - [public] - [License] - [Get-GitHubLicense]
Write-Debug "[$scriptName] - [functions] - [public] - [License] - [Get-GitHubLicense] - Importing"
filter Get-GitHubLicense {
    <#
        .SYNOPSIS
        Get a license template, list of all popular license templates or a license for a repository

        .DESCRIPTION
        If no parameters are specified, the function will return a list of all license templates.
        If the Name parameter is specified, the function will return the license template for the specified name.
        If the Owner and Repo parameters are specified, the function will return the license for the specified repository.

        .EXAMPLE
        Get-GitHubLicense

        Get all license templates

        .EXAMPLE
        Get-GitHubLicense -Name mit

        Get the mit license template

        .EXAMPLE
        Get-GitHubLicense -Owner 'octocat' -Repository 'Hello-World'

        Get the license for the Hello-World repository from the octocat account.


        .NOTES
        [Get a license](https://docs.github.com/rest/licenses/licenses#get-a-license)
        [Get all commonly used licenses](https://docs.github.com/rest/licenses/licenses#get-all-commonly-used-licenses)
        [Get the license for a repository](https://docs.github.com/rest/licenses/licenses#get-the-license-for-a-repository)

        .LINK
        https://psmodule.io/GitHub/Functions/License/Get-GitHubLicense
    #>
    [CmdletBinding(DefaultParameterSetName = 'List')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(ParameterSetName = 'Repository')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(ParameterSetName = 'Repository')]
        [string] $Repository,

        # The license keyword, license name, or license SPDX ID. For example, mit or mpl-2.0.
        [Parameter(ParameterSetName = 'Name')]
        [string] $Name,

        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter()]
        [switch] $Anonymous,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context -Anonymous $Anonymous
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $params = @{
            Context = $Context
        }
        switch ($PSCmdlet.ParameterSetName) {
            'List' {
                Get-GitHubLicenseList @params
            }
            'Name' {
                Get-GitHubLicenseByName @params -Name $Name
            }
            'Repository' {
                Get-GitHubRepositoryLicense @params -Owner $Owner -Repository $Repository
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

Register-ArgumentCompleter -CommandName Get-GitHubLicense -ParameterName Name -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter
    Get-GitHubLicense -Anonymous | Select-Object -ExpandProperty Name | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [License] - [Get-GitHubLicense] - Done"
#endregion [functions] - [public] - [License] - [Get-GitHubLicense]
Write-Debug "[$scriptName] - [functions] - [public] - [License] - Done"
#endregion [functions] - [public] - [License]
#region    [functions] - [public] - [Markdown]
Write-Debug "[$scriptName] - [functions] - [public] - [Markdown] - Processing folder"
#region    [functions] - [public] - [Markdown] - [Get-GitHubMarkdown]
Write-Debug "[$scriptName] - [functions] - [public] - [Markdown] - [Get-GitHubMarkdown] - Importing"
filter Get-GitHubMarkdown {
    <#
        .SYNOPSIS
        Render a Markdown document

        .DESCRIPTION
        Converts Markdown to HTML

        .EXAMPLE
        Get-GitHubMarkdown -Text "Hello **world**"
        "<p>Hello <strong>world</strong></p>"

        Renders the Markdown text "Hello **world**" to HTML.

        .NOTES
        [Render a Markdown document](https://docs.github.com/rest/markdown/markdown#render-a-markdown-document)

        .LINK
        https://psmodule.io/GitHub/Functions/Markdown/Get-GitHubMarkdown
    #>
    [OutputType([string])]
    [CmdletBinding()]
    param(
        # The Markdown text to render in HTML.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Text,

        # The rendering mode.
        [Parameter()]
        [ValidateSet('markdown', 'gfm')]
        [string] $Mode = 'markdown',

        # The repository context to use when creating references in `gfm` mode. For example, setting `context` to `octo-org/octo-Repository` will
        # change the text `#42` into an HTML link to issue 42 in the `octo-org/octo-Repository` repository.
        [Parameter()]
        [string] $RepoContext,

        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter()]
        [switch] $Anonymous,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context -Anonymous $Anonymous
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $body = @{
            context = $RepoContext
            mode    = $Mode
            text    = $Text
        }

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = '/markdown'
            Body        = $body
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Markdown] - [Get-GitHubMarkdown] - Done"
#endregion [functions] - [public] - [Markdown] - [Get-GitHubMarkdown]
#region    [functions] - [public] - [Markdown] - [Get-GitHubMarkdownRaw]
Write-Debug "[$scriptName] - [functions] - [public] - [Markdown] - [Get-GitHubMarkdownRaw] - Importing"
filter Get-GitHubMarkdownRaw {
    <#
        .SYNOPSIS
        Render a Markdown document in raw mode

        .DESCRIPTION
        You must send Markdown as plain text (using a `Content-Type` header of `text/plain` or `text/x-markdown`) to this endpoint, rather than using
        JSON format. In raw mode, [GitHub Flavored Markdown](https://github.github.com/gfm/) is not supported and Markdown will be rendered in plain
        format like a README.md file. Markdown content must be 400 KB or less.

        .EXAMPLE
        Get-GitHubMarkdownRaw -Text 'Hello, world!'
        "<p>Hello <strong>world</strong></p>"

        Render the Markdown text 'Hello, world!' in raw mode.

        .NOTES
        [Render a Markdown document in raw mode](https://docs.github.com/rest/markdown/markdown#render-a-markdown-document-in-raw-mode)

        .LINK
        https://psmodule.io/GitHub/Functions/Markdown/Get-GitHubMarkdownRaw
    #>
    [CmdletBinding()]
    param(
        # The Markdown text to render in HTML.
        [Parameter()]
        [string] $Text,

        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter()]
        [switch] $Anonymous,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context -Anonymous $Anonymous
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $body = @{
            text = $Text
        }

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = '/markdown/raw'
            ContentType = 'text/plain'
            Body        = $body
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Markdown] - [Get-GitHubMarkdownRaw] - Done"
#endregion [functions] - [public] - [Markdown] - [Get-GitHubMarkdownRaw]
Write-Debug "[$scriptName] - [functions] - [public] - [Markdown] - Done"
#endregion [functions] - [public] - [Markdown]
#region    [functions] - [public] - [Meta]
Write-Debug "[$scriptName] - [functions] - [public] - [Meta] - Processing folder"
#region    [functions] - [public] - [Meta] - [Get-GitHubApiVersion]
Write-Debug "[$scriptName] - [functions] - [public] - [Meta] - [Get-GitHubApiVersion] - Importing"
filter Get-GitHubApiVersion {
    <#
        .SYNOPSIS
        Get all API versions.

        .DESCRIPTION
        Get all supported GitHub API versions.

        .EXAMPLE
        Get-GitHubApiVersion

        Get all supported GitHub API versions.

        .NOTES
        [Get all API versions](https://docs.github.com/rest/meta/meta#get-all-api-versions)

        .LINK
        https://psmodule.io/GitHub/Functions/Meta/Get-GitHubApiVersion
    #>
    [OutputType([string[]])]
    [CmdletBinding()]
    param(
        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter()]
        [switch] $Anonymous,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context -Anonymous $Anonymous
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            ApiEndpoint = '/versions'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Meta] - [Get-GitHubApiVersion] - Done"
#endregion [functions] - [public] - [Meta] - [Get-GitHubApiVersion]
#region    [functions] - [public] - [Meta] - [Get-GitHubMeta]
Write-Debug "[$scriptName] - [functions] - [public] - [Meta] - [Get-GitHubMeta] - Importing"
filter Get-GitHubMeta {
    <#
        .SYNOPSIS
        Get GitHub meta information.

        .DESCRIPTION
        Returns meta information about GitHub, including a list of GitHub's IP addresses. For more information, see
        "[About GitHub's IP addresses](https://docs.github.com/articles/about-github-s-ip-addresses/)."

        The API's response also includes a list of GitHub's domain names.

        The values shown in the documentation's response are example values. You must always query the API directly to get the latest values.

        **Note:** This endpoint returns both IPv4 and IPv6 addresses. However, not all features support IPv6. You should refer to the specific
        documentation for each feature to determine if IPv6 is supported.

        .EXAMPLE
        Get-GitHubMeta

        Returns meta information about GitHub, including a list of GitHub's IP addresses.

        .NOTES
        [Get GitHub meta information](https://docs.github.com/rest/meta/meta#get-apiname-meta-information)

        .LINK
        https://psmodule.io/GitHub/Functions/Meta/Get-GitHubMeta
    #>
    [OutputType([object])]
    [CmdletBinding()]
    param(
        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter()]
        [switch] $Anonymous,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context -Anonymous $Anonymous
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            ApiEndpoint = '/meta'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Meta] - [Get-GitHubMeta] - Done"
#endregion [functions] - [public] - [Meta] - [Get-GitHubMeta]
#region    [functions] - [public] - [Meta] - [Get-GitHubOctocat]
Write-Debug "[$scriptName] - [functions] - [public] - [Meta] - [Get-GitHubOctocat] - Importing"
filter Get-GitHubOctocat {
    <#
        .SYNOPSIS
        Get Octocat.

        .DESCRIPTION
        Get the octocat as ASCII art.

        .EXAMPLE
        Get-GitHubOctocat

        Get the octocat as ASCII art

        .EXAMPLE
        Get-GitHubOctocat -S "Hello world"

        Get the octocat as ASCII art with a custom saying

        .NOTES
        [Get Octocat](https://docs.github.com/rest/meta/meta#get-octocat)

        .LINK
        https://psmodule.io/GitHub/Functions/Meta/Get-GitHubOctocat
    #>
    [OutputType([string])]
    [CmdletBinding()]
    param(
        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter()]
        [switch] $Anonymous,

        # The words to show in Octocat's speech bubble
        [Parameter()]
        [string] $Saying,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context -Anonymous $Anonymous
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $body = @{
            s = $Saying
        }

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/octocat'
            Body        = $body
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Meta] - [Get-GitHubOctocat] - Done"
#endregion [functions] - [public] - [Meta] - [Get-GitHubOctocat]
#region    [functions] - [public] - [Meta] - [Get-GitHubRoot]
Write-Debug "[$scriptName] - [functions] - [public] - [Meta] - [Get-GitHubRoot] - Importing"
filter Get-GitHubRoot {
    <#
        .SYNOPSIS
        GitHub API Root.

        .DESCRIPTION
        Get Hypermedia links to resources accessible in GitHub's REST API.

        .EXAMPLE
        Get-GitHubRoot

        Get the root endpoint for the GitHub API.

        .NOTES
        [GitHub API Root](https://docs.github.com/rest/meta/meta#github-api-root)

        .LINK
        https://psmodule.io/GitHub/Functions/Meta/Get-GitHubRoot
    #>
    [CmdletBinding()]
    param(
        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter()]
        [switch] $Anonymous,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context -Anonymous $Anonymous
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Meta] - [Get-GitHubRoot] - Done"
#endregion [functions] - [public] - [Meta] - [Get-GitHubRoot]
#region    [functions] - [public] - [Meta] - [Get-GitHubZen]
Write-Debug "[$scriptName] - [functions] - [public] - [Meta] - [Get-GitHubZen] - Importing"
filter Get-GitHubZen {
    <#
        .SYNOPSIS
        Get the Zen of GitHub.

        .DESCRIPTION
        Get a random sentence from the Zen of GitHub.

        .EXAMPLE
        Get-GitHubZen

        Get a random sentence from the Zen of GitHub.

        .NOTES
        [Get the Zen of GitHub](https://docs.github.com/rest/meta/meta#get-the-zen-of-github)

        .LINK
        https://psmodule.io/GitHub/Functions/Meta/Get-GitHubZen
    #>
    [CmdletBinding()]
    param(
        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter()]
        [switch] $Anonymous,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context -Anonymous $Anonymous
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/zen'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Meta] - [Get-GitHubZen] - Done"
#endregion [functions] - [public] - [Meta] - [Get-GitHubZen]
Write-Debug "[$scriptName] - [functions] - [public] - [Meta] - Done"
#endregion [functions] - [public] - [Meta]
#region    [functions] - [public] - [Organization]
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - Processing folder"
#region    [functions] - [public] - [Organization] - [completers]
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [completers] - Importing"
Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport |
        Where-Object { $_ -like '*GitHubOrganization' }) -ParameterName Name -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters
    (Get-GitHubOrganization).Name | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}

Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport) -ParameterName Owner -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters
    (Get-GitHubOrganization).Name | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}

Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport) -ParameterName Organization -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters
    (Get-GitHubOrganization).Name | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [completers] - Done"
#endregion [functions] - [public] - [Organization] - [completers]
#region    [functions] - [public] - [Organization] - [Get-GitHubOrganization]
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Get-GitHubOrganization] - Importing"
filter Get-GitHubOrganization {
    <#
        .SYNOPSIS
        List organization

        .DESCRIPTION
        List organizations for the authenticated user - if no parameters are provided.
        List organizations for a user - if a username is provided.
        Lists all organizations, in the order that they were created on GitHub - if '-All' is provided.
        Get an organization - if a organization name is provided.

        .EXAMPLE
        Get-GitHubOrganization

        List all organizations for the authenticated user.

        .EXAMPLE
        Get-GitHubOrganization -Username 'octocat'

        List public organizations for a specific user.

        .EXAMPLE
        Get-GitHubOrganization -All -Since 142951047

        List all organizations made after an ID.

        .EXAMPLE
        Get-GitHubOrganization -Name 'PSModule'

        Get a specific organization.

        .EXAMPLE
        Get-GitHubOrganization -Enterprise 'msx'

        Get the organizations belonging to an Enterprise.

        .OUTPUTS
        GitHubOrganization

        .LINK
        https://psmodule.io/GitHub/Functions/Organization/Get-GitHubOrganization
    #>
    [OutputType([GitHubOrganization])]
    [CmdletBinding(DefaultParameterSetName = 'List all organizations for the authenticated user')]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSReviewUnusedParameter', 'All', Justification = 'Required for parameter set')]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ParameterSetName = 'Get a specific organization',
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Name,

        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ParameterSetName = 'List public organizations for a specific user',
            ValueFromPipelineByPropertyName
        )]
        [Alias('User')]
        [string] $Username,

        # The Enterprise slug to get organizations from.
        [Parameter(
            Mandatory,
            ParameterSetName = 'Get the organizations belonging to an Enterprise',
            ValueFromPipelineByPropertyName
        )]
        [string] $Enterprise,

        # List all organizations. Use '-Since' to start at a specific organization ID.
        [Parameter(
            Mandatory,
            ParameterSetName = 'List all organizations on the tenant'
        )]
        [switch] $All,

        # A organization ID. Only return organizations with an ID greater than this ID.
        [Parameter(ParameterSetName = 'List all organizations on the tenant')]
        [int] $Since = 0,

        # The number of results per page (max 100).
        [Parameter(ParameterSetName = 'List all organizations on the tenant')]
        [Parameter(ParameterSetName = 'List all organizations for the authenticated user')]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'Get a specific organization' {
                Get-GitHubOrganizationByName -Name $Name -Context $Context
            }
            'List public organizations for a specific user' {
                Get-GitHubUserOrganization -Username $Username -Context $Context
            }
            'Get the organizations belonging to an Enterprise' {
                Get-GitHubAppInstallableOrganization -Enterprise $Enterprise -Context $Context
            }
            'List all organizations on the tenant' {
                Get-GitHubAllOrganization -Since $Since -PerPage $PerPage -Context $Context
            }
            'List all organizations for the authenticated user' {
                Get-GitHubOrganizationListForAuthUser -PerPage $PerPage -Context $Context
            }
            default {
                Write-Error "Invalid parameter set name: $($PSCmdlet.ParameterSetName)"
                throw "Unsupported parameter set name: $($PSCmdlet.ParameterSetName)"
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Get-GitHubOrganization] - Done"
#endregion [functions] - [public] - [Organization] - [Get-GitHubOrganization]
#region    [functions] - [public] - [Organization] - [New-GitHubOrganization]
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [New-GitHubOrganization] - Importing"
function New-GitHubOrganization {
    <#
        .SYNOPSIS
        Creates a new GitHub organization within a specified enterprise.

        .DESCRIPTION
        This function creates a new GitHub organization within the specified enterprise.

        .EXAMPLE
        New-GitHubOrganization -Enterprise 'my-enterprise' -Name 'my-org' -Owner 'user1' -BillingEmail 'billing@example.com'

        .OUTPUTS
        GitHubOrganization

        .LINK
        https://psmodule.io/GitHub/Functions/Organization/New-GitHubOrganization/
    #>
    [OutputType([GitHubOrganization])]
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
    param(
        # The name of the enterprise to create the organization in.
        [Parameter()]
        [string]$Enterprise,

        # The name of the organization to create.
        [Parameter(Mandatory)]
        [string]$Name,

        # The owners of the organization. This should be a list of GitHub usernames.
        [Parameter(Mandatory)]
        [string[]]$Owner,

        # The billing email for the organization.
        [Parameter()]
        [string]$BillingEmail,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $enterpriseObject = Get-GitHubEnterprise -Name $Enterprise -Context $Context
        Write-Verbose "Creating organization in enterprise: $($enterpriseObject.Name)"
        $graphQLFields = ([GitHubOrganization]::PropertyToGraphQLMap).Values

        $inputParams = @{
            adminLogins  = $Owner
            billingEmail = $BillingEmail
            enterpriseId = $enterpriseObject.NodeID
            login        = $Name
            profileName  = $Name
        }

        $updateGraphQLInputs = @{
            Query     = @"
mutation(`$input:CreateEnterpriseOrganizationInput!) {
    createEnterpriseOrganization(input:`$input) {
        organization {
            $graphQLFields
        }
    }
}
"@
            Variables = @{
                input = $inputParams
            }
            Context   = $Context
        }
        if ($PSCmdlet.ShouldProcess("Creating organization '$Name' in enterprise '$Enterprise'")) {
            $orgresult = Invoke-GitHubGraphQLQuery @updateGraphQLInputs
            [GitHubOrganization]::new($orgresult.createEnterpriseOrganization.organization, $Context)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [New-GitHubOrganization] - Done"
#endregion [functions] - [public] - [Organization] - [New-GitHubOrganization]
#region    [functions] - [public] - [Organization] - [Remove-GitHubOrganization]
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Remove-GitHubOrganization] - Importing"
filter Remove-GitHubOrganization {
    <#
        .SYNOPSIS
        Delete an organization

        .DESCRIPTION
        Deletes an organization and all its repositories.
        The organization login will be unavailable for 90 days after deletion.
        Please review the [GitHub Terms of Service](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
        regarding account deletion before using this endpoint.

        .EXAMPLE
        Remove-GitHubOrganization -Name 'GitHub'

        Deletes the organization 'GitHub' and all its repositories.

        .INPUTS
        GitHubOrganization

        .NOTES
        [Delete an organization](https://docs.github.com/rest/orgs/orgs#delete-an-organization)

        .LINK
        https://psmodule.io/GitHub/Functions/Organization/Remove-GitHubOrganization
    #>
    [OutputType([void])]
    [CmdletBinding(DefaultParameterSetName = 'Remove an organization', SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [string] $Name,

        # The input object to process. Can be a single or an array of GitHubOrganization objects.
        [Parameter(Mandatory, ParameterSetName = 'ArrayInput', ValueFromPipeline)]
        [GitHubOrganization[]] $InputObject,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'ArrayInput' {
                foreach ($item in $InputObject) {
                    $params = @{
                        Name    = $item.Name
                        Context = $Context
                    }
                    Remove-GitHubOrganization @params
                }
                break
            }
            default {
                $apiParams = @{
                    Method      = 'DELETE'
                    APIEndpoint = "/orgs/$Name"
                    Context     = $Context
                }

                if ($PSCmdlet.ShouldProcess("organization [$Name]", 'Delete')) {
                    $null = Invoke-GitHubAPI @apiParams
                }
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Remove-GitHubOrganization] - Done"
#endregion [functions] - [public] - [Organization] - [Remove-GitHubOrganization]
#region    [functions] - [public] - [Organization] - [Update-GitHubOrganization]
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Update-GitHubOrganization] - Importing"
filter Update-GitHubOrganization {
    <#
        .SYNOPSIS
        Update an organization

        .DESCRIPTION
        Enables an authenticated organization owner with the `admin:org` scope or the `repo` scope to update the organization's
        profile and member privileges.

        .EXAMPLE
        Update-GitHubOrganization -Organization 'GitHub' -Description 'The official GitHub organization.'

        Sets the description for the organization 'GitHub' to 'The official GitHub organization.'.

        .EXAMPLE
        $param = @{
            Organization                         = 'GitHub'
            MembersCanCreatePublicRepositories   = $true
            MembersCanCreatePrivateRepositories  = $true
            MembersCanCreateInternalRepositories = $true
        }
        Update-GitHubOrganization @param

        Sets the repository creation permissions for the organization 'GitHub' to allow all members to create public, private,
        and internal repositories.

        .INPUTS
        GitHubOrganization

        .OUTPUTS
        GitHubOrganization

        .NOTES
        [Update an organization](https://docs.github.com/rest/orgs/orgs#update-an-organization)

        .LINK
        https://psmodule.io/GitHub/Functions/Organization/Update-GitHubOrganization
    #>
    [OutputType([GitHubOrganization])]
    [CmdletBinding(SupportsShouldProcess)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '',
        Justification = 'Long parameter names'
    )]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Name,

        # Billing email address. This address is not publicized.
        [Parameter(ValueFromPipelineByPropertyName)]
        [string] $BillingEmail,

        # The company name.
        [Parameter(ValueFromPipelineByPropertyName)]
        [string] $Company,

        # The publicly visible email address.
        [Parameter(ValueFromPipelineByPropertyName)]
        [string] $Email,

        # The Twitter username of the company.
        [Parameter(ValueFromPipelineByPropertyName)]
        [string] $TwitterUsername,

        # The location.
        [Parameter(ValueFromPipelineByPropertyName)]
        [string] $Location,

        # The shorthand name of the company.
        [Parameter(ValueFromPipelineByPropertyName)]
        [string] $NewName,

        # The description of the company.
        [Parameter(ValueFromPipelineByPropertyName)]
        [string] $Description,

        # Whether an organization can use organization projects.
        [Parameter(ValueFromPipelineByPropertyName)]
        [bool] $HasOrganizationProjects,

        # Whether repositories that belong to the organization can use repository projects.
        [Parameter(ValueFromPipelineByPropertyName)]
        [bool] $HasRepositoryProjects,

        # Default permission level members have for organization repositories.
        [Parameter(ValueFromPipelineByPropertyName)]
        [ValidateSet('Read', 'Write', 'Admin', 'None')]
        [string] $DefaultRepositoryPermission,

        # Whether of non-admin organization members can create repositories.
        # Note: A parameter can override this parameter. See members_allowed_repository_creation_type in this table for details.
        [Parameter(ValueFromPipelineByPropertyName)]
        [bool] $MembersCanCreateRepositories,

        # Whether organization members can create internal repositories, which are visible to all enterprise members.
        # You can only allow members to create internal repositories if your organization is associated with an enterprise
        # account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see
        # "Restricting repository creation in your organization" in the GitHub Help documentation.
        [Parameter(ValueFromPipelineByPropertyName)]
        [bool] $MembersCanCreateInternalRepositories,

        # Whether organization members can create private repositories, which are visible to organization members with permission.
        # For more information, see "Restricting repository creation in your organization" in the GitHub Help documentation.
        [Parameter(ValueFromPipelineByPropertyName)]
        [bool] $MembersCanCreatePrivateRepositories,

        # Whether organization members can create public repositories, which are visible to anyone. For more information,
        # see 'Restricting repository creation in your organization' in the GitHub Help documentation.
        [Parameter(ValueFromPipelineByPropertyName)]
        [bool] $MembersCanCreatePublicRepositories,

        # Whether organization members can create GitHub Pages sites. Existing published sites will not be impacted.
        [Parameter(ValueFromPipelineByPropertyName)]
        [bool] $MembersCanCreatePages,

        # Whether organization members can create public GitHub Pages sites. Existing published sites will not be impacted.
        [Parameter(ValueFromPipelineByPropertyName)]
        [bool] $MembersCanCreatePublicPages,

        # Whether organization members can create private GitHub Pages sites. Existing published sites will not be impacted.
        [Parameter(ValueFromPipelineByPropertyName)]
        [bool] $MembersCanCreatePrivatePages,

        # Whether organization members can fork private organization repositories.
        [Parameter(ValueFromPipelineByPropertyName)]
        [bool] $MembersCanForkPrivateRepositories,

        # Whether contributors to organization repositories are required to sign off on commits they make through GitHub's web interface.
        [Parameter(ValueFromPipelineByPropertyName)]
        [bool] $WebCommitSignoffRequired,

        # Path to the organization's site.
        [Parameter(ValueFromPipelineByPropertyName)]
        [string] $Website,

        # Whether secret scanning push protection is automatically enabled for new repositories.
        # To use this parameter, you must have admin permissions for the repository or be an owner or security manager for
        # the organization that owns the repository. For more information, see "Managing security managers in your organization."
        # You can check which security and analysis features are currently enabled by using a GET /orgs/{org} request.
        [Parameter(ValueFromPipelineByPropertyName)]
        [bool] $SecretScanningPushProtectionEnabledForNewRepositories,

        # Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.
        [Parameter(ValueFromPipelineByPropertyName)]
        [bool] $SecretScanningPushProtectionCustomLinkEnabled,

        # If secret_scanning_push_protection_custom_link_enabled is true, the URL that will be displayed to contributors who
        # are blocked from pushing a secret.
        [Parameter(ValueFromPipelineByPropertyName)]
        [string] $SecretScanningPushProtectionCustomLink,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            name                                                         = $NewName
            billing_email                                                = $BillingEmail
            blog                                                         = $Website
            company                                                      = $Company
            description                                                  = $Description
            email                                                        = $Email
            location                                                     = $Location
            twitter_username                                             = $TwitterUsername
            has_organization_projects                                    = $PSBoundParameters.ContainsKey('HasOrganizationProjects') ? $HasOrganizationProjects : $null
            has_repository_projects                                      = $PSBoundParameters.ContainsKey('HasRepositoryProjects') ? $HasRepositoryProjects : $null
            default_repository_permission                                = $PSBoundParameters.ContainsKey('DefaultRepositoryPermission') ? $DefaultRepositoryPermission.ToLower() : $null
            members_can_create_repositories                              = $PSBoundParameters.ContainsKey('MembersCanCreateRepositories') ? $MembersCanCreateRepositories : $null
            members_can_create_internal_repositories                     = $PSBoundParameters.ContainsKey('MembersCanCreateInternalRepositories') ? $MembersCanCreateInternalRepositories : $null
            members_can_create_private_repositories                      = $PSBoundParameters.ContainsKey('MembersCanCreatePrivateRepositories') ? $MembersCanCreatePrivateRepositories : $null
            members_can_create_public_repositories                       = $PSBoundParameters.ContainsKey('MembersCanCreatePublicRepositories') ? $MembersCanCreatePublicRepositories : $null
            members_can_create_pages                                     = $PSBoundParameters.ContainsKey('MembersCanCreatePages') ? $MembersCanCreatePages : $null
            members_can_create_public_pages                              = $PSBoundParameters.ContainsKey('MembersCanCreatePublicPages') ? $MembersCanCreatePublicPages : $null
            members_can_create_private_pages                             = $PSBoundParameters.ContainsKey('MembersCanCreatePrivatePages') ? $MembersCanCreatePrivatePages : $null
            members_can_fork_private_repositories                        = $PSBoundParameters.ContainsKey('MembersCanForkPrivateRepositories') ? $MembersCanForkPrivateRepositories : $null
            web_commit_signoff_required                                  = $PSBoundParameters.ContainsKey('WebCommitSignoffRequired') ? $WebCommitSignoffRequired : $null
            secret_scanning_push_protection_enabled_for_new_repositories = $PSBoundParameters.ContainsKey('SecretScanningPushProtectionEnabledForNewRepositories') ? $SecretScanningPushProtectionEnabledForNewRepositories : $null
            secret_scanning_push_protection_custom_link_enabled          = $PSBoundParameters.ContainsKey('SecretScanningPushProtectionCustomLinkEnabled') ? $SecretScanningPushProtectionCustomLinkEnabled : $null
            secret_scanning_push_protection_custom_link                  = $PSBoundParameters.ContainsKey('SecretScanningPushProtectionCustomLink') ? $SecretScanningPushProtectionCustomLink : $null
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'PATCH'
            APIEndpoint = "/orgs/$Name"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("organization [$Name]", 'Set')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                [GitHubOrganization]::new($_.Response, $Context)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Update-GitHubOrganization] - Done"
#endregion [functions] - [public] - [Organization] - [Update-GitHubOrganization]
#region    [functions] - [public] - [Organization] - [Members]
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Members] - Processing folder"
#region    [functions] - [public] - [Organization] - [Members] - [Get-GitHubOrganizationMember]
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Members] - [Get-GitHubOrganizationMember] - Importing"
function Get-GitHubOrganizationMember {
    <#
        .SYNOPSIS
        List organization members

        .DESCRIPTION
        List all users who are members of an organization.
        If the authenticated user is also a member of this organization then both concealed and public members will be returned.

        .OUTPUTS
        GitHubUser

        .NOTES
        [List organization members](https://docs.github.com/rest/orgs/members#list-organization-members)

        .LINK
        https://psmodule.io/GitHub/Functions/Organization/Members/Get-GitHubOrganizationMember
    #>
    [OutputType([GitHubUser])]
    [CmdletBinding()]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [string] $Organization,

        # Filter members returned in the list.
        # `2fa_disabled` means that only members without two-factor authentication enabled will be returned.
        # This options is only available for organization owners.
        [Parameter()]
        [ValidateSet('2fa_disabled', 'all')]
        [string] $Filter = 'all',

        # Filter members returned by their role.
        [Parameter()]
        [ValidateSet('all', 'admin', 'member')]
        [string] $Role = 'all',

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            filter = $Filter
            role   = $Role
        }

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Organization/members"
            Body        = $body
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            foreach ($user in $_.Response) {
                [GitHubUser]::new($user)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Members] - [Get-GitHubOrganizationMember] - Done"
#endregion [functions] - [public] - [Organization] - [Members] - [Get-GitHubOrganizationMember]
#region    [functions] - [public] - [Organization] - [Members] - [Get-GitHubOrganizationPendingInvitation]
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Members] - [Get-GitHubOrganizationPendingInvitation] - Importing"
function Get-GitHubOrganizationPendingInvitation {
    <#
        .SYNOPSIS
        List pending organization invitations

        .DESCRIPTION
        The return hash contains a `role` field which refers to the Organization
        Invitation role and will be one of the following values: `direct_member`, `admin`,
        `billing_manager`, or `hiring_manager`. If the invitee is not a GitHub
        member, the `login` field in the return hash will be `null`.

        .EXAMPLE
        Get-GitHubOrganizationPendingInvitation -Organization 'github'

        List all pending organization invitations for the organization `github`.

        .EXAMPLE
        Get-GitHubOrganizationPendingInvitation -Organization 'github' -Role 'admin'

        List all pending organization invitations for the organization `github` with the role `admin`.

        .NOTES
        [List pending organization invitations](https://docs.github.com/rest/orgs/members#list-pending-organization-invitations)

        .LINK
        https://psmodule.io/GitHub/Functions/Organization/Members/Get-GitHubOrganizationPendingInvitation
    #>
    [CmdletBinding()]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [string] $Organization,

        # Filter invitations by their member role.
        [Parameter()]
        [ValidateSet('all', 'admin', 'direct_member', 'billing_manager', 'hiring_manager')]
        [string] $Role = 'all',

        # Filter invitations by their invitation source.
        [Parameter()]
        [ValidateSet('all', 'member', 'scim')]
        [string] $InvitationSource = 'all',

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            role              = $Role
            invitation_source = $InvitationSource
        }

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Organization/invitations"
            Body        = $body
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Members] - [Get-GitHubOrganizationPendingInvitation] - Done"
#endregion [functions] - [public] - [Organization] - [Members] - [Get-GitHubOrganizationPendingInvitation]
#region    [functions] - [public] - [Organization] - [Members] - [New-GitHubOrganizationInvitation]
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Members] - [New-GitHubOrganizationInvitation] - Importing"
function New-GitHubOrganizationInvitation {
    <#
        .SYNOPSIS
        Create an organization invitation

        .DESCRIPTION
        Invite people to an organization by using their GitHub user ID or their email address. In order to create invitations in an organization,
        the authenticated user must be an organization owner.

        This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
        Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see
        "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
        and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."

        .EXAMPLE
        New-GitHubOrganizationInvitation -Organization 'PSModule' -InviteeID 123456789 -Role 'admin'

        Invites the user with the ID `12345679` to the organization `PSModule` with the role `admin`.

        .EXAMPLE
        New-GitHubOrganizationInvitation -Organization 'PSModule' -Email 'user@psmodule.io'

        Invites the user with the email `user@psmodule.io` to the organization `PSModule`.

        .NOTES
        [Create an organization invitation](https://docs.github.com/rest/orgs/members#list-pending-organization-invitations)

        .LINK
        https://psmodule.io/GitHub/Functions/Organization/Members/New-GitHubOrganizationInvitation
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [string] $Organization,

        # GitHub user ID for the person you are inviting.
        [Parameter(
            Mandatory,
            ParameterSetName = 'UserID'
        )]
        [System.Nullable[int]] $ID,

        # Email address of the person you are inviting, which can be an existing GitHub user.
        [Parameter(
            Mandatory,
            ParameterSetName = 'Email'
        )]
        [string] $Email,

        # The role for the new member.
        #
        # - `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.
        # - `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.
        # - `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization.
        # - `reinstate` - The previous role assigned to the invitee before they were removed from your organization.
        #   Can be one of the roles listed above.
        # Only works if the invitee was previously part of your organization.
        [Parameter()]
        [ValidateSet('admin', 'direct_member', 'billing_manager', 'reinstate')]
        [string] $Role = 'direct_member',

        # Specify IDs for the teams you want to invite new members to.
        [Parameter()]
        [int[]] $TeamIDs,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            invitee_id = $ID
            email      = $Email
            role       = $Role
            team_ids   = $TeamIDs
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/orgs/$Organization/invitations"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("$InviteeID$Email to organization $Organization", 'Invite')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Members] - [New-GitHubOrganizationInvitation] - Done"
#endregion [functions] - [public] - [Organization] - [Members] - [New-GitHubOrganizationInvitation]
#region    [functions] - [public] - [Organization] - [Members] - [Remove-GitHubOrganizationInvitation]
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Members] - [Remove-GitHubOrganizationInvitation] - Importing"
function Remove-GitHubOrganizationInvitation {
    <#
        .SYNOPSIS
        Cancel an organization invitation

        .DESCRIPTION
        Cancel an organization invitation. In order to cancel an organization invitation, the authenticated user must be an organization owner.

        This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).

        .EXAMPLE
        Remove-GitHubOrganizationInvitation -Organization 'github' -InvitationID '12345678'

        Cancel the invitation with the ID '12345678' for the organization `github`.

        .INPUTS
        GitHubOrganization

        .OUTPUTS
        void

        .NOTES
        [Cancel an organization invitation](https://docs.github.com/rest/orgs/members#cancel-an-organization-invitation)

        .LINK
        https://psmodule.io/GitHub/Functions/Organization/Members/Remove-GitHubOrganizationInvitation
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [string] $Organization,

        # The unique identifier of the invitation.
        [Parameter(Mandatory)]
        [Alias('invitation_id', 'InvitationID')]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/orgs/$Organization/invitations/$ID"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess('GitHub Organization invitation', 'Remove')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Members] - [Remove-GitHubOrganizationInvitation] - Done"
#endregion [functions] - [public] - [Organization] - [Members] - [Remove-GitHubOrganizationInvitation]
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - [Members] - Done"
#endregion [functions] - [public] - [Organization] - [Members]
Write-Debug "[$scriptName] - [functions] - [public] - [Organization] - Done"
#endregion [functions] - [public] - [Organization]
#region    [functions] - [public] - [Rate-Limit]
Write-Debug "[$scriptName] - [functions] - [public] - [Rate-Limit] - Processing folder"
#region    [functions] - [public] - [Rate-Limit] - [Get-GitHubRateLimit]
Write-Debug "[$scriptName] - [functions] - [public] - [Rate-Limit] - [Get-GitHubRateLimit] - Importing"
filter Get-GitHubRateLimit {
    <#
        .SYNOPSIS
        Get rate limit status for the authenticated user

        .DESCRIPTION
        **Note:** Accessing this endpoint does not count against your REST API rate limit.

        Some categories of endpoints have custom rate limits that are separate from the rate limit governing the other REST API endpoints.
        For this reason, the API response categorizes your rate limit. Under `resources`, you'll see objects relating to different categories:
        - The `core` object provides your rate limit status for all non-search-related resources in the REST API.
        - The `search` object provides your rate limit status for the REST API for searching (excluding code searches). For more information, see "[Search](https://docs.github.com/rest/search)."
        - The `code_search` object provides your rate limit status for the REST API for searching code. For more information, see "[Search code](https://docs.github.com/rest/search/search#search-code)."
        - The `graphql` object provides your rate limit status for the GraphQL API. For more information, see "[Resource limitations](https://docs.github.com/graphql/overview/resource-limitations#rate-limit)."
        - The `integration_manifest` object provides your rate limit status for the `POST /app-manifests/{code}/conversions` operation. For more information, see "[Creating a GitHub App from a manifest](https://docs.github.com/apps/creating-github-apps/setting-up-a-github-app/creating-a-github-app-from-a-manifest#3-you-exchange-the-temporary-code-to-retrieve-the-app-configuration)."
        - The `dependency_snapshots` object provides your rate limit status for submitting snapshots to the dependency graph. For more information, see "[Dependency graph](https://docs.github.com/rest/dependency-graph)."
        - The `code_scanning_upload` object provides your rate limit status for uploading SARIF results to code scanning. For more information, see "[Uploading a SARIF file to GitHub](https://docs.github.com/code-security/code-scanning/integrating-with-code-scanning/uploading-a-sarif-file-to-github)."
        - The `actions_runner_registration` object provides your rate limit status for registering self-hosted runners in GitHub Actions. For more information, see "[Self-hosted runners](https://docs.github.com/rest/actions/self-hosted-runners)."
        - The `source_import` object is no longer in use for any API endpoints, and it will be removed in the next API version. For more information about API versions, see "[API Versions](https://docs.github.com/rest/overview/api-versions)."

        **Note:** The `rate` object is deprecated. If you're writing new API client code or updating existing code, you should use the `core` object
        instead of the `rate` object. The `core` object contains the same information that is present in the `rate` object.

        .EXAMPLE
        Get-GitHubRateLimit

        Gets the rate limit status for the authenticated user.

        .OUTPUTS
        GitHubRateLimitResource

        .NOTES
        [Get rate limit status for the authenticated user](https://docs.github.com/rest/rate-limit/rate-limit#get-rate-limit-status-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Rate-Limit/Get-GitHubRateLimit
    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [CmdletBinding()]
    param(
        # If specified, makes an anonymous request to the GitHub API without authentication.
        [Parameter()]
        [switch] $Anonymous,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context -Anonymous $Anonymous
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT, Anonymous
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/rate_limit'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response.Resources.PSObject.Properties | ForEach-Object {
                $resource = $_.Value | Add-Member -MemberType NoteProperty -Name 'name' -Value $_.Name -PassThru
                [GitHubRateLimitResource]::new($resource)
            }
            if ($_.Response.Rate) {
                $resource = $_.Response.Rate | Add-Member -MemberType NoteProperty -Name 'name' -Value 'rate' -PassThru
                [GitHubRateLimitResource]::new($resource)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Rate-Limit] - [Get-GitHubRateLimit] - Done"
#endregion [functions] - [public] - [Rate-Limit] - [Get-GitHubRateLimit]
Write-Debug "[$scriptName] - [functions] - [public] - [Rate-Limit] - Done"
#endregion [functions] - [public] - [Rate-Limit]
#region    [functions] - [public] - [Releases]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - Processing folder"
#region    [functions] - [public] - [Releases] - [Get-GitHubRelease]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Get-GitHubRelease] - Importing"
filter Get-GitHubRelease {
    <#
        .SYNOPSIS
        Retrieves GitHub release information for a repository.

        .DESCRIPTION
        This returns a list of releases, which does not include regular Git tags that have not been associated with a release.
        To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/repos/repos#list-repository-tags).
        Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.

        .EXAMPLE
        Get-GitHubRelease -Owner 'octocat' -Repository 'hello-world'

        Gets the latest release for the repository 'hello-world' owned by 'octocat'.

        .EXAMPLE
        Get-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -AllVersions

        Gets all releases for the repository 'hello-world' owned by 'octocat'.

        .EXAMPLE
        Get-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0.0'

        Gets the release with the tag 'v1.0.0' for the repository 'hello-world' owned by 'octocat'.

        .EXAMPLE
        Get-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -ID '1234567'

        Gets the release with the ID '1234567' for the repository 'hello-world' owned by 'octocat'.

        .INPUTS
        GitHubRepository

        .OUTPUTS
        GitHubRelease

        .LINK
        https://psmodule.io/GitHub/Functions/Releases/Get-GitHubRelease/
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSReviewUnusedParameter', 'AllVersions',
        Justification = 'Using the ParameterSetName to determine the context of the command.'
    )]
    [OutputType([GitHubRelease])]
    [CmdletBinding(DefaultParameterSetName = 'Latest')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # Get all releases instead of just the latest.
        [Parameter(Mandatory, ParameterSetName = 'AllVersions')]
        [switch] $AllVersions,

        # The name of the tag to get a release from.
        [Parameter(Mandatory, ParameterSetName = 'Tag')]
        [string] $Tag,

        # The unique identifier of the release.
        [Parameter(Mandatory, ParameterSetName = 'ID')]
        [string] $ID,

        # The number of results per page (max 100).
        [Parameter(ParameterSetName = 'AllVersions')]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $params = @{
            Owner      = $Owner
            Repository = $Repository
            Context    = $Context
        }
        Write-Debug "ParameterSet: $($PSCmdlet.ParameterSetName)"
        switch ($PSCmdlet.ParameterSetName) {
            'AllVersions' {
                Get-GitHubReleaseAll @params -PerPage $PerPage
            }
            'Tag' {
                $release = Get-GitHubReleaseByTagName @params -Tag $Tag
                if ($release) {
                    $release
                } else {
                    Get-GithubReleaseAll @params -PerPage $PerPage | Where-Object { $_.Tag -eq $Tag }
                }
            }
            'ID' {
                Get-GitHubReleaseByID @params -ID $ID
            }
            'Latest' {
                Get-GitHubReleaseLatest @params
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Get-GitHubRelease] - Done"
#endregion [functions] - [public] - [Releases] - [Get-GitHubRelease]
#region    [functions] - [public] - [Releases] - [New-GitHubRelease]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [New-GitHubRelease] - Importing"
filter New-GitHubRelease {
    <#
        .SYNOPSIS
        Create a release

        .DESCRIPTION
        Users with push access to the repository can create a release.
        This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
        Creating content too quickly using this endpoint may result in secondary rate limiting.
        See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
        and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.

        .EXAMPLE
        New-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0.0' -Target 'main' -Notes 'Release notes'

        Creates a release for the repository 'octocat/hello-world' on the 'main' branch with the tag 'v1.0.0'.

        .EXAMPLE
        New-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v0.9.0' -Name 'Beta Release' -Draft -Prerelease

        Creates a draft prerelease for the repository 'octocat/hello-world' with the tag 'v0.9.0' using the default target branch ('main').

        .EXAMPLE
        New-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v2.0.0' -Latest

        Creates a release for the repository 'octocat/hello-world' with the tag 'v2.0.0' and marks it as the latest release.
        Note that when using -Latest, you cannot use -Draft or -Prerelease as they are mutually exclusive.

        .EXAMPLE
        New-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.1.0' -GenerateReleaseNotes

        Creates a release for the repository 'octocat/hello-world' with the tag 'v1.1.0' and automatically generates release notes based on commits since the previous release.

        .EXAMPLE
        New-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.2.0' -DiscussionCategoryName 'Announcements' -Notes 'Major update with new features'

        Creates a release for the repository 'octocat/hello-world' with the tag 'v1.2.0' and creates a discussion in the 'Announcements' category linked to this release.

        .INPUTS
        GitHubRepository

        .OUTPUTS
        GitHubRelease

        .LINK
        https://psmodule.io/GitHub/Functions/Releases/New-GitHubRelease/

        .NOTES
        [Create a release](https://docs.github.com/rest/releases/releases#create-a-release)
    #>
    [OutputType([GitHubRelease])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [CmdletBinding(SupportsShouldProcess, DefaultParameterSetName = 'Not latest')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the tag.
        [Parameter(Mandatory)]
        [string] $Tag,

        # Specifies the reference value that determines where the Git tag is created from.
        # Can be any branch or commit SHA. Unused if the Git tag already exists.
        # API Default: the repository's default branch.
        [Parameter()]
        [string] $Target,

        # The name of the release.
        [Parameter()]
        [string] $Name,

        # Text describing the contents of the tag.
        [Parameter()]
        [string] $Notes,

        # Whether the release is a draft.
        [Parameter(ParameterSetName = 'Not latest')]
        [switch] $Draft,

        # Whether to identify the release as a prerelease.
        [Parameter(ParameterSetName = 'Not latest')]
        [switch] $Prerelease,

        # If specified, a discussion of the specified category is created and linked to the release.
        # The value must be a category that already exists in the repository.
        # For more information, see [Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository).
        [Parameter()]
        [string] $DiscussionCategoryName,

        # Whether to automatically generate the name and body for this release. If name is specified, the specified name will be used; otherwise,
        # a name will be automatically generated. If body is specified, the body will be pre-pended to the automatically generated notes.
        [Parameter()]
        [switch] $GenerateReleaseNotes,

        # Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest.
        # If not specified the latest release is determined based on the release creation date and higher semantic version.
        # If set to true, the release will be set as the latest release for the repository.
        # If set to false, the release will not be set as the latest release for the repository.
        [Parameter(ParameterSetName = 'Set latest')]
        [switch] $Latest,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            tag_name                 = $Tag
            target_commitish         = $Target
            name                     = $Name
            body                     = $Notes
            discussion_category_name = $DiscussionCategoryName
            generate_release_notes   = [bool]$GenerateReleaseNotes
            make_latest              = ([bool]$Latest).ToString().ToLower()
            draft                    = [bool]$Draft
            prerelease               = [bool]$Prerelease
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/repos/$Owner/$Repository/releases"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("$Owner/$Repository", 'Create a release')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                [GitHubRelease]::new($_.Response , $Owner, $Repository, $Latest)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [New-GitHubRelease] - Done"
#endregion [functions] - [public] - [Releases] - [New-GitHubRelease]
#region    [functions] - [public] - [Releases] - [New-GitHubReleaseNote]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [New-GitHubReleaseNote] - Importing"
filter New-GitHubReleaseNote {
    <#
        .SYNOPSIS
        Generate release notes content for a release.

        .DESCRIPTION
        Generate a name and body describing a [release](https://docs.github.com/rest/releases/releases#generate-release-notes-content-for-a-release).
        The body content will be Markdown formatted and contain information like the changes since last release and users who contributed.
        The generated release notes are not saved anywhere. They are intended to be generated and used when creating a new release.

        .EXAMPLE
        $params = @{
            Owner = 'octocat'
            Repository = 'hello-world'
            Tag = 'v1.0.0'
        }
        New-GitHubReleaseNote @params

        Creates a new release notes draft for the repository 'hello-world' owned by 'octocat' with the tag name 'v1.0.0'.
        In this example the tag 'v1.0.0' has to exist in the repository.
        The configuration file '.github/release.yml' or '.github/release.yaml' will be used.

        .EXAMPLE
        $params = @{
            Owner = 'octocat'
            Repository = 'hello-world'
            Tag = 'v1.0.0'
            Target = 'main'
        }
        New-GitHubReleaseNote @params

        Creates a new release notes draft for the repository 'hello-world' owned by 'octocat' with the tag name 'v1.0.0'.
        In this example the tag 'v1.0.0' has to exist in the repository.

        .EXAMPLE
        $params = @{
            Owner = 'octocat'
            Repository = 'hello-world'
            Tag = 'v1.0.0'
            Target = 'main'
            PreviousTag = 'v0.9.2'
            ConfigurationFilePath = '.github/custom_release_config.yml'
        }
        New-GitHubReleaseNote @params

        Creates a new release notes draft for the repository 'hello-world' owned by 'octocat' with the tag name 'v1.0.0'.
        The release notes will be based on the changes between the tags 'v0.9.2' and 'v1.0.0' and generated based on the
        configuration file located in the repository at '.github/custom_release_config.yml'.

        .OUTPUTS
        pscustomobject

        .NOTES
        The returned object contains the following properties:
        - Name: The name of the release.
        - Notes: The body of the release notes.

        .LINK
        https://psmodule.io/GitHub/Functions/Releases/New-GitHubReleaseNote/

        .NOTES
        [Generate release notes content for a release](https://docs.github.com/rest/releases/releases#generate-release-notes-content-for-a-release)
    #>
    [OutputType([pscustomobject])]
    [Alias('Generate-GitHubReleaseNotes')]
    [Alias('New-GitHubReleaseNotes')]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The tag name for the release. This can be an existing tag or a new one.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Tag,

        # Specifies the commitish value that will be the target for the release's tag.
        # Required if the supplied tag_name does not reference an existing tag.
        # Ignored if the tag_name already exists.
        [Parameter()]
        [string] $Target,

        # The name of the previous tag to use as the starting point for the release notes.
        # Use to manually specify the range for the set of changes considered as part this release.
        [Parameter()]
        [string] $PreviousTag,

        # Specifies a path to a file in the repository containing configuration settings used for generating the release notes.
        # If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used.
        # If that is not present, the default configuration will be used.
        [Parameter()]
        [string] $ConfigurationFilePath,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            tag_name                = $Tag
            target_commitish        = $Target
            previous_tag_name       = $PreviousTag
            configuration_file_path = $ConfigurationFilePath
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/repos/$Owner/$Repository/releases/generate-notes"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("release notes for release on $Owner/$Repository", 'Create')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                [PSCustomObject]@{
                    Name  = $_.Response.name
                    Notes = $_.Response.body
                }
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [New-GitHubReleaseNote] - Done"
#endregion [functions] - [public] - [Releases] - [New-GitHubReleaseNote]
#region    [functions] - [public] - [Releases] - [Remove-GitHubRelease]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Remove-GitHubRelease] - Importing"
filter Remove-GitHubRelease {
    <#
        .SYNOPSIS
        Delete a release

        .DESCRIPTION
        Users with push access to the repository can delete a release.

        .EXAMPLE
        Remove-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -ID '1234567'

        Deletes the release with the ID '1234567' for the repository 'octocat/hello-world'.

        .INPUTS
        GitHubRelease

        .OUTPUTS
        None

        .LINK
        https://psmodule.io/GitHub/Functions/Releases/Get-GitHubRelease/

        .NOTES
        [Delete a release](https://docs.github.com/rest/releases/releases#delete-a-release)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The unique identifier of the release.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/repos/$Owner/$Repository/releases/$ID"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Release with ID [$ID] in [$Owner/$Repository]", 'Delete')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Remove-GitHubRelease] - Done"
#endregion [functions] - [public] - [Releases] - [Remove-GitHubRelease]
#region    [functions] - [public] - [Releases] - [Set-GitHubRelease]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Set-GitHubRelease] - Importing"
filter Set-GitHubRelease {
    <#
        .SYNOPSIS
        Creates or updates a release.

        .DESCRIPTION
        The Set-GitHubRelease cmdlet creates a new GitHub release or updates an existing one for a specified tag.

        This function first checks if a release with the specified tag already exists:
        - If the release exists, it will update the existing release with the provided parameters
        - If the release doesn't exist, it will create a new release

        You can specify whether the release is a draft or prerelease, generate release notes automatically,
        link a discussion to the release, and set a release as the latest for the repository.

        When using the 'Latest' parameter, the release will be promoted from draft/prerelease status to a full release.

        .EXAMPLE
        Set-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0.0' -Target 'main' -Notes 'Release notes'

        Creates a new release with tag 'v1.0.0' targeting the 'main' branch.

        .EXAMPLE
        Set-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0.0' -Notes 'Updated release notes'

        Updates an existing release with tag 'v1.0.0' to have new release notes.

        .EXAMPLE
        Set-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0.0' -Draft

        Creates or updates a release as a draft release.

        .EXAMPLE
        Set-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0.0' -Prerelease

        Creates or updates a release as a prerelease.

        .EXAMPLE
        Set-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0.0' -Latest

        Sets the release with tag 'v1.0.0' as the latest release for the repository. If the release was a draft or prerelease,
        it will be promoted to a full release.

        .EXAMPLE
        Set-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0.0' -GenerateReleaseNotes

        Creates or updates a release with automatically generated release notes based on pull requests and commits.

        .EXAMPLE
        Get-GitHubRepository -Owner 'octocat' -Repository 'hello-world' | Set-GitHubRelease -Tag 'v1.0.0' -Notes 'Release notes'

        Creates or updates a release using pipeline input for the repository.

        .INPUTS
        GitHubRepository

        .OUTPUTS
        GitHubRelease

        .LINK
        https://psmodule.io/GitHub/Functions/Releases/Set-GitHubRelease/
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSShouldProcess', '', Scope = 'Function',
        Justification = 'This check is performed in the private functions.'
    )]
    [OutputType([GitHubRelease])]
    [CmdletBinding(SupportsShouldProcess, DefaultParameterSetName = 'Not latest')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the tag.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Tag,

        # Specifies the reference value that determines where the Git tag is created from.
        # Can be any branch or commit SHA. Unused if the Git tag already exists.
        # API Default: the repository's default branch.
        [Parameter()]
        [string] $Target = 'main',

        # The name of the release.
        [Parameter()]
        [string] $Name,

        # Text describing the contents of the tag.
        [Parameter()]
        [string] $Notes,

        # Whether the release is a draft.
        [Parameter(ParameterSetName = 'Not latest')]
        [switch] $Draft,

        # Whether to identify the release as a prerelease.
        [Parameter(ParameterSetName = 'Not latest')]
        [switch] $Prerelease,

        # If specified, a discussion of the specified category is created and linked to the release.
        # The value must be a category that already exists in the repository.
        [Parameter()]
        [string] $DiscussionCategoryName,

        # Whether to automatically generate the name and body for this release. If name is specified, the specified name will be used; otherwise,
        # a name will be automatically generated. If body is specified, the body will be pre-pended to the automatically generated notes.
        [Parameter()]
        [switch] $GenerateReleaseNotes,

        # Specifies whether this release should be set as the latest release for the repository. If the release is a draft or a prerelease, setting
        # this parameters will promote the release to a release, setting the draft and prerelease parameters to false.
        [Parameter(Mandatory, ParameterSetName = 'Set latest')]
        [switch] $Latest,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $scope = @{
            Owner      = $Owner
            Repository = $Repository
            Context    = $Context
        }

        $params = @{
            Tag                    = $Tag
            Target                 = $Target
            Name                   = $Name
            Notes                  = $Notes
            GenerateReleaseNotes   = [bool]$GenerateReleaseNotes
            DiscussionCategoryName = $DiscussionCategoryName
        }

        switch ($PSCmdlet.ParameterSetName) {
            'Set latest' {
                $params['Latest'] = [bool]$Latest
            }
            'Not latest' {
                $params['Draft'] = [bool]$Draft
                $params['Prerelease'] = [bool]$Prerelease
            }
        }

        $release = Get-GitHubRelease @scope -Tag $Tag
        if ($release) {
            $ID = $release.ID
            $params['ID'] = $ID
            Update-GitHubRelease @scope @params -Declare
        } else {
            New-GitHubRelease @scope @params
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Set-GitHubRelease] - Done"
#endregion [functions] - [public] - [Releases] - [Set-GitHubRelease]
#region    [functions] - [public] - [Releases] - [Update-GitHubRelease]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Update-GitHubRelease] - Importing"
filter Update-GitHubRelease {
    <#
        .SYNOPSIS
        Update a release

        .DESCRIPTION
        Users with push access to the repository can edit a release.

        You must specify either the ID or Tag parameter to identify the release to update.
        The function also accepts GitHubRelease objects through the pipeline.

        .EXAMPLE
        Update-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -ID '1234567' -Notes 'Release notes'

        Updates the release with the ID '1234567' for the repository 'octocat/hello-world' with the note 'Release notes'.

        .EXAMPLE
        Update-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0' -Name 'Release v1.0' -Notes 'Stable release'

        Updates the release with the tag 'v1.0' for the repository 'octocat/hello-world' with a new name and notes.

        .EXAMPLE
        Get-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0' |
            Update-GitHubRelease -Draft:$false -Prerelease

        Gets a release by tag and updates it to be a prerelease (not a draft).

        .EXAMPLE
        Update-GitHubRelease -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0' -Latest -GenerateReleaseNotes

        Updates the release with tag 'v1.0' to be the latest release and automatically generates release notes.

        .INPUTS
        GitHubRelease

        .OUTPUTS
        GitHubRelease

        .NOTES
        [Update a release](https://docs.github.com/rest/releases/releases#update-a-release)

        .LINK
        https://psmodule.io/GitHub/Functions/Releases/Update-GitHubRelease
    #>
    [OutputType([GitHubRelease])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [CmdletBinding(SupportsShouldProcess, DefaultParameterSetName = 'Not latest')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The unique identifier of the release.
        [Parameter()]
        [string] $ID,

        # The name of the tag.
        [Parameter()]
        [string] $Tag,

        # Specifies the commitish value that determines where the Git tag is created from.
        # Can be any branch or commit SHA. Unused if the Git tag already exists.
        # API Default: the repository's default branch.
        [Parameter()]
        [string] $Target,

        # The name of the release.
        [Parameter()]
        [string] $Name,

        # Text describing the contents of the tag.
        [Parameter()]
        [string] $Notes,

        # Whether the release is a draft.
        [Parameter(ParameterSetName = 'Not latest')]
        [System.Nullable[switch]] $Draft,

        # Whether to identify the release as a prerelease.
        [Parameter(ParameterSetName = 'Not latest')]
        [System.Nullable[switch]] $Prerelease,

        # If specified, a discussion of the specified category is created and linked to the release.
        # The value must be a category that already exists in the repository.
        # For more information, see [Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository).
        [Parameter()]
        [string] $DiscussionCategoryName,

        # Whether to automatically generate the name and body for this release. If name is specified, the specified name will be used; otherwise,
        # a name will be automatically generated. If body is specified, the body will be pre-pended to the automatically generated notes.
        [Parameter()]
        [switch] $GenerateReleaseNotes,

        # Specifies whether this release should be set as the latest release for the repository. If the release is a draft or a prerelease, setting
        # this parameters will promote the release to a release, setting the draft and prerelease parameters to false.
        [Parameter(Mandatory, ParameterSetName = 'Set latest')]
        [System.Nullable[switch]] $Latest,

        # Takes all parameters and updates the release with the provided _AND_ the default values of the non-provided parameters.
        # Used for Set-GitHubRelease.
        [Parameter()]
        [switch] $Declare,

        # The release to update
        [Parameter(ValueFromPipeline)]
        [GitHubRelease] $ReleaseObject,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $ID = $ReleaseObject.ID

        if (-not $ID -and -not $Tag) {
            throw 'You must specify either the ID or the Tag parameter.'
        }

        if ($GenerateReleaseNotes) {
            $generated = New-GitHubReleaseNote -Owner $Owner -Repository $Repository -Tag $Tag -Context $Context
            $Name = -not [string]::IsNullOrEmpty($Name) ? $Name : $generated.Name
            $Notes = -not [string]::IsNullOrEmpty($Notes) ? $Notes, $generated.Notes -join "`n" : $generated.Notes
        }

        $body = @{
            tag_name         = $Tag
            target_commitish = $Target
            name             = $Name
            body             = $Notes
        }

        if ([string]::IsNullOrEmpty($ID) -and -not [string]::IsNullOrEmpty($Tag)) {
            $release = if ($ReleaseObject) {
                $ReleaseObject
            } else {
                Get-GitHubRelease -Owner $Owner -Repository $Repository -Tag $Tag -Context $Context
            }
            if (-not $release) {
                throw "Release with tag [$Tag] not found in [$Owner/$Repository]."
            }
            $ID = $release.ID
            $body.Remove('tag_name')
        }

        $repo = Get-GitHubRepositoryByName -Owner $Owner -Name $Repository -Context $Context -Property HasDiscussions
        if ($repo.HasDiscussions -and $PSBoundParameters.ContainsKey('DiscussionCategoryName') -and -not [string]::IsNullOrEmpty($DiscussionCategoryName)) {
            $body['discussion_category_name'] = $DiscussionCategoryName
        }
        if (-not $Declare) {
            $body | Remove-HashtableEntry -NullOrEmptyValues
        }

        if ($Latest) {
            $body['make_latest'] = [bool]$Latest.ToString().ToLower()
            $body['prerelease'] = $false
            $body['draft'] = $false
        }
        if ($Draft -or $Prerelease) {
            $body['make_latest'] = $false
            $body['prerelease'] = [bool]$Prerelease
            $body['draft'] = [bool]$Draft
        }

        $apiParams = @{
            Method      = 'PATCH'
            APIEndpoint = "/repos/$Owner/$Repository/releases/$ID"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("release with ID [$ID] in [$Owner/$Repository]", 'Update')) {
            $resultLatest = $PSBoundParameters.ContainsKey('Latest') ? $Latest : $release.IsLatest
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                [GitHubRelease]::new($_.Response , $Owner, $Repository, $resultLatest)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Update-GitHubRelease] - Done"
#endregion [functions] - [public] - [Releases] - [Update-GitHubRelease]
#region    [functions] - [public] - [Releases] - [Assets]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Assets] - Processing folder"
#region    [functions] - [public] - [Releases] - [Assets] - [Add-GitHubReleaseAsset]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Assets] - [Add-GitHubReleaseAsset] - Importing"
filter Add-GitHubReleaseAsset {
    <#
        .SYNOPSIS
        Upload a release asset

        .DESCRIPTION
        This endpoint makes use of [a Hypermedia relation](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia)
        to determine which URL to access. The endpoint you call to upload release assets is specific to your release. Use the
        `upload_url` returned in
        the response of the [Create a release endpoint](https://docs.github.com/rest/releases/releases#create-a-release) to upload
        a release asset.

        You need to use an HTTP client which supports [SNI](http://en.wikipedia.org/wiki/Server_Name_Indication) to make calls to
        this endpoint.

        Most libraries will set the required `Content-Length` header automatically. Use the required `Content-Type` header to provide
        the media type of the asset. For a list of media types, see
        [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example:

        `application/zip`

        GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw binary content of the asset
        as the request body. Everything else about the endpoint is the same as the rest of the API. For example,
        you'll still need to pass your authentication to be able to upload an asset.

        When an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an empty asset with a state
        of `starter`. It can be safely deleted.

        **Notes:**
        * GitHub renames asset filenames that have special characters, non-alphanumeric characters, and leading or trailing periods.
        The "[List release assets](https://docs.github.com/rest/releases/assets#list-release-assets)"
        endpoint lists the renamed filenames. For more information and help, contact
        [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
        * To find the `release_id` query the
        [`GET /repos/{owner}/{repo}/releases/latest` endpoint](https://docs.github.com/rest/releases/releases#get-the-latest-release).
        * If you upload an asset with the same filename as another uploaded asset, you'll receive an error and must delete
        the old file before you can re-upload the new asset.

        .EXAMPLE
        Add-GitHubReleaseAsset -Owner 'octocat' -Repository 'hello-world' -ID '7654321' -Path 'C:\Users\octocat\Downloads\hello-world.zip'

        Gets the release assets for the release with the ID '1234567' for the repository 'octocat/hello-world'.

        .EXAMPLE
        Add-GitHubReleaseAsset -Owner 'octocat' -Repository 'hello-world' -ID '7654321' -Path 'C:\Users\octocat\Projects\MyApp'

        Automatically creates a ZIP file from the contents of the MyApp directory and uploads it as a release asset.

        .INPUTS
        GitHubRelease

        .OUTPUTS
        GitHubReleaseAsset

        .LINK
        https://psmodule.io/GitHub/Functions/Releases/Assets/Add-GitHubReleaseAsset/

        .NOTES
        [Upload a release asset](https://docs.github.com/rest/releases/assets#upload-a-release-asset)
    #>
    [OutputType([GitHubReleaseAsset])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the tag to get a release from.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Tag,

        #The name of the file asset.
        [Parameter()]
        [string] $Name,

        # An alternate short description of the asset. Used in place of the filename.
        [Parameter()]
        [string] $Label,

        # The path to the asset file.
        [Parameter(Mandatory)]
        [alias('FullName')]
        [string] $Path,

        # The 'Content-Type' for the payload.
        [Parameter()]
        [string] $ContentType,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        try {
            $item = Get-Item $Path
            $isDirectory = $item.PSIsContainer
        } catch {
            throw "Error accessing the path: $_"
        }
        $fileToUpload = $Path
        # If the path is a directory, create a zip file from the contents of the folder
        if ($isDirectory) {
            Write-Verbose 'Path is a directory. Zipping contents...'
            $dirName = $item.Name
            $TempFilePath = "$dirName.zip"

            Write-Verbose "Creating temporary zip file: $TempFilePath"
            try {
                Get-ChildItem -Path $Path | Compress-Archive -DestinationPath $TempFilePath -ErrorAction Stop -Force
                $fileToUpload = $TempFilePath
            } catch {
                Remove-Item -Path $TempFilePath -Force -ErrorAction SilentlyContinue
            }
        }
        if (!$Name) {
            $Name = $item.Name
        }
        if (!$Label) {
            $Label = $item.Name
        }

        if (!$ContentType) {
            $ContentType = switch ((Get-Item $fileToUpload).Extension) {
                '.zip' { 'application/zip' }
                '.tar' { 'application/x-tar' }
                '.gz' { 'application/gzip' }
                '.bz2' { 'application/x-bzip2' }
                '.xz' { 'application/x-xz' }
                '.7z' { 'application/x-7z-compressed' }
                '.rar' { 'application/vnd.rar' }
                '.tar.gz' { 'application/gzip' }
                '.tgz' { 'application/gzip' }
                '.tar.bz2' { 'application/x-bzip2' }
                '.tar.xz' { 'application/x-xz' }
                '.tar.7z' { 'application/x-7z-compressed' }
                '.tar.rar' { 'application/vnd.rar' }
                '.png' { 'image/png' }
                '.json' { 'application/json' }
                '.txt' { 'text/plain' }
                '.md' { 'text/markdown' }
                '.html' { 'text/html' }
                default { 'application/octet-stream' }
            }
        }

        $release = Get-GitHubReleaseByTagName -Owner $Owner -Repository $Repository -Tag $Tag -Context $Context

        $body = @{
            name  = $Name
            label = $Label
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $urlParams = @{
            BaseUri = "https://uploads.$($Context.HostName)"
            Path    = "/repos/$Owner/$Repository/releases/$($release.id)/assets"
            Query   = $body
        }
        $uploadUrl = New-Uri @urlParams

        $apiParams = @{
            Method         = 'POST'
            Uri            = $uploadUrl
            ContentType    = $ContentType
            UploadFilePath = $fileToUpload
            Context        = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubReleaseAsset]::new($_.Response)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }

    clean {
        if ($isDirectory) {
            Write-Verbose "Cleaning up temporary zip file: $TempFilePath"
            Remove-Item -Path $TempFilePath -Force -ErrorAction SilentlyContinue
        }
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Assets] - [Add-GitHubReleaseAsset] - Done"
#endregion [functions] - [public] - [Releases] - [Assets] - [Add-GitHubReleaseAsset]
#region    [functions] - [public] - [Releases] - [Assets] - [Get-GitHubReleaseAsset]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Assets] - [Get-GitHubReleaseAsset] - Importing"
filter Get-GitHubReleaseAsset {
    <#
        .SYNOPSIS
        List release assets based on a release ID, asset ID, or asset name

        .DESCRIPTION
        If an asset ID is provided, the asset is returned.
        If a release ID is provided, all assets for the release are returned.
        If a release ID and name are provided, the specific named asset from that release is returned.
        If a tag and name are provided, the specific named asset from the release with that tag is returned.

        .EXAMPLE
        Get-GitHubReleaseAsset -Owner 'octocat' -Repository 'hello-world' -ID '1234567'

        Gets the release asset with the ID '1234567' for the repository 'octocat/hello-world'.

        .EXAMPLE
        Get-GitHubReleaseAsset -Owner 'octocat' -Repository 'hello-world' -ReleaseID '7654321'

        Gets all release assets for the release with the ID '7654321' for the repository 'octocat/hello-world'.

        .EXAMPLE
        Get-GitHubReleaseAsset -Owner 'octocat' -Repository 'hello-world' -ReleaseID '7654321' -Name 'example.zip'

        Gets the release asset named 'example.zip' from the release with ID '7654321' for the repository 'octocat/hello-world'.

        .EXAMPLE
        Get-GitHubReleaseAsset -Owner 'octocat' -Repository 'hello-world' -Tag 'v1.0.0' -Name 'example.zip'

        Gets the release asset named 'example.zip' from the release tagged as 'v1.0.0' for the repository 'octocat/hello-world'.

        .INPUTS
        GitHubRelease

        .OUTPUTS
        GitHubReleaseAsset

        .LINK
        https://psmodule.io/GitHub/Functions/Releases/Assets/Get-GitHubReleaseAsset
    #>
    [OutputType([GitHubReleaseAsset])]
    [CmdletBinding(DefaultParameterSetName = 'List assets from the latest release')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The unique identifier of the asset.
        [Parameter(Mandatory, ParameterSetName = 'Get a specific asset by ID')]
        [string] $ID,

        # The unique identifier of the release.
        [Parameter(Mandatory, ParameterSetName = 'List assets from a release by ID', ValueFromPipelineByPropertyName)]
        [Alias('Release')]
        [string] $ReleaseID,

        # The tag name of the release.
        [Parameter(Mandatory, ParameterSetName = 'List assets from a release by tag')]
        [string] $Tag,

        # The name of the asset to get. If specified, only assets with this name will be returned.
        [Parameter()]
        [string] $Name,

        # The number of results per page (max 100).
        [Parameter(ParameterSetName = 'List assets from the latest release')]
        [Parameter(ParameterSetName = 'List assets from a release by ID')]
        [Parameter(ParameterSetName = 'List assets from a release by tag')]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $params = @{
            Owner      = $Owner
            Repository = $Repository
            Context    = $Context
            Name       = $Name
        }
        $params | Remove-HashtableEntry -NullOrEmptyValues

        switch ($PSCmdlet.ParameterSetName) {
            'List assets from the latest release' {
                Get-GitHubReleaseAssetFromLatest @params -PerPage $PerPage
            }
            'List assets from a release by ID' {
                Get-GitHubReleaseAssetByReleaseID @params -ID $ReleaseID -PerPage $PerPage
            }
            'List assets from a release by tag' {
                Get-GitHubReleaseAssetByTag @params -Tag $Tag -PerPage $PerPage
            }
            'Get a specific asset by ID' {
                Get-GitHubReleaseAssetByID @params -ID $ID
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Assets] - [Get-GitHubReleaseAsset] - Done"
#endregion [functions] - [public] - [Releases] - [Assets] - [Get-GitHubReleaseAsset]
#region    [functions] - [public] - [Releases] - [Assets] - [Remove-GitHubReleaseAsset]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Assets] - [Remove-GitHubReleaseAsset] - Importing"
filter Remove-GitHubReleaseAsset {
    <#
        .SYNOPSIS
        Delete a release asset

        .DESCRIPTION
        Delete a release asset

        .EXAMPLE
        Remove-GitHubReleaseAsset -Owner 'octocat' -Repository 'hello-world' -ID '1234567'

        Deletes the release asset with the ID '1234567' for the repository 'octocat/hello-world'.

        .INPUTS
        GitHubReleaseAsset

        .LINK
        https://psmodule.io/GitHub/Functions/Releases/Assets/Remove-GitHubReleaseAsset

        .NOTES
        [Delete a release asset](https://docs.github.com/rest/releases/assets#delete-a-release-asset)
    #>
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The unique identifier of the asset.
        [Parameter(Mandatory)]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/repos/$Owner/$Repository/releases/assets/$ID"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Asset with ID [$ID] in [$Owner/$Repository]", 'DELETE')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Assets] - [Remove-GitHubReleaseAsset] - Done"
#endregion [functions] - [public] - [Releases] - [Assets] - [Remove-GitHubReleaseAsset]
#region    [functions] - [public] - [Releases] - [Assets] - [Save-GitHubReleaseAsset]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Assets] - [Save-GitHubReleaseAsset] - Importing"
function Save-GitHubReleaseAsset {
    <#
        .SYNOPSIS
        Downloads a GitHub Release asset.

        .DESCRIPTION
        Downloads an asset from a repository release. The asset is downloaded as a file to the specified path
        or the current directory by default. Users must have read access to the repository. For private repositories,
        personal access tokens (classic) or OAuth tokens with the `repo` scope are required.

        .EXAMPLE
        Save-GitHubReleaseAsset -Owner 'octocat' -Repository 'Hello-World' -ID '123456' -Path 'C:\Assets'

        Output:
        ```powershell
        Directory: C:\Assets

        Mode                 LastWriteTime         Length Name
        ----                 -------------         ------ ----
        -a----        03/31/2025     12:00       4194304 asset-123456.zip
        ```

        Downloads release asset ID '123456' from the 'Hello-World' repository owned by 'octocat' to the specified path.

        .EXAMPLE
        Save-GitHubReleaseAsset -Owner 'octocat' -Repository 'Hello-World' -Tag 'v1.0.0' -Name 'binary.zip' -Path 'C:\Assets\app' -Expand -Force

        Output:
        ```powershell
        Directory: C:\Assets\app

        Mode                 LastWriteTime         Length Name
        ----                 -------------         ------ ----
        -a----        03/31/2025     12:00          5120 config.json
        -a----        03/31/2025     12:00       4194304 application.exe
        ```

        Downloads asset named 'binary.zip' from the release tagged as 'v1.0.0' in the 'Hello-World' repository owned by 'octocat'
        to the specified path, overwriting existing files during download and extraction.

        .EXAMPLE
        $params = @{
            Owner         = 'octocat'
            Repository    = 'Hello-World'
            ID            = '123456'
            Tag           = 'v1.0.0'
            Name          = 'binary.zip'
        }
        Get-GitHubReleaseAsset @params | Save-GitHubReleaseAsset -Path 'C:\Assets' -Expand -Force

        Pipes a release asset object directly to the Save-GitHubReleaseAsset function, which downloads and extracts it.

        .INPUTS
        GitHubReleaseAsset

        .OUTPUTS
        System.IO.FileSystemInfo[]

        .NOTES
        Contains the extracted file or folder information from the downloaded asset.
        This output can include directories or files depending on the asset content.

        .LINK
        https://psmodule.io/GitHub/Functions/Releases/Assets/Save-GitHubReleaseAsset/
    #>
    [OutputType([System.IO.FileSystemInfo[]])]
    [CmdletBinding(DefaultParameterSetName = 'By Asset ID')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'By Asset ID')]
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'By Release ID and Asset Name')]
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'By Tag and Asset Name')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'By Asset ID')]
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'By Release ID and Asset Name')]
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'By Tag and Asset Name')]
        [string] $Repository,

        # The unique identifier of the asset.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'By Asset ID')]
        [string] $ID,

        # The unique identifier of the release.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'By Release ID and Asset Name')]
        [string] $ReleaseID,

        # The tag name of the release.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'By Tag and Asset Name')]
        [string] $Tag,

        # The name of the asset to download.
        [Parameter(Mandatory, ParameterSetName = 'By Release ID and Asset Name')]
        [Parameter(Mandatory, ParameterSetName = 'By Tag and Asset Name')]
        [string] $Name,

        # The GitHubReleaseAsset object containing the information about the asset to download.
        [Parameter(Mandatory, ValueFromPipeline, ParameterSetName = 'By Asset Object')]
        [GitHubReleaseAsset] $ReleaseAssetObject,

        # Path to the file or folder for the download. Accepts relative or absolute paths.
        [Parameter()]
        [string] $Path = $PWD.Path,

        # When specified, the ZIP file is extracted to the same directory it was downloaded to.
        [Parameter()]
        [Alias('Extract')]
        [switch] $Expand,

        # When specified, overwrites existing files during download and extraction.
        [Parameter()]
        [switch] $Force,

        # When specified, the downloaded file or the folder where the ZIP file was extracted to is returned.
        [Parameter()]
        [switch] $PassThru,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $asset = $null

        switch ($PSCmdlet.ParameterSetName) {
            'By Asset ID' {
                $asset = Get-GitHubReleaseAsset -Owner $Owner -Repository $Repository -ID $ID -Context $Context
            }
            'By Release ID and Asset Name' {
                $asset = Get-GitHubReleaseAsset -Owner $Owner -Repository $Repository -ReleaseID $ReleaseID -Name $Name -Context $Context
            }
            'By Tag and Asset Name' {
                $asset = Get-GitHubReleaseAsset -Owner $Owner -Repository $Repository -Tag $Tag -Name $Name -Context $Context
            }
            'By Asset Object' {
                $asset = $ReleaseAssetObject
            }
        }

        if (-not $asset) {
            throw 'Release asset not found. Please verify the parameters provided.'
        }

        # Now download the asset
        $apiParams = @{
            Method  = 'GET'
            Uri     = $asset.Url
            Context = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $itemType = $Path.EndsWith('.zip') ? 'File' : 'Directory'
            $isAbsolute = [System.IO.Path]::IsPathRooted($Path)
            $filename = $asset.Name

            Write-Debug "Path:        [$Path]"
            Write-Debug "Type:        [$itemType]"
            Write-Debug "Is absolute: [$isAbsolute]"
            Write-Debug "Filename:    [$filename]"

            if ($itemType -eq 'Directory') {
                $Path = Join-Path -Path $Path -ChildPath $filename
            }

            $folderPath = [System.IO.Path]::GetDirectoryName($Path)
            $folder = New-Item -Path $folderPath -ItemType Directory -Force
            Write-Debug "Resolved final download path: [$Path]"
            [System.IO.File]::WriteAllBytes($Path, $_.Response)

            # Check if we need to expand the downloaded file
            if ($Expand -and $filename -match '\.(zip|tar|gz|bz2|xz|7z|rar)$') {
                Write-Debug "Expanding asset to [$folder]"
                Expand-Archive -LiteralPath $Path -DestinationPath $folder -Force:$Force
                Write-Debug "Removing ZIP file [$Path]"
                Remove-Item -LiteralPath $Path -Force
                if ($PassThru) {
                    return $folder
                }
            }
            if ($PassThru) {
                return Get-Item -Path $Path
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Assets] - [Save-GitHubReleaseAsset] - Done"
#endregion [functions] - [public] - [Releases] - [Assets] - [Save-GitHubReleaseAsset]
#region    [functions] - [public] - [Releases] - [Assets] - [Update-GitHubReleaseAsset]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Assets] - [Update-GitHubReleaseAsset] - Importing"
filter Update-GitHubReleaseAsset {
    <#
        .SYNOPSIS
        Update a release asset

        .DESCRIPTION
        Users with push access to the repository can edit a release asset.

        .EXAMPLE
        Update-GitHubReleaseAsset -Owner 'octocat' -Repository 'hello-world' -ID '1234567' -Name 'new_asset_name' -Label 'new_asset_label'

        Updates the release asset with the ID '1234567' for the repository 'octocat/hello-world' with the new name 'new_asset_name' and
        label 'new_asset_label'.

        .INPUTS
        GitHubReleaseAsset

        .OUTPUTS
        GitHubReleaseAsset

        .LINK
        https://psmodule.io/GitHub/Functions/Releases/Assets/Update-GitHubReleaseAsset

        .NOTES
        [Update a release asset](https://docs.github.com/rest/releases/assets#update-a-release-asset)
    #>
    [OutputType([GitHubReleaseAsset])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter()]
        [string] $Repository,

        # The unique identifier of the asset.
        [Parameter(Mandatory)]
        [string] $ID,

        #The name of the file asset.
        [Parameter()]
        [string] $Name,

        # An alternate short description of the asset. Used in place of the filename.
        [Parameter()]
        [string] $Label,

        # State of the release asset.
        [Parameter()]
        [ValidateSet('uploaded', 'open')]
        [string] $State,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            name  = $Name
            label = $Label
            state = $State
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'PATCH'
            APIEndpoint = "/repos/$Owner/$Repository/releases/assets/$ID"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("assets for release with ID [$ID] in [$Owner/$Repository]", 'Set')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                [GitHubReleaseAsset]::new($_.Response)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Assets] - [Update-GitHubReleaseAsset] - Done"
#endregion [functions] - [public] - [Releases] - [Assets] - [Update-GitHubReleaseAsset]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - [Assets] - Done"
#endregion [functions] - [public] - [Releases] - [Assets]
Write-Debug "[$scriptName] - [functions] - [public] - [Releases] - Done"
#endregion [functions] - [public] - [Releases]
#region    [functions] - [public] - [Repositories]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - Processing folder"
#region    [functions] - [public] - [Repositories] - [completers]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [completers] - Importing"
Register-ArgumentCompleter -CommandName New-GitHubRepository -ParameterName Gitignore -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters
    Get-GitHubGitignore | Select-Object -ExpandProperty name | Where-Object { $_ -like "*$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}

Register-ArgumentCompleter -CommandName New-GitHubRepository -ParameterName License -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters
    Get-GitHubLicense | Select-Object -ExpandProperty name | Where-Object { $_ -like "*$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}

Register-ArgumentCompleter -CommandName Get-GitHubRepository -ParameterName AdditionalProperty -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters
    [GitHubRepository].GetProperties().Name | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}

Register-ArgumentCompleter -CommandName Get-GitHubRepository -ParameterName Property -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters
    [GitHubRepository].GetProperties().Name | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}

Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport) -ParameterName Repository -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters
    $params = @{
        Property = 'Name'
        Verbose  = $false
        Debug    = $false
    }
    if ($fakeBoundParameters.ContainsKey('Owner')) {
        $params['Owner'] = $fakeBoundParameters.Owner
    } elseif ($fakeBoundParameters.ContainsKey('Organization')) {
        $params['Owner'] = $fakeBoundParameters.Organization
    }
    (Get-GitHubRepository @params).Name | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}

Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport |
        Where-Object { $_ -like '*GitHubRepository' }) -ParameterName Name -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters
    $params = @{
        Property = 'Name'
        Verbose  = $false
        Debug    = $false
    }
    if ($fakeBoundParameters.ContainsKey('Owner')) {
        $params['Owner'] = $fakeBoundParameters.Owner
    } elseif ($fakeBoundParameters.ContainsKey('Organization')) {
        $params['Owner'] = $fakeBoundParameters.Organization
    }
    (Get-GitHubRepository @params).Name | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [completers] - Done"
#endregion [functions] - [public] - [Repositories] - [completers]
#region    [functions] - [public] - [Repositories] - [Get-GitHubRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Get-GitHubRepository] - Importing"
filter Get-GitHubRepository {
    <#
        .SYNOPSIS
        Gets a specific repository or list of repositories.

        .DESCRIPTION
        Gets a specific repository or list of repositories.
        If no parameters are specified, the authenticated user's repositories are returned.
        If a username is specified, the user's public repositories are returned.
        If an organization is specified, the organization's public repositories are returned.
        Can also be used with the name parameter to get a specific repository.

        .EXAMPLE
        Get-GitHubRepository

        Gets the repositories for the authenticated user.

        .EXAMPLE
        Get-GitHubRepository -Username 'octocat'

        Gets the repositories for the specified user.

        .EXAMPLE
        Get-GitHubRepository -Organization 'github' -Name 'octocat'

        Gets the specified repository.

        .EXAMPLE
        Get-GitHubRepository -Organization 'github' -Team 'my-team'

        Gets repositories that the 'my-team' team has access to in the `github` organization.

        .EXAMPLE
        Get-GitHubRepository -Organization 'github' -Name 'octocat' -Team 'my-team'

        Gets the repository and permission for the `my-team` team on the `octocat` repository in the `github` organization.

        .INPUTS
        GitHubOwner

        .OUTPUTS
        GithubRepository

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Get-GitHubRepository/
    #>
    [OutputType([GitHubRepository])]
    [CmdletBinding(DefaultParameterSetName = 'List repositories for the authenticated user')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Get a repository by name')]
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'List repositories from an account')]
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Get the repository and permission for the specified team')]
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'List repositories for a team')]
        [Alias('Organization', 'Username')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Get a repository by name')]
        [Parameter(Mandatory, ParameterSetName = 'Get a repository for the authenticated user by name')]
        [Parameter(Mandatory, ParameterSetName = 'Get the repository and permission for the specified team')]
        [string] $Name,

        # The slug of the team.
        [Parameter(Mandatory, ParameterSetName = 'Get the repository and permission for the specified team')]
        [Parameter(Mandatory, ParameterSetName = 'List repositories for a team')]
        [string] $Team,

        # Limit the results to repositories with a visibility level.
        [Parameter(ParameterSetName = 'List repositories for the authenticated user')]
        [Parameter(ParameterSetName = 'List repositories from an account')]
        [ValidateSet('Internal', 'Private', 'Public')]
        [string] $Visibility,

        # Limit the results to repositories where the user has this role.
        [Parameter(ParameterSetName = 'List repositories for the authenticated user')]
        [Parameter(ParameterSetName = 'List repositories from an account')]
        [ValidateSet('Owner', 'Collaborator', 'Organization_member')]
        [string[]] $Affiliation,

        # Properties to include in the returned object.
        [Parameter()]
        [string[]] $Property,

        # Additional properties to include in the returned object. Is added to the list of properties to include.
        # This is useful for properties that are not included in the default list of properties.
        [Parameter()]
        [string[]] $AdditionalProperty,

        # The number of results per page (max 100).
        [Parameter(ParameterSetName = 'List repositories for the authenticated user')]
        [Parameter(ParameterSetName = 'List repositories from an account')]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $params = @{
            Context            = $Context
            Owner              = $Owner
            Name               = $Name
            Team               = $Team
            Affiliation        = $Affiliation
            Visibility         = $Visibility
            PerPage            = $PerPage
            Property           = $Property
            AdditionalProperty = $AdditionalProperty
        }
        $params | Remove-HashtableEntry -NullOrEmptyValues
        if ($DebugPreference -eq 'Continue') {
            Write-Debug "ParamSet: [$($PSCmdlet.ParameterSetName)]"
            [pscustomobject]$params | Format-List | Out-String -Stream | ForEach-Object { Write-Debug $_ }
        }
        switch ($PSCmdlet.ParameterSetName) {
            'Get a repository for the authenticated user by name' {
                try {
                    Get-GitHubMyRepositoryByName @params
                } catch { return }
            }
            'List repositories for the authenticated user' {
                Get-GitHubMyRepositories @params
            }
            'Get a repository by name' {
                try {
                    Get-GitHubRepositoryByName @params
                } catch { return }
            }
            'List repositories from an account' {
                Get-GitHubRepositoryListByOwner @params
            }
            'List repositories for a team' {
                try {
                    Get-GitHubRepositoryListByTeam @params
                } catch { return }
            }
            'Get the repository and permission for the specified team' {
                try {
                    Get-GitHubRepositoryByNameAndTeam @params
                } catch { return }
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Get-GitHubRepository] - Done"
#endregion [functions] - [public] - [Repositories] - [Get-GitHubRepository]
#region    [functions] - [public] - [Repositories] - [Move-GitHubRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Move-GitHubRepository] - Importing"
filter Move-GitHubRepository {
    <#
        .SYNOPSIS
        Transfer a repository

        .DESCRIPTION
        A transfer request will need to be accepted by the new owner when transferring a personal repository to another user.
        The response will contain the original `owner`, and the transfer will continue asynchronously. For more details on
        the requirements to transfer personal and organization-owned repositories, see
        [about repository transfers](https://docs.github.com/articles/about-repository-transfers/).
        You must use a personal access token (classic) or an OAuth token for this endpoint. An installation access token or
        a fine-grained personal access token cannot be used because they are only granted access to a single account.

        .EXAMPLE
        Move-GitHubRepository -Owner 'PSModule' -Name 'GitHub' -NewOwner 'GitHub' -NewName 'PowerShell'

        Moves the GitHub repository to the PSModule organization and renames it to GitHub.

        .INPUTS
        GitHubRepository

        .OUTPUTS
        GitHubRepository

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Move-GitHubRepository/

        .NOTES
        [Transfer a repository](https://docs.github.com/rest/repos/repos#transfer-a-repository)
    #>
    [OutputType([GitHubRepository])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Name,

        # The username or organization name the repository will be transferred to.
        [Parameter(Mandatory)]
        [string] $NewOwner,

        # The new name to be given to the repository.
        [Parameter()]
        [string] $NewName,

        # ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
        [Parameter()]
        [int[]] $TeamIds,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            new_owner = $NewOwner
            new_name  = $NewName
            team_ids  = $TeamIds
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/repos/$Owner/$Name/transfer"
            Body        = $body
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubRepository]::New($_.Response)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Move-GitHubRepository] - Done"
#endregion [functions] - [public] - [Repositories] - [Move-GitHubRepository]
#region    [functions] - [public] - [Repositories] - [New-GitHubRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [New-GitHubRepository] - Importing"
filter New-GitHubRepository {
    <#
        .SYNOPSIS
        Create a repository for a user or an organization.

        .DESCRIPTION
        Creates a new repository for a user or in a specified organization.

        **OAuth scope requirements**

        When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:

        * `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
        * `repo` scope to create a private repository

        .EXAMPLE
        $params = @{
            Name                     = 'Hello-World'
            Description              = 'This is your first repository'
            Homepage                 = 'https://github.com'
            HasIssues                = $true
            HasProjects              = $true
            HasWiki                  = $true
            HasDiscussions           = $true
            IsTemplate               = $true
            AddReadme                = $true
            AllowSquashMerge         = $true
            AllowAutoMerge           = $true
            DeleteBranchOnMerge      = $true
            SquashMergeCommitTitle   = 'PR_TITLE'
            SquashMergeCommitMessage = 'PR_BODY'
        }
        New-GitHubRepository @params

        Creates a new public repository named "Hello-World" owned by the authenticated user.

        .EXAMPLE
        $params = @{
            Organization             = 'PSModule'
            Name                     = 'Hello-World'
            Description              = 'This is your first repository'
            Homepage                 = 'https://github.com'
            HasIssues                = $true
            HasProjects              = $true
            HasWiki                  = $true
            IsTemplate               = $true
            AddReadme                = $true
            AllowSquashMerge         = $true
            AllowAutoMerge           = $true
            DeleteBranchOnMerge      = $true
            SquashMergeCommitTitle   = 'PR_TITLE'
            SquashMergeCommitMessage = 'PR_BODY'
        }
        New-GitHubRepository @params

        Creates a new public repository named "Hello-World" owned by the organization "PSModule".

        .EXAMPLE
        $params = @{
            TemplateOwner      = 'GitHub'
            TemplateRepository = 'octocat'
            Organization       = 'PSModule'
            Name               = 'MyNewRepo'
            IncludeAllBranches = $true
            Description        = 'My new repo'
            Visibility         = 'Private'
        }
        New-GitHubRepository @params

        Creates a new private repository named `MyNewRepo` from the `octocat` template repository owned by `GitHub`.

        .EXAMPLE
        $params = @{
            ForkOwner         = 'octocat'
            ForkRepo          = 'Hello-World'
            Organization      = 'PSModule'
            Name              = 'MyNewRepo'
            DefaultBranchOnly = $true
        }
        New-GitHubRepository @params

        Creates a new repository named `MyNewRepo` as a fork of `Hello-World` owned by `octocat`.
        Only the default branch will be forked.

        .OUTPUTS
        GitHubRepository

        .NOTES
        [Create a repository for the authenticated user](https://docs.github.com/rest/repos/repos#create-a-repository-for-the-authenticated-user)
        [Create an organization repository](https://docs.github.com/rest/repos/repos#create-an-organization-repository)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/New-GitHubRepository/
    #>
    [OutputType([GitHubRepository])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSShouldProcess', '', Scope = 'Function',
        Justification = 'This check is performed in the private functions.'
    )]
    [CmdletBinding(SupportsShouldProcess, DefaultParameterSetName = 'Create a repository for the authenticated user')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Create a repository in an organization')]
        [Parameter(Mandatory, ParameterSetName = 'Fork a repository to an organization')]
        [Parameter(Mandatory, ParameterSetName = 'Create a repository from a template to an organization')]
        [Alias('Owner')]
        [string] $Organization,

        # The name of the repository.
        [Parameter(Mandatory, ParameterSetName = 'Create a repository from a template to a user')]
        [Parameter(Mandatory, ParameterSetName = 'Create a repository from a template to an organization')]
        [Parameter(Mandatory, ParameterSetName = 'Create a repository for the authenticated user')]
        [Parameter(Mandatory, ParameterSetName = 'Create a repository in an organization')]
        [Parameter(ParameterSetName = 'Fork a repository to a user')]
        [Parameter(ParameterSetName = 'Fork a repository to an organization')]
        [string] $Name,

        # The account owner of the template repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Create a repository from a template to a user')]
        [Parameter(Mandatory, ParameterSetName = 'Create a repository from a template to an organization')]
        [string] $TemplateOwner,

        # The name of the template repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Create a repository from a template to a user')]
        [Parameter(Mandatory, ParameterSetName = 'Create a repository from a template to an organization')]
        [string] $TemplateRepository,

        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Fork a repository to a user')]
        [Parameter(Mandatory, ParameterSetName = 'Fork a repository to an organization')]
        [string] $ForkOwner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Fork a repository to a user')]
        [Parameter(Mandatory, ParameterSetName = 'Fork a repository to an organization')]
        [string] $ForkRepository,

        # Include all branches from the source repository.
        [Parameter(ParameterSetName = 'Create a repository from a template to a user')]
        [Parameter(ParameterSetName = 'Create a repository from a template to an organization')]
        [Parameter(ParameterSetName = 'Fork a repository to a user')]
        [Parameter(ParameterSetName = 'Fork a repository to an organization')]
        [switch] $IncludeAllBranches,

        # Pass true to create an initial commit with empty README.
        [Parameter(ParameterSetName = 'Create a repository for the authenticated user')]
        [Parameter(ParameterSetName = 'Create a repository in an organization')]
        [switch] $AddReadme,

        # The desired language or platform to apply to the .gitignore.
        [Parameter(ParameterSetName = 'Create a repository for the authenticated user')]
        [Parameter(ParameterSetName = 'Create a repository in an organization')]
        [string] $Gitignore,

        # The license keyword of the open source license for this repository.
        [Parameter(ParameterSetName = 'Create a repository for the authenticated user')]
        [Parameter(ParameterSetName = 'Create a repository in an organization')]
        [string] $License,

        # The visibility of the repository.
        [Parameter(ParameterSetName = 'Create a repository for the authenticated user')]
        [Parameter(ParameterSetName = 'Create a repository in an organization')]
        [Parameter(ParameterSetName = 'Create a repository from a template to an organization')]
        [Parameter(ParameterSetName = 'Create a repository from a template to a user')]
        [ValidateSet('Public', 'Private', 'Internal')]
        [string] $Visibility = 'Public',

        # A short description of the new repository.
        [Parameter()]
        [string] $Description,

        # A URL with more information about the repository.
        [Parameter()]
        [uri] $Homepage,

        # Whether the repository is archived.
        [Parameter()]
        [System.Nullable[bool]] $IsArchived,

        # Whether this repository acts as a template that can be used to generate new repositories.
        [Parameter()]
        [System.Nullable[bool]] $IsTemplate,

        # Whether to require contributors to sign off on web-based commits.
        [Parameter()]
        [System.Nullable[bool]] $WebCommitSignoffRequired,

        # Updates the default branch for this repository.
        [Parameter()]
        [string] $DefaultBranch,

        # Whether the wiki is enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasWiki,

        # Whether issues are enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasIssues,

        # Either true to allow private forks, or false to prevent private forks.
        [Parameter(ParameterSetName = 'Fork a repository to an organization')]
        [Parameter(ParameterSetName = 'Create a repository from a template to an organization')]
        [Parameter(ParameterSetName = 'Create a repository in an organization')]
        [System.Nullable[bool]] $AllowForking,

        # Whether sponsorships are enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasSponsorships,

        # Whether discussions are enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasDiscussions,

        # Whether projects are enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasProjects,

        # Allow merge commits for pull requests with the specified setting.
        [Parameter()]
        [ValidateSet('', 'Default message', 'Pull request title', 'Pull request title and description')]
        [string] $AllowMergeCommitWith = 'Default message',

        # Allow squash merges for pull requests with the specified setting.
        [Parameter()]
        [ValidateSet('', 'Default message', 'Pull request title', 'Pull request title and description', 'Pull request title and commit details')]
        [string] $AllowSquashMergingWith = 'Default message',

        # Whether to allow rebase merges for pull requests.
        [Parameter()]
        [System.Nullable[bool]] $AllowRebaseMerging,

        # Whether to always suggest to update a head branch that is behind its base branch during a pull request.
        [Parameter()]
        [System.Nullable[bool]] $SuggestUpdateBranch,

        # Whether to allow Auto-merge to be used on pull requests.
        [Parameter()]
        [System.Nullable[bool]] $AllowAutoMerge,

        # Whether to delete head branches when pull requests are merged
        [Parameter()]
        [System.Nullable[bool]] $DeleteBranchOnMerge,

        # Whether to enable GitHub Advanced Security for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableAdvancedSecurity,

        # Whether to enable code security for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableCodeSecurity,

        # Whether to enable secret scanning for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableSecretScanning,

        # Whether to enable secret scanning push protection for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableSecretScanningPushProtection,

        # Whether to enable secret scanning AI detection for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableSecretScanningAIDetection,

        # Whether to enable secret scanning non-provider patterns for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableSecretScanningNonProviderPatterns,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        Write-Verbose "ParameterSetName: $($PSCmdlet.ParameterSetName)"
        $repo = switch ($PSCmdlet.ParameterSetName) {
            'Create a repository for the authenticated user' {
                $params = @{
                    Context    = $Context
                    Name       = $Name
                    Visibility = $Visibility
                    AddReadme  = $AddReadme
                    Gitignore  = $Gitignore
                    License    = $License
                }
                $params | Remove-HashtableEntry -NullOrEmptyValues
                New-GitHubRepositoryUser @params
            }
            'Create a repository in an organization' {
                $params = @{
                    Context      = $Context
                    Organization = $Organization
                    Name         = $Name
                    Visibility   = $Visibility
                    AddReadme    = $AddReadme
                    Gitignore    = $Gitignore
                    License      = $License
                }
                $params | Remove-HashtableEntry -NullOrEmptyValues
                New-GitHubRepositoryOrg @params
            }
            'Create a repository from a template to a user' {
                $params = @{
                    Context            = $Context
                    TemplateOwner      = $TemplateOwner
                    TemplateRepository = $TemplateRepository
                    Name               = $Name
                    IncludeAllBranches = $IncludeAllBranches
                    Visibility         = $Visibility
                }
                $params | Remove-HashtableEntry -NullOrEmptyValues
                New-GitHubRepositoryFromTemplate @params
            }
            'Create a repository from a template to an organization' {
                $params = @{
                    Context            = $Context
                    TemplateOwner      = $TemplateOwner
                    TemplateRepository = $TemplateRepository
                    Owner              = $Organization
                    Name               = $Name
                    IncludeAllBranches = $IncludeAllBranches
                    Visibility         = $Visibility
                }
                $params | Remove-HashtableEntry -NullOrEmptyValues
                New-GitHubRepositoryFromTemplate @params
            }
            'Fork a repository to a user' {
                $params = @{
                    Context            = $Context
                    ForkOwner          = $ForkOwner
                    ForkRepository     = $ForkRepository
                    Name               = $Name
                    IncludeAllBranches = $IncludeAllBranches
                }
                $params | Remove-HashtableEntry -NullOrEmptyValues
                New-GitHubRepositoryAsFork @params
            }
            'Fork a repository to an organization' {
                $params = @{
                    Context            = $Context
                    ForkOwner          = $ForkOwner
                    ForkRepository     = $ForkRepository
                    Owner              = $Organization
                    Name               = $Name
                    IncludeAllBranches = $IncludeAllBranches
                }
                $params | Remove-HashtableEntry -NullOrEmptyValues
                New-GitHubRepositoryAsFork @params
            }
        }

        if ($VerbosePreference -eq 'Continue') {
            Write-Verbose 'New repo created'
            $repo | Select-Object * | Format-List | Out-String -Stream | ForEach-Object { Write-Verbose $_ }
        }

        $updateParams = @{
            Owner                                   = $repo.Owner
            Name                                    = $repo.Name
            Context                                 = $Context
            Visibility                              = $Visibility
            Description                             = $Description
            Homepage                                = $Homepage
            IsArchived                              = $IsArchived
            IsTemplate                              = $IsTemplate
            WebCommitSignoffRequired                = $WebCommitSignoffRequired
            DefaultBranch                           = $DefaultBranch
            HasWiki                                 = $HasWiki
            HasIssues                               = $HasIssues
            HasSponsorships                         = $HasSponsorships
            HasDiscussions                          = $HasDiscussions
            HasProjects                             = $HasProjects
            AllowMergeCommitWith                    = $AllowMergeCommitWith
            AllowSquashMergingWith                  = $AllowSquashMergingWith
            AllowRebaseMerging                      = $AllowRebaseMerging
            AllowForking                            = $AllowForking
            SuggestUpdateBranch                     = $SuggestUpdateBranch
            AllowAutoMerge                          = $AllowAutoMerge
            DeleteBranchOnMerge                     = $DeleteBranchOnMerge
            EnableAdvancedSecurity                  = $EnableAdvancedSecurity
            EnableCodeSecurity                      = $EnableCodeSecurity
            EnableSecretScanning                    = $EnableSecretScanning
            EnableSecretScanningPushProtection      = $EnableSecretScanningPushProtection
            EnableSecretScanningAIDetection         = $EnableSecretScanningAIDetection
            EnableSecretScanningNonProviderPatterns = $EnableSecretScanningNonProviderPatterns
        }
        $updatedRepo = Update-GitHubRepository @updateParams

        if ($VerbosePreference -eq 'Continue') {
            Write-Verbose 'Updated repo'
            $updatedRepo | Select-Object * | Format-List | Out-String -Stream | ForEach-Object { Write-Verbose $_ }
        }

        $updatedRepo.DefaultBranch = $repo.DefaultBranch
        $updatedRepo
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [New-GitHubRepository] - Done"
#endregion [functions] - [public] - [Repositories] - [New-GitHubRepository]
#region    [functions] - [public] - [Repositories] - [Remove-GitHubRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Remove-GitHubRepository] - Importing"
filter Remove-GitHubRepository {
    <#
        .SYNOPSIS
        Delete a repository

        .DESCRIPTION
        Deleting a repository requires admin access. If OAuth is used, the `delete_repo` scope is required.

        If an organization owner has configured the organization to prevent members from deleting organization-owned
        repositories, you will get a `403 Forbidden` response.

        .EXAMPLE
        Remove-GitHubRepository -Owner 'PSModule' -Name 'Hello-World'

        Deletes the repository `Hello-World` in the `PSModule` organization.

        .INPUTS
        GitHubRepository

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Remove-GitHubRepository/

        .NOTES
        [Delete a repository](https://docs.github.com/rest/repos/repos#delete-a-repository)
    #>
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/repos/$Owner/$Name"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("repo [$Owner/$Name]", 'Delete')) {
            $null = Invoke-GitHubAPI @apiParams
            Write-Verbose "Repository [$Owner/$Name] deleted."
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Remove-GitHubRepository] - Done"
#endregion [functions] - [public] - [Repositories] - [Remove-GitHubRepository]
#region    [functions] - [public] - [Repositories] - [Set-GitHubRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Set-GitHubRepository] - Importing"
function Set-GitHubRepository {
    <#
        .SYNOPSIS
        Creates or updates a repository.

        .DESCRIPTION
        Checks if the specified repository exists. If it does, the repository is updated using
        the provided parameters. If it does not exist, a new repository is created with the
        provided parameters. The updated or newly created repository is returned.

        .EXAMPLE
        Set-GitHubRepository -Name 'Hello-World' -Description 'My repo'

        Sets the repository `Hello-World` for the authenticated user if it does not exist,
        or updates it if it already exists. The repository uses GitHub's default settings.

        .EXAMPLE
        $params = @{
            Owner                  = 'octocat'
            Name                   = 'Hello-World'
            AllowSquashMergingWith = 'Pull request title and description'
            HasIssues              = $true
            SuggestUpdateBranch    = $true
            AllowAutoMerge         = $true
            DeleteBranchOnMerge    = $true
        }
        Set-GitHubRepository @params

        Sets a repository using splatting for the configuration.

        .OUTPUTS
        GitHubRepository

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Set-GitHubRepository/
    #>
    [OutputType([GitHubRepository])]
    [CmdletBinding(SupportsShouldProcess, DefaultParameterSetName = 'Set a repository for the authenticated user')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Set a repository in an organization')]
        [Parameter(Mandatory, ParameterSetName = 'Set a forked repository in an organization')]
        [Parameter(Mandatory, ParameterSetName = 'Set a repository from a template to an organization')]
        [Alias('Owner')]
        [string] $Organization,

        # The name of the repository.
        [Parameter(Mandatory, ParameterSetName = 'Set a repository from a template to a user')]
        [Parameter(Mandatory, ParameterSetName = 'Set a repository from a template to an organization')]
        [Parameter(Mandatory, ParameterSetName = 'Set a repository for the authenticated user')]
        [Parameter(Mandatory, ParameterSetName = 'Set a repository in an organization')]
        [Parameter(ParameterSetName = 'Set a forked repository for a user')]
        [Parameter(ParameterSetName = 'Set a forked repository in an organization')]
        [string] $Name,

        # The account owner of the template repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Set a repository from a template to a user')]
        [Parameter(Mandatory, ParameterSetName = 'Set a repository from a template to an organization')]
        [string] $TemplateOwner,

        # The name of the template repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Set a repository from a template to a user')]
        [Parameter(Mandatory, ParameterSetName = 'Set a repository from a template to an organization')]
        [string] $TemplateRepository,

        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Set a forked repository for a user')]
        [Parameter(Mandatory, ParameterSetName = 'Set a forked repository in an organization')]
        [string] $ForkOwner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Set a forked repository for a user')]
        [Parameter(Mandatory, ParameterSetName = 'Set a forked repository in an organization')]
        [string] $ForkRepository,

        # Include all branches from the source repository.
        [Parameter(ParameterSetName = 'Set a repository from a template to a user')]
        [Parameter(ParameterSetName = 'Set a repository from a template to an organization')]
        [Parameter(ParameterSetName = 'Set a forked repository for a user')]
        [Parameter(ParameterSetName = 'Set a forked repository in an organization')]
        [switch] $IncludeAllBranches,

        # Pass true to Set an initial commit with empty README.
        [Parameter(ParameterSetName = 'Set a repository for the authenticated user')]
        [Parameter(ParameterSetName = 'Set a repository in an organization')]
        [switch] $AddReadme,

        # The desired language or platform to apply to the .gitignore.
        [Parameter(ParameterSetName = 'Set a repository for the authenticated user')]
        [Parameter(ParameterSetName = 'Set a repository in an organization')]
        [string] $Gitignore,

        # The license keyword of the open source license for this repository.
        [Parameter(ParameterSetName = 'Set a repository for the authenticated user')]
        [Parameter(ParameterSetName = 'Set a repository in an organization')]
        [string] $License,

        # The visibility of the repository.
        [Parameter(ParameterSetName = 'Set a repository from a template to a user')]
        [Parameter(ParameterSetName = 'Set a repository from a template to an organization')]
        [Parameter(ParameterSetName = 'Set a repository for the authenticated user')]
        [Parameter(ParameterSetName = 'Set a repository in an organization')]
        [ValidateSet('Public', 'Private', 'Internal')]
        [string] $Visibility = 'Public',

        # A short description of the new repository.
        [Parameter()]
        [string] $Description,

        # A URL with more information about the repository.
        [Parameter()]
        [uri] $Homepage,

        # Whether the repository is archived.
        [Parameter()]
        [System.Nullable[bool]] $IsArchived,

        # Whether this repository acts as a template that can be used to generate new repositories.
        [Parameter()]
        [System.Nullable[bool]] $IsTemplate,

        # Whether to require contributors to sign off on web-based commits.
        [Parameter()]
        [System.Nullable[bool]] $WebCommitSignoffRequired,

        # Updates the default branch for this repository.
        [Parameter()]
        [string] $DefaultBranch,

        # Whether the wiki is enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasWiki,

        # Whether issues are enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasIssues,

        # Either true to allow private forks, or false to prevent private forks.
        [Parameter(ParameterSetName = 'Set a forked repository in an organization')]
        [Parameter(ParameterSetName = 'Set a repository from a template to an organization')]
        [Parameter(ParameterSetName = 'Set a repository in an organization')]
        [System.Nullable[bool]] $AllowForking,

        # Whether sponsorships are enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasSponsorships,

        # Whether discussions are enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasDiscussions,

        # Whether projects are enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasProjects,

        # Allow merge commits for pull requests with the specified setting.
        [Parameter()]
        [ValidateSet('', 'Default message', 'Pull request title', 'Pull request title and description')]
        [string] $AllowMergeCommitWith = 'Default message',

        # Allow squash merges for pull requests with the specified setting.
        [Parameter()]
        [ValidateSet('', 'Default message', 'Pull request title', 'Pull request title and description', 'Pull request title and commit details')]
        [string] $AllowSquashMergingWith = 'Default message',

        # Whether to allow rebase merges for pull requests.
        [Parameter()]
        [System.Nullable[bool]] $AllowRebaseMerging,

        # Whether to always suggest to update a head branch that is behind its base branch during a pull request.
        [Parameter()]
        [System.Nullable[bool]] $SuggestUpdateBranch,

        # Whether to allow Auto-merge to be used on pull requests.
        [Parameter()]
        [System.Nullable[bool]] $AllowAutoMerge,

        # Whether to delete head branches when pull requests are merged
        [Parameter()]
        [System.Nullable[bool]] $DeleteBranchOnMerge,

        # Whether to enable GitHub Advanced Security for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableAdvancedSecurity,

        # Whether to enable code security for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableCodeSecurity,

        # Whether to enable secret scanning for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableSecretScanning,

        # Whether to enable secret scanning push protection for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableSecretScanningPushProtection,

        # Whether to enable secret scanning AI detection for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableSecretScanningAIDetection,

        # Whether to enable secret scanning non-provider patterns for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableSecretScanningNonProviderPatterns,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )
    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $getParams = @{
            Owner   = $Organization
            Name    = $Name
            Context = $Context
        }
        $getParams | Remove-HashtableEntry -NullOrEmptyValues
        $repo = Get-GitHubRepository @getParams -ErrorAction Stop

        $configParams = @{
            Description                             = $Description
            Homepage                                = $Homepage
            IsArchived                              = $IsArchived
            IsTemplate                              = $IsTemplate
            WebCommitSignoffRequired                = $WebCommitSignoffRequired
            DefaultBranch                           = $DefaultBranch
            HasWiki                                 = $HasWiki
            HasIssues                               = $HasIssues
            AllowForking                            = $AllowForking
            HasSponsorships                         = $HasSponsorships
            HasDiscussions                          = $HasDiscussions
            HasProjects                             = $HasProjects
            AllowMergeCommitWith                    = $AllowMergeCommitWith
            AllowSquashMergingWith                  = $AllowSquashMergingWith
            AllowRebaseMerging                      = $AllowRebaseMerging
            SuggestUpdateBranch                     = $SuggestUpdateBranch
            AllowAutoMerge                          = $AllowAutoMerge
            DeleteBranchOnMerge                     = $DeleteBranchOnMerge
            EnableAdvancedSecurity                  = $EnableAdvancedSecurity
            EnableCodeSecurity                      = $EnableCodeSecurity
            EnableSecretScanning                    = $EnableSecretScanning
            EnableSecretScanningPushProtection      = $EnableSecretScanningPushProtection
            EnableSecretScanningAIDetection         = $EnableSecretScanningAIDetection
            EnableSecretScanningNonProviderPatterns = $EnableSecretScanningNonProviderPatterns
        }
        if ($PSCmdlet.ParameterSetName -notlike '*fork*') {
            $configParams['Visibility'] = $Visibility
        }
        $configParams | Remove-HashtableEntry -NullOrEmptyValues

        if ($repo) {
            $updateParams = @{
                Owner   = $repo.Owner
                Name    = $repo.Name
                Context = $Context
            }
            Update-GitHubRepository @updateParams @configParams -ErrorAction Stop
        } else {
            $newParams = @{
                Organization       = $Organization
                Name               = $Name
                TemplateOwner      = $TemplateOwner
                TemplateRepository = $TemplateRepository
                ForkOwner          = $ForkOwner
                ForkRepository     = $ForkRepository
                IncludeAllBranches = $PSBoundParameters.ContainsKey('IncludeAllBranches') ? $IncludeAllBranches : $null
                AddReadme          = $PSBoundParameters.ContainsKey('AddReadme') ? $AddReadme : $null
                Gitignore          = $Gitignore
                License            = $License
                Context            = $Context
            }
            $newParams | Remove-HashtableEntry -NullOrEmptyValues
            if ($VerbosePreference -eq 'Continue') {
                Write-Verbose 'New repo params:'
                $newParams | Select-Object * | Format-List | Out-String -Stream | ForEach-Object { Write-Verbose $_ }
                Write-Verbose 'Config params:'
                $configParams | Select-Object * | Format-List | Out-String -Stream | ForEach-Object { Write-Verbose $_ }
            }
            New-GitHubRepository @newParams @configParams -ErrorAction Stop
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Set-GitHubRepository] - Done"
#endregion [functions] - [public] - [Repositories] - [Set-GitHubRepository]
#region    [functions] - [public] - [Repositories] - [Update-GitHubRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Update-GitHubRepository] - Importing"
filter Update-GitHubRepository {
    <#
        .SYNOPSIS
        Update a repository

        .DESCRIPTION
        **Note**: To edit a repository's topics, use the
        [Replace all repository topics](https://docs.github.com/rest/repos/repos#replace-all-repository-topics) endpoint.

        .EXAMPLE
        Update-GitHubRepository -Name 'octocat' -Description 'Hello-World' -Homepage 'https://github.com'

        .EXAMPLE
        $params = @{
            Owner       = 'octocat'
            Name        = 'Hello-World'
            NewName     = 'Hello-World-Repository'
            Description = 'This is your first repository'
            Homepage    = 'https://github.com'
        }
        Update-GitHubRepository @params

        .INPUTS
        GitHubRepository

        .OUTPUTS
        GitHubRepository

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Update-GitHubRepository/

        .NOTES
        [Update a repository](https://docs.github.com/rest/repos/repos#update-a-repository)
    #>
    [OutputType([GitHubRepository])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Name,

        # The name of the repository.
        [Parameter()]
        [string] $NewName,

        # The visibility of the repository.
        [Parameter()]
        [ValidateSet('Public', 'Private', 'Internal')]
        [string] $Visibility,

        # A short description of the repository.
        [Parameter()]
        [string] $Description,

        # A URL with more information about the repository.
        [Parameter()]
        [uri] $Homepage,

        # Whether to archive this repository. false will unarchive a previously archived repository.
        [Parameter()]
        [System.Nullable[bool]] $IsArchived,

        # Whether this repository acts as a template that can be used to generate new repositories.
        [Parameter()]
        [System.Nullable[bool]] $IsTemplate,

        # Whether to require contributors to sign off on web-based commits.
        [Parameter()]
        [System.Nullable[bool]] $WebCommitSignoffRequired,

        # Updates the default branch for this repository.
        [Parameter()]
        [string] $DefaultBranch,

        # Whether the wiki is enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasWiki,

        # Whether issues are enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasIssues,

        # Either true to allow private forks, or false to prevent private forks.
        [Parameter()]
        [System.Nullable[bool]] $AllowForking,

        # Whether sponsorships are enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasSponsorships,

        # Whether discussions are enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasDiscussions,

        # Whether projects are enabled.
        [Parameter()]
        [System.Nullable[bool]] $HasProjects,

        # Allow merge commits for pull requests with the specified setting.
        [Parameter()]
        [ValidateSet('', 'Default message', 'Pull request title', 'Pull request title and description')]
        [string] $AllowMergeCommitWith,

        # Allow squash merges for pull requests with the specified setting.
        [Parameter()]
        [ValidateSet('', 'Default message', 'Pull request title', 'Pull request title and description', 'Pull request title and commit details')]
        [string] $AllowSquashMergingWith,

        # Whether to allow rebase merges for pull requests.
        [Parameter()]
        [switch] $AllowRebaseMerging,

        # Whether to always suggest to update a head branch that is behind its base branch during a pull request.
        [Parameter()]
        [System.Nullable[bool]] $SuggestUpdateBranch,

        # Whether to allow Auto-merge to be used on pull requests.
        [Parameter()]
        [System.Nullable[bool]] $AllowAutoMerge,

        # Whether to delete head branches when pull requests are merged
        [Parameter()]
        [System.Nullable[bool]] $DeleteBranchOnMerge,

        # Whether to enable GitHub Advanced Security for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableAdvancedSecurity,

        # Whether to enable code security for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableCodeSecurity,

        # Whether to enable secret scanning for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableSecretScanning,

        # Whether to enable secret scanning push protection for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableSecretScanningPushProtection,

        # Whether to enable secret scanning AI detection for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableSecretScanningAIDetection,

        # Whether to enable secret scanning non-provider patterns for this repository.
        [Parameter()]
        [System.Nullable[bool]] $EnableSecretScanningNonProviderPatterns,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
        if ([string]::IsNullOrEmpty($Owner)) {
            $Owner = $Context.Username
        }
        Write-Debug "Owner: [$Owner]"
    }

    process {
        $repo = Get-GitHubRepository -Owner $Owner -Name $Name
        if (-not $repo) {
            $PSCmdlet.ThrowTerminatingError(
                [System.Management.Automation.ErrorRecord]::new(
                    [System.Management.Automation.ItemNotFoundException]::new("Repository '$Name' not found for owner '$Owner'."),
                    'RepositoryNotFound',
                    [System.Management.Automation.ErrorCategory]::ObjectNotFound,
                    $null
                )
            )
        }

        if ($PSBoundParameters.ContainsKey('AllowMergeCommitWith')) {
            switch ($AllowMergeCommitWith) {
                'Default message' {
                    $AllowMergeCommit = $true
                    $MergeCommitTitle = 'MERGE_MESSAGE'
                    $MergeCommitMessage = 'PR_TITLE'
                }
                'Pull request title' {
                    $AllowMergeCommit = $true
                    $MergeCommitTitle = 'PR_TITLE'
                    $MergeCommitMessage = 'BLANK'
                }
                'Pull request title and description' {
                    $AllowMergeCommit = $true
                    $MergeCommitTitle = 'PR_TITLE'
                    $MergeCommitMessage = 'PR_BODY'
                }
                default {
                    $AllowMergeCommit = $false
                }
            }
        }

        if ($PSBoundParameters.ContainsKey('AllowSquashMergingWith')) {
            switch ($AllowSquashMergingWith) {
                'Default message' {
                    $AllowSquashMerge = $true
                    $SquashMergeCommitTitle = 'COMMIT_OR_PR_TITLE'
                    $SquashMergeCommitMessage = 'COMMIT_MESSAGES'
                }
                'Pull request title' {
                    $AllowSquashMerge = $true
                    $SquashMergeCommitTitle = 'PR_TITLE'
                    $SquashMergeCommitMessage = 'BLANK'
                }
                'Pull request title and description' {
                    $AllowSquashMerge = $true
                    $SquashMergeCommitTitle = 'PR_TITLE'
                    $SquashMergeCommitMessage = 'PR_BODY'
                }
                'Pull request title and commit details' {
                    $AllowSquashMerge = $true
                    $SquashMergeCommitTitle = 'PR_TITLE'
                    $SquashMergeCommitMessage = 'COMMIT_MESSAGES'
                }
                default {
                    $AllowSquashMerge = $false
                }
            }
        }

        $body = @{
            name                                  = $NewName
            visibility                            = $Visibility.ToLower()
            description                           = $Description
            homepage                              = $Homepage
            archived                              = $IsArchived
            is_template                           = $IsTemplate
            web_commit_signoff_required           = $WebCommitSignoffRequired
            default_branch                        = $DefaultBranch
            has_wiki                              = $HasWiki
            has_issues                            = $HasIssues
            allow_forking                         = $AllowForking
            has_projects                          = $HasProjects
            allow_squash_merge                    = $AllowSquashMerge
            allow_merge_commit                    = $AllowMergeCommit
            squash_merge_commit_title             = $SquashMergeCommitTitle
            squash_merge_commit_message           = $SquashMergeCommitMessage
            merge_commit_title                    = $MergeCommitTitle
            merge_commit_message                  = $MergeCommitMessage
            allow_rebase_merge                    = $AllowRebaseMerge
            allow_update_branch                   = $SuggestUpdateBranch
            allow_auto_merge                      = $AllowAutoMerge
            delete_branch_on_merge                = $DeleteBranchOnMerge
            advanced_security                     = $PSBoundParameters.ContainsKey('EnableAdvancedSecurity') ? @{
                status = $EnableAdvancedSecurity ? 'enabled' : 'disabled'
            } : $null
            code_security                         = $PSBoundParameters.ContainsKey('EnableCodeSecurity') ? @{
                status = $EnableCodeSecurity ? 'enabled' : 'disabled'
            } : $null
            secret_scanning                       = $PSBoundParameters.ContainsKey('EnableSecretScanning') ? @{
                status = $EnableSecretScanning ? 'enabled' : 'disabled'
            } : $null
            secret_scanning_push_protection       = $PSBoundParameters.ContainsKey('EnableSecretScanningPushProtection') ? @{
                status = $EnableSecretScanningPushProtection ? 'enabled' : 'disabled'
            } : $null
            secret_scanning_ai_detection          = $PSBoundParameters.ContainsKey('EnableSecretScanningAIDetection') ? @{
                status = $EnableSecretScanningAIDetection ? 'enabled' : 'disabled'
            } : $null
            secret_scanning_non_provider_patterns = $PSBoundParameters.ContainsKey('EnableSecretScanningNonProviderPatterns') ? @{
                status = $EnableSecretScanningNonProviderPatterns ? 'enabled' : 'disabled'
            } : $null
        }

        $body | Remove-HashtableEntry -NullOrEmptyValues

        if ($DebugPreference -eq 'Continue') {
            Write-Debug 'Changed settings for REST call is:'
            [pscustomobject]$body | Out-String -Stream | ForEach-Object { Write-Debug $_ }
        }
        if ($body.Keys.Count -gt 0) {
            $apiParams = @{
                Method      = 'PATCH'
                APIEndpoint = "/repos/$Owner/$Name"
                Body        = $body
                Context     = $Context
            }

            if ($PSCmdlet.ShouldProcess("Repository [$Owner/$Name]", 'Update')) {
                $updatedRepo = Invoke-GitHubAPI @apiParams | Select-Object -ExpandProperty Response
            }
            if ($DebugPreference -eq 'Continue') {
                Write-Debug 'Repo has been updated'
                $updatedRepo | Select-Object * | Out-String -Stream | ForEach-Object { Write-Debug $_ }
            }
        } else {
            Write-Debug 'No changes made to repo via REST'
        }

        $inputParams = @{
            hasSponsorshipsEnabled = $HasSponsorships
            hasDiscussionsEnabled  = $HasDiscussions
        }
        $inputParams | Remove-HashtableEntry -NullOrEmptyValues

        if ($DebugPreference -eq 'Continue') {
            Write-Debug 'Changed settings for GraphQL call is:'
            $inputParams | Out-String -Stream | ForEach-Object { Write-Debug $_ }
        }
        if ($inputParams.Keys.Count -gt 0) {
            $inputParams += @{
                repositoryId = $repo.NodeID
            }

            $updateGraphQLInputs = @{
                query     = @'
                mutation($input:UpdateRepositoryInput!) {
                    updateRepository(input:$input) {
                        repository {
                            id
                            name
                            hasSponsorshipsEnabled
                            hasDiscussionsEnabled
                        }
                    }
                }
'@
                variables = @{
                    input = $inputParams
                }
            }
            $null = Invoke-GitHubGraphQLQuery @updateGraphQLInputs
        } else {
            Write-Debug 'No changes made to repo via GraphQL'
        }

        Get-GitHubRepository -Owner $Owner -Name $Name
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Update-GitHubRepository] - Done"
#endregion [functions] - [public] - [Repositories] - [Update-GitHubRepository]
#region    [functions] - [public] - [Repositories] - [Autolinks]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Autolinks] - Processing folder"
#region    [functions] - [public] - [Repositories] - [Autolinks] - [Get-GitHubRepositoryAutolink]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Autolinks] - [Get-GitHubRepositoryAutolink] - Importing"
filter Get-GitHubRepositoryAutolink {
    <#
        .SYNOPSIS
        List all autolinks of a repository

        .DESCRIPTION
        This returns a list of autolinks configured for the given repository.

        Information about autolinks are only available to repository administrators.

        .EXAMPLE
        Get-GitHubRepositoryAutolink -Owner 'octocat' -Repository 'Hello-World'

        Gets all autolinks for the repository 'Hello-World' owned by 'octocat'.

        .EXAMPLE
        Get-GitHubRepositoryAutolink -Owner 'octocat' -Repository 'Hello-World' -ID 1

        Gets the autolink with the ID 1 for the repository 'Hello-World' owned by 'octocat'.

        .NOTES
        [Get all autolinks of a repository](https://docs.github.com/rest/repos/autolinks#list-all-autolinks-of-a-repository)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Autolinks/Get-GitHubRepositoryAutolink
    #>
    [Alias('Get-GitHubRepositoryAutolinks')]
    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The unique identifier of the autolink.
        [Parameter(
            Mandatory,
            ParameterSetName = 'ById'
        )]
        [Alias('autolink_id', 'AutolinkID')]
        [int] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'ById' {
                Get-GitHubRepositoryAutolinkById -Owner $Owner -Repository $Repository -ID $ID -Context $Context
            }
            default {
                Get-GitHubRepositoryAutolinkList -Owner $Owner -Repository $Repository -Context $Context
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Autolinks] - [Get-GitHubRepositoryAutolink] - Done"
#endregion [functions] - [public] - [Repositories] - [Autolinks] - [Get-GitHubRepositoryAutolink]
#region    [functions] - [public] - [Repositories] - [Autolinks] - [New-GitHubRepositoryAutolink]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Autolinks] - [New-GitHubRepositoryAutolink] - Importing"
filter New-GitHubRepositoryAutolink {
    <#
        .SYNOPSIS
        Create an autolink reference for a repository

        .DESCRIPTION
        Users with admin access to the repository can create an autolink.

        .EXAMPLE
        New-GitHubRepositoryAutolink -Owner 'octocat' -Repository 'Hello-World' -KeyPrefix 'GH-' -UrlTemplate 'https://www.example.com/issue/<num>'

        Creates an autolink for the repository 'Hello-World' owned by 'octocat' that links to <https://www.example.com/issue/123>
        when the prefix 'GH-' is found in an issue, pull request, or commit.

        .NOTES
        [Create an autolink reference for a repository](https://docs.github.com/rest/repos/autolinks#create-an-autolink-reference-for-a-repository)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Autolinks/New-GitHubRepositoryAutolink
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # This prefix appended by certain characters will generate a link any time it is found in an issue, pull request, or commit.
        [Parameter(Mandatory)]
        [Alias('key_prefix')]
        [string] $KeyPrefix,

        # The URL must contain <num> for the reference number. <num> matches different characters depending on the value of is_alphanumeric.
        [Parameter(Mandatory)]
        [Alias('url_template')]
        [string] $UrlTemplate,

        # Whether this autolink reference matches alphanumeric characters. If true, the <num> parameter of the url_template matches alphanumeric
        # characters A-Z (case insensitive), 0-9, and -. If false, this autolink reference only matches numeric characters.
        [Parameter()]
        [Alias('is_alphanumeric')]
        [bool] $IsAlphanumeric = $true,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            key_prefix      = $KeyPrefix
            url_template    = $UrlTemplate
            is_alphanumeric = $IsAlphanumeric
        }

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/repos/$Owner/$Repository/autolinks"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Autolink for repository [$Owner/$Repository]", 'Create')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Autolinks] - [New-GitHubRepositoryAutolink] - Done"
#endregion [functions] - [public] - [Repositories] - [Autolinks] - [New-GitHubRepositoryAutolink]
#region    [functions] - [public] - [Repositories] - [Autolinks] - [Remove-GitHubRepositoryAutolink]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Autolinks] - [Remove-GitHubRepositoryAutolink] - Importing"
filter Remove-GitHubRepositoryAutolink {
    <#
        .SYNOPSIS
        Delete an autolink reference from a repository

        .DESCRIPTION
        This deletes a single autolink reference by ID that was configured for the given repository.

        Information about autolinks are only available to repository administrators.

        .EXAMPLE
        Remove-GitHubRepositoryAutolink -Owner 'octocat' -Repository 'Hello-World' -AutolinkId 1

        Deletes the autolink with ID 1 for the repository 'Hello-World' owned by 'octocat'.

        .NOTES
        [Delete an autolink reference from a repository](https://docs.github.com/rest/repos/autolinks#delete-an-autolink-reference-from-a-repository)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Autolinks/Remove-GitHubRepositoryAutolink
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The unique identifier of the autolink.
        [Parameter(Mandatory)]
        [Alias('autolink_id', 'AutolinkID')]
        [int] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/repos/$Owner/$Repository/autolinks/$ID"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Autolink with ID [$ID] for repository [$Owner/$Repository]", 'DELETE')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Autolinks] - [Remove-GitHubRepositoryAutolink] - Done"
#endregion [functions] - [public] - [Repositories] - [Autolinks] - [Remove-GitHubRepositoryAutolink]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Autolinks] - Done"
#endregion [functions] - [public] - [Repositories] - [Autolinks]
#region    [functions] - [public] - [Repositories] - [CustomProperties]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [CustomProperties] - Processing folder"
#region    [functions] - [public] - [Repositories] - [CustomProperties] - [Get-GitHubRepositoryCustomProperty]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [CustomProperties] - [Get-GitHubRepositoryCustomProperty] - Importing"
filter Get-GitHubRepositoryCustomProperty {
    <#
        .SYNOPSIS
        Get all custom property values for a repository

        .DESCRIPTION
        Gets all custom property values that are set for a repository.
        Users with read access to the repository can use this endpoint.

        .EXAMPLE
        Get-GitHubRepositoryCustomProperty -Owner 'octocat' -Repository 'hello-world'

        Gets all custom property values that are set for the 'hello-world' repository.

        .NOTES
        [Get all custom property values for a repository](https://docs.github.com/rest/repos/custom-properties#get-all-custom-property-values-for-a-repository)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/CustomProperties/Get-GitHubRepositoryCustomProperty
    #>
    [Alias('Get-GitHubRepositoryCustomProperties')]
    [CmdletBinding()]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [OutputType([pscustomobject])]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/properties/values"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [CustomProperties] - [Get-GitHubRepositoryCustomProperty] - Done"
#endregion [functions] - [public] - [Repositories] - [CustomProperties] - [Get-GitHubRepositoryCustomProperty]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [CustomProperties] - Done"
#endregion [functions] - [public] - [Repositories] - [CustomProperties]
#region    [functions] - [public] - [Repositories] - [Permissions]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Permissions] - Processing folder"
#region    [functions] - [public] - [Repositories] - [Permissions] - [completers]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Permissions] - [completers] - Importing"
Register-ArgumentCompleter -CommandName Set-GitHubRepositoryPermission -ParameterName Permission -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters

    $permissions = @('None', 'Pull', 'Triage', 'Push', 'Maintain', 'Admin', 'Read', 'Write')

    $permissions | Where-Object { $_ -like "*$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Permissions] - [completers] - Done"
#endregion [functions] - [public] - [Repositories] - [Permissions] - [completers]
#region    [functions] - [public] - [Repositories] - [Permissions] - [Get-GitHubRepositoryPermission]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Permissions] - [Get-GitHubRepositoryPermission] - Importing"
filter Get-GitHubRepositoryPermission {
    <#
        .SYNOPSIS
        Get the permission level for a team on a repository.

        .DESCRIPTION
        Retrieves the permission level assigned to a specific team for a given GitHub repository.

        .EXAMPLE
        Get-GitHubRepositoryPermission -Owner 'octocat' -Name 'Hello-World' -Team 'core'

        Output:
        ```powershell
        Admin
        ```

        Retrieves the permission of the 'core' team on the 'Hello-World' repository owned by 'octocat'.

        .EXAMPLE


        .INPUTS
        GitHubRepository

        .OUTPUTS
        string

        .LINK
        https://psmodule.io/GitHub/Functions/Get-GitHubRepositoryPermission/

        .NOTES
        [Check team permissions for a repository](https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-repository)
    #>
    [OutputType([string])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [Alias('Organization')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Name,

        # The slug of the team to add or update repository permissions for.
        [Parameter(Mandatory)]
        [Alias('Slug', 'TeamSlug')]
        [string] $Team,

        # The owner of the team. If not specified, the owner will default to the value of -Owner.
        [Parameter()]
        [string] $TeamOwner,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
        $TeamOwner = [string]::IsNullOrEmpty($TeamOwner) ? $Owner : $TeamOwner
    }

    process {
        $params = @{
            Context   = $Context
            Owner     = $Owner
            Name      = $Name
            Team      = $Team
            TeamOwner = $TeamOwner
        }
        $repo = Get-GitHubRepositoryByNameAndTeam @params
        if ($null -eq $repo) {
            Write-Debug "[$stackPath] - No permission found for team '$Team' on repository '$Name' owned by '$Owner'."
            return $null
        }
        $repo.Permission
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Permissions] - [Get-GitHubRepositoryPermission] - Done"
#endregion [functions] - [public] - [Repositories] - [Permissions] - [Get-GitHubRepositoryPermission]
#region    [functions] - [public] - [Repositories] - [Permissions] - [Remove-GitHubRepositoryPermission]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Permissions] - [Remove-GitHubRepositoryPermission] - Importing"
filter Remove-GitHubRepositoryPermission {
    <#
        .SYNOPSIS
        Remove the permission level for a team on a repository.

        .DESCRIPTION
        This function removes a team's access to a specific repository within an organization.

        .EXAMPLE
        Remove-GitHubRepositoryPermission -Owner 'my-org' -Name 'repo-name' -Team 'dev-team'

        Removes the 'dev-team' permissions from the 'repo-name' repository under 'my-org'.

        .INPUTS
        GitHubRepository

        .OUTPUTS
        void

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Remove-GitHubRepositoryPermission/

        .NOTES
        [Remove a repository from a team](https://docs.github.com/rest/teams/teams#remove-a-repository-from-a-team)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [Alias('Organization')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Name,

        # The slug of the team to add or update repository permissions for.
        [Parameter(Mandatory)]
        [Alias('Slug', 'TeamSlug')]
        [string] $Team,

        # The owner of the team. If not specified, the owner will default to the value of -Owner.
        [Parameter()]
        [string] $TeamOwner,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
        $TeamOwner = [string]::IsNullOrEmpty($TeamOwner) ? $Owner : $TeamOwner
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/orgs/$TeamOwner/teams/$Team/repos/$Owner/$Name"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Team [$TeamOwner/$Team] repository permission on [$Owner/$Name]", 'Remove')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Permissions] - [Remove-GitHubRepositoryPermission] - Done"
#endregion [functions] - [public] - [Repositories] - [Permissions] - [Remove-GitHubRepositoryPermission]
#region    [functions] - [public] - [Repositories] - [Permissions] - [Set-GitHubRepositoryPermission]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Permissions] - [Set-GitHubRepositoryPermission] - Importing"
filter Set-GitHubRepositoryPermission {
    <#
        .SYNOPSIS
        Set the permission level for a team on a repository

        .DESCRIPTION
        Assigns or updates the permission level for a specific team on a GitHub repository. The permission can be
        standard roles like 'pull', 'push', 'admin', or any custom roles defined in the organization. If the value
        'None' is specified, the function removes the team's access to the repository.

        .EXAMPLE
        Set-GitHubRepositoryPermission -Owner 'MyOrg' -Name 'MyRepo' -Team 'devs' -Permission 'push'

        Grants the 'push' permission to the 'devs' team for the repository 'MyRepo' owned by 'MyOrg'.

        .INPUTS
        GitHubRepository

        .OUTPUTS
        void

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Set-GitHubRepositoryPermission/

        .NOTES
        [Add or update team repository permissions](https://docs.github.com/rest/teams/teams#add-or-update-team-repository-permissions)
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [Alias('Organization')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Name,

        # The slug of the team to add or update repository permissions for.
        [Parameter(Mandatory)]
        [Alias('Slug', 'TeamSlug')]
        [string] $Team,

        # The owner of the team. If not specified, the owner will default to the value of -Owner.
        [Parameter()]
        [string] $TeamOwner,

        # The permission to grant the team on this repository. We accept the following permissions to be set:
        # pull, triage, push, maintain, admin and you can also specify a custom repository role name, if the
        # owning organization has defined any. If you want to remove the permissions specify 'None'.
        [Parameter(Mandatory)]
        [string] $Permission,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
        $TeamOwner = [string]::IsNullOrEmpty($TeamOwner) ? $Owner : $TeamOwner
    }

    process {
        $teamObject = Get-GitHubTeam -Organization $TeamOwner -Slug $Team -Context $Context
        if (-not $teamObject) {
            throw "Team [$TeamOwner/$Team] was not found."
        }
        if ($Permission -eq 'Write') {
            $Permission = 'push'
        }
        if ($Permission -eq 'Read') {
            $Permission = 'pull'
        }
        Write-Debug "$(Get-FunctionParameter | Format-List | Out-String)"
        try {
            $currentPermission = Get-GitHubRepositoryPermission -Owner $Owner -Name $Name -TeamOwner $TeamOwner -Team $Team -Context $Context
            Write-Debug "$($currentPermission | Format-List | Out-String)"
        } catch {
            Write-Debug "Team [$TeamOwner/$Team] was not found for repository [$Owner/$Name]."
        }
        if ($currentPermission -eq $Permission -or ($Permission -eq 'None' -and [string]::IsNullOrEmpty($currentPermission))) {
            Write-Debug "[$stackPath] - No change needed for [$Owner/$Name] team [$TeamOwner/$Team] permission [$Permission]"
            return
        }

        if ($Permission -eq 'None') {
            if (-not $currentPermission) {
                return
            }
            Remove-GitHubRepositoryPermission -Owner $Owner -Name $Name -Team $Team -TeamOwner $TeamOwner -Context $Context -Confirm:$false
            Write-Debug "[$stackPath] - Removed team [$TeamOwner/$Team] permission"
            return
        }

        $body = @{
            permission = $Permission.ToLower()
        }

        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/orgs/$TeamOwner/teams/$Team/repos/$Owner/$Name"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Team [$TeamOwner/$Team] repository permission [$Permission] on [$Owner/$Name]", 'Set')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Permissions] - [Set-GitHubRepositoryPermission] - Done"
#endregion [functions] - [public] - [Repositories] - [Permissions] - [Set-GitHubRepositoryPermission]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Permissions] - Done"
#endregion [functions] - [public] - [Repositories] - [Permissions]
#region    [functions] - [public] - [Repositories] - [Repositories]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - Processing folder"
#region    [functions] - [public] - [Repositories] - [Repositories] - [Disable-GitHubRepositoryPrivateVulnerabilityReporting]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Disable-GitHubRepositoryPrivateVulnerabilityReporting] - Importing"
filter Disable-GitHubRepositoryPrivateVulnerabilityReporting {
    <#
        .SYNOPSIS
        Disable private vulnerability reporting for a repository

        .DESCRIPTION
        Disables private vulnerability reporting for a repository. The authenticated user must have admin access
        to the repository. For more information, see
        "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)".

        .EXAMPLE
        Disable-GitHubRepositoryPrivateVulnerabilityReporting -Owner 'PSModule' -Name 'GitHub'

        Disables private vulnerability reporting for the PSModule/GitHub repository.

        .NOTES
        [Disable private vulnerability reporting for a repository](https://docs.github.com/rest/repos/repos#disable-private-vulnerability-reporting-for-a-repository)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Disable-GitHubRepositoryPrivateVulnerabilityReporting
    #>
    [CmdletBinding(SupportsShouldProcess)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Long links')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/repos/$Owner/$Name/private-vulnerability-reporting"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Private Vulnerability Reporting for [$Owner/$Name]", 'Disable')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Disable-GitHubRepositoryPrivateVulnerabilityReporting] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Disable-GitHubRepositoryPrivateVulnerabilityReporting]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Disable-GitHubRepositorySecurityFix]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Disable-GitHubRepositorySecurityFix] - Importing"
filter Disable-GitHubRepositorySecurityFix {
    <#
        .SYNOPSIS
        Disable automated security fixes

        .DESCRIPTION
        Disables automated security fixes for a repository. The authenticated user must have admin access to the repository.
        For more information, see
        "[Configuring automated security fixes](https://docs.github.com/articles/configuring-automated-security-fixes)".

        .EXAMPLE
        Disable-GitHubRepositorySecurityFix -Owner 'PSModule' -Name 'GitHub'

        Disables automated security fixes for the repository.

        .NOTES
        [Disable automated security fixes](https://docs.github.com/rest/repos/repos#disable-automated-security-fixes)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Disable-GitHubRepositorySecurityFix
    #>
    [CmdletBinding(SupportsShouldProcess)]
    [Alias('Disable-GitHubRepositorySecurityFixes')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/repos/$Owner/$Name/automated-security-fixes"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Security Fixes for [$Owner/$Name]", 'Disable')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Disable-GitHubRepositorySecurityFix] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Disable-GitHubRepositorySecurityFix]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Disable-GitHubRepositoryVulnerabilityAlert]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Disable-GitHubRepositoryVulnerabilityAlert] - Importing"
filter Disable-GitHubRepositoryVulnerabilityAlert {
    <#
        .SYNOPSIS
        Disable vulnerability alerts

        .DESCRIPTION
        Disables dependency alerts and the dependency graph for a repository.
        The authenticated user must have admin access to the repository. For more information, see
        "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".

        .EXAMPLE
        Disable-GitHubRepositoryVulnerabilityAlert -Owner 'octocat' -Name 'hello-world'

        Disables vulnerability alerts for the 'octocat/hello-world' repository.

        .NOTES
        [Disable vulnerability alerts](https://docs.github.com/rest/repos/repos#disable-vulnerability-alerts)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Disable-GitHubRepositoryVulnerabilityAlert
    #>
    [CmdletBinding(SupportsShouldProcess)]
    [Alias('Disable-GitHubRepositoryVulnerabilityAlerts')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/repos/$Owner/$Name/vulnerability-alerts"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Vulnerability Alerts for [$Owner/$Name]", 'Disable')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Disable-GitHubRepositoryVulnerabilityAlert] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Disable-GitHubRepositoryVulnerabilityAlert]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Enable-GitHubRepositoryPrivateVulnerabilityReporting]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Enable-GitHubRepositoryPrivateVulnerabilityReporting] - Importing"
filter Enable-GitHubRepositoryPrivateVulnerabilityReporting {
    <#
        .SYNOPSIS
        Enable private vulnerability reporting for a repository

        .DESCRIPTION
        Enables private vulnerability reporting for a repository. The authenticated user must have admin access
        to the repository. For more information, see
        "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)."

        .EXAMPLE
        Enable-GitHubRepositoryPrivateVulnerabilityReporting -Owner 'PSModule' -Name 'GitHub'

        Enables private vulnerability reporting for the PSModule/GitHub repository.

        .NOTES
        [Enable private vulnerability reporting for a repository](https://docs.github.com/rest/repos/repos#enable-private-vulnerability-reporting-for-a-repository)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Enable-GitHubRepositoryPrivateVulnerabilityReporting
    #>
    [CmdletBinding(SupportsShouldProcess)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Long links')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/repos/$Owner/$Name/private-vulnerability-reporting"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Private Vulnerability Reporting for [$Owner/$Name]", 'Enable')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Enable-GitHubRepositoryPrivateVulnerabilityReporting] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Enable-GitHubRepositoryPrivateVulnerabilityReporting]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Enable-GitHubRepositorySecurityFix]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Enable-GitHubRepositorySecurityFix] - Importing"
filter Enable-GitHubRepositorySecurityFix {
    <#
        .SYNOPSIS
        Enable automated security fixes

        .DESCRIPTION
        Enables automated security fixes for a repository. The authenticated user must have admin access to the repository.
        For more information, see
        "[Configuring automated security fixes](https://docs.github.com/articles/configuring-automated-security-fixes)".

        .EXAMPLE
        Enable-GitHubRepositorySecurityFix -Owner 'PSModule' -Name 'GitHub'

        Enables automated security fixes for the repository.

        .NOTES
        [Enable automated security fixes](https://docs.github.com/rest/repos/repos#enable-automated-security-fixes)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Enable-GitHubRepositorySecurityFix
    #>
    [CmdletBinding(SupportsShouldProcess)]
    [Alias('Enable-GitHubRepositorySecurityFixes')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/repos/$Owner/$Name/automated-security-fixes"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Security Fixes for [$Owner/$Name]", 'Enable')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Enable-GitHubRepositorySecurityFix] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Enable-GitHubRepositorySecurityFix]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Enable-GitHubRepositoryVulnerabilityAlert]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Enable-GitHubRepositoryVulnerabilityAlert] - Importing"
filter Enable-GitHubRepositoryVulnerabilityAlert {
    <#
        .SYNOPSIS
        Enable vulnerability alerts

        .DESCRIPTION
        Enables dependency alerts and the dependency graph for a repository.
        The authenticated user must have admin access to the repository.
        For more information, see
        "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".

        .EXAMPLE
        Enable-GitHubRepositoryVulnerabilityAlert -Owner 'octocat' -Name 'hello-world'

        Enables vulnerability alerts for the 'octocat/hello-world' repository.

        .NOTES
        [Enable vulnerability alerts](https://docs.github.com/rest/repos/repos#enable-vulnerability-alerts)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Enable-GitHubRepositoryVulnerabilityAlert
    #>
    [CmdletBinding(SupportsShouldProcess)]
    [Alias('Enable-GitHubRepositoryVulnerabilityAlerts')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/repos/$Owner/$Name/vulnerability-alerts"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Vulnerability Alerts for [$Owner/$Name]", 'Enable')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Enable-GitHubRepositoryVulnerabilityAlert] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Enable-GitHubRepositoryVulnerabilityAlert]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryActivity]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryActivity] - Importing"
filter Get-GitHubRepositoryActivity {
    <#
        .SYNOPSIS
        List repository activities

        .DESCRIPTION
        Lists a detailed history of changes to a repository, such as pushes, merges, force pushes, and branch changes,
        and associates these changes with commits and users.

        For more information about viewing repository activity,
        see "[Viewing activity and data for your repository](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository)."

        .EXAMPLE
        Get-GitHubRepositoryActivity -Owner 'PSModule' -Name 'GitHub'

        .EXAMPLE
        Get-GitHubRepositoryActivity -Owner 'PSModule' -Name 'GitHub' -Direction 'asc'

        .EXAMPLE
        Get-GitHubRepositoryActivity -Owner 'PSModule' -Name 'GitHub' -PerPage 100

        .EXAMPLE
        Get-GitHubRepositoryActivity -Owner 'PSModule' -Name 'GitHub' -Before '2021-01-01T00:00:00Z'

        .EXAMPLE
        Get-GitHubRepositoryActivity -Owner 'PSModule' -Name 'GitHub' -After '2021-01-01T00:00:00Z'

        .EXAMPLE
        Get-GitHubRepositoryActivity -Owner 'PSModule' -Name 'GitHub' -Ref 'refs/heads/main'

        .EXAMPLE
        Get-GitHubRepositoryActivity -Owner 'PSModule' -Name 'GitHub' -Actor 'octocat'

        .EXAMPLE
        $params = @{
            Owner       = 'PSModule'
            Repo        = 'GitHub'
            TimePeriod  = 'day'
        }
        Get-GitHubRepositoryActivity @params |
            Select-Object -Property @{n='actor';e={$_.actor.login}},activity_type,ref,timestamp

        Gets the activity for the past 24 hours and selects the actor, activity type, ref, and timestamp.

        .EXAMPLE
        Get-GitHubRepositoryActivity -Owner 'PSModule' -Name 'GitHub' -ActivityType 'push','force_push'

        .NOTES
        [List repository activities](https://docs.github.com/rest/repos/repos#list-repository-activities)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Get-GitHubRepositoryActivity
    #>
    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The direction to sort the results by.
        [Parameter()]
        [ValidateSet('asc', 'desc')]
        [string] $Direction = 'desc',

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # A cursor, as given in the Link header. If specified, the query only searches for results before this cursor.
        [Parameter(ParameterSetName = 'BeforeAfter')]
        [string] $Before,

        # A cursor, as given in the Link header. If specified, the query only searches for results after this cursor.
        [Parameter(ParameterSetName = 'BeforeAfter')]
        [string] $After,

        # The Git reference for the activities you want to list.
        # The ref for a branch can be formatted either as refs/heads/BRANCH_NAME or BRANCH_NAME, where BRANCH_NAME is the name of your branch.
        [Parameter()]
        [string] $Ref,

        # The GitHub username to use to filter by the actor who performed the activity.
        [Parameter()]
        [string] $Actor,

        # The time period to filter by.
        # For example,day will filter for activity that occurred in the past 24 hours,
        # and week will filter for activity that occurred in the past 7 days (168 hours).
        [Parameter()]
        [ValidateSet('day', 'week', 'month', 'quarter', 'year')]
        [Alias('time_period')]
        [string] $TimePeriod,

        # The activity type to filter by.
        # For example,you can choose to filter by 'force_push', to see all force pushes to the repository.
        [Parameter()]
        [ValidateSet('push', 'force_push', 'branch_creation', 'branch_deletion', 'pr_merge', 'merge_queue_merge')]
        [Alias('activity_type')]
        [string] $ActivityType,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            direction     = $Direction
            before        = $Before
            after         = $After
            ref           = $Ref
            actor         = $Actor
            time_period   = $TimePeriod
            activity_type = $ActivityType
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Name/activity"
            Body        = $body
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryActivity] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryActivity]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryCodeownersError]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryCodeownersError] - Importing"
filter Get-GitHubRepositoryCodeownersError {
    <#
        .SYNOPSIS
        List CODEOWNERS errors

        .DESCRIPTION
        List any syntax errors that are detected in the CODEOWNERS file.

        For more information about the correct CODEOWNERS syntax,
        see "[About code owners](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners)."

        .EXAMPLE
        Get-GitHubRepositoryCodeownersError -Owner 'PSModule' -Name 'GitHub'

        Gets the CODEOWNERS errors for the repository.

        .NOTES
        [List CODEOWNERS errors](https://docs.github.com/rest/repos/repos#list-codeowners-errors)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Get-GitHubRepositoryCodeownersError
    #>
    [CmdletBinding()]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # A branch, tag or commit name used to determine which version of the CODEOWNERS file to use.
        # Default: the repository's default branch (e.g. main)
        [Parameter()]
        [string] $Ref,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            ref = $Ref
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Name/codeowners/errors"
            Body        = $body
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryCodeownersError] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryCodeownersError]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryContributor]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryContributor] - Importing"
filter Get-GitHubRepositoryContributor {
    <#
        .SYNOPSIS
        List repository contributors

        .DESCRIPTION
        Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order.
        This endpoint may return information that is a few hours old because the GitHub REST API caches contributor data to improve performance.

        GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user,
        which includes all associated email addresses. To improve performance, only the first 500 author email addresses
        in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.

        .EXAMPLE
        Get-GitHubRepositoryContributor -Owner 'PSModule' -Name 'GitHub'

        Gets all contributors to the GitHub repository.

        .NOTES
        [List repository contributors](https://docs.github.com/rest/repos/repos#list-repository-contributors)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Get-GitHubRepositoryContributor
    #>
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # Wether to include anonymous contributors in results.
        [Parameter()]
        [switch] $Anon,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            anon = $Anon
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Name/contributors"
            Body        = $body
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryContributor] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryContributor]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryFork]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryFork] - Importing"
filter Get-GitHubRepositoryFork {
    <#
        .SYNOPSIS
        List forks

        .DESCRIPTION
        List forks of a named repository.

        .EXAMPLE
        Get-GitHubRepositoryFork -Owner 'octocat' -Name 'Hello-World'

        List forks of the 'Hello-World' repository owned by 'octocat'.

        .NOTES
        [List forks](https://docs.github.com/rest/repos/forks#list-forks)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Get-GitHubRepositoryFork
    #>
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The direction to sort the results by.
        [Parameter()]
        [ValidateSet('newest', 'oldest', 'stargazers', 'watchers')]
        [string] $Sort = 'newest',

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            sort     = $Sort
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Name/forks"
            Body        = $body
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryFork] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryFork]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryLanguage]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryLanguage] - Importing"
filter Get-GitHubRepositoryLanguage {
    <#
        .SYNOPSIS
        List repository languages

        .DESCRIPTION
        Lists languages for the specified repository. The value shown for each language is the number of
        bytes of code written in that language.

        .EXAMPLE
        Get-GitHubRepositoryLanguage -Owner 'octocat' -Name 'hello-world'

        Gets the languages for the 'hello-world' repository owned by 'octocat'.

        .NOTES
        [List repository languages](https://docs.github.com/rest/repos/repos#list-repository-languages)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Get-GitHubRepositoryLanguage
    #>
    [CmdletBinding()]
    [Alias('Get-GitHubRepositoryLanguages')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Name/languages"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryLanguage] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryLanguage]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositorySecurityFix]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositorySecurityFix] - Importing"
filter Get-GitHubRepositorySecurityFix {
    <#
        .SYNOPSIS
        Check if automated security fixes are enabled for a repository

        .DESCRIPTION
        Shows whether automated security fixes are enabled, disabled or paused for a repository.
        The authenticated user must have admin read access to the repository. For more information, see
        "[Configuring automated security fixes](https://docs.github.com/articles/configuring-automated-security-fixes)".

        .EXAMPLE
        Get-GitHubRepositorySecurityFix -Owner 'PSModule' -Name 'GitHub'

        Gets the automated security fixes status for the GitHub repository.

        .NOTES
        [Check if automated security fixes are enabled for a repository](https://docs.github.com/rest/repos/repos#check-if-automated-security-fixes-are-enabled-for-a-repository)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Get-GitHubRepositorySecurityFix
    #>
    [CmdletBinding()]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Name/automated-security-fixes"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositorySecurityFix] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositorySecurityFix]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryTag]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryTag] - Importing"
filter Get-GitHubRepositoryTag {
    <#
        .SYNOPSIS
        List repository tags

        .DESCRIPTION
        List repository tags

        .EXAMPLE
        Get-GitHubRepositoryTag -Owner 'PSModule' -Name 'GitHub'

        Gets all tags of the GitHub repository.

        .NOTES
        [List repository tags](https://docs.github.com/rest/repos/repos#list-repository-tags)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Get-GitHubRepositoryTag
    #>
    [CmdletBinding()]
    [Alias('Get-GitHubRepositoryTags')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Name/tags"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryTag] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryTag]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryTeam]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryTeam] - Importing"
filter Get-GitHubRepositoryTeam {
    <#
        .SYNOPSIS
        List repository teams

        .DESCRIPTION
        Lists the teams that have access to the specified repository and that are also visible to the authenticated user.

        For a public repository, a team is listed only if that team added the public repository explicitly.

        Personal access tokens require the following scopes:
        * `public_repo` to call this endpoint on a public repository
        * `repo` to call this endpoint on a private repository (this scope also includes public repositories)

        This endpoint is not compatible with fine-grained personal access tokens.

        .EXAMPLE
        Get-GitHubRepositoryTeam -Owner 'PSModule' -Name 'GitHub'

        Lists the teams that have access to the specified repository and that are also visible to the authenticated user.

        .NOTES
        [List repository teams](https://docs.github.com/rest/repos/repos#list-repository-teams)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Get-GitHubRepositoryTeam
    #>
    [CmdletBinding()]
    [Alias('Get-GitHubRepositoryTeams')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Name/teams"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryTeam] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryTeam]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryTopic]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryTopic] - Importing"
filter Get-GitHubRepositoryTopic {
    <#
        .SYNOPSIS
        Get all repository topics

        .DESCRIPTION
        Get all repository topics

        .EXAMPLE

        .NOTES
        [Get all repository topics](https://docs.github.com/rest/repos/repos#get-all-repository-topics)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Get-GitHubRepositoryTopic
    #>
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Name/topics"
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response.names
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryTopic] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Get-GitHubRepositoryTopic]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Set-GitHubRepositoryTopic]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Set-GitHubRepositoryTopic] - Importing"
filter Set-GitHubRepositoryTopic {
    <#
        .SYNOPSIS
        Replace all repository topics

        .DESCRIPTION
        Replace all repository topics

        .EXAMPLE
        Set-GitHubRepositoryTopic -Owner 'octocat' -Name 'hello-world' -Topic 'octocat', 'octo', 'octocat/hello-world'

        Replaces all topics for the repository 'octocat/hello-world' with the topics 'octocat', 'octo', 'octocat/hello-world'.

        .NOTES
        [Replace all repository topics](https://docs.github.com/rest/repos/repos#replace-all-repository-topics)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Set-GitHubRepositoryTopic
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The number of results per page (max 100).
        [Parameter()]
        [string[]] $Topic = @(),

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            names = $Topic | ForEach-Object { $_.ToLower() }
        }

        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/repos/$Owner/$Name/topics"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("topics for repo [$Owner/$Name]", 'Set')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response.names
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Set-GitHubRepositoryTopic] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Set-GitHubRepositoryTopic]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Start-GitHubRepositoryEvent]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Start-GitHubRepositoryEvent] - Importing"
filter Start-GitHubRepositoryEvent {
    <#
        .SYNOPSIS
        Create a repository dispatch event

        .DESCRIPTION
        You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want activity
        that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook. You must configure
        your GitHub Actions workflow or GitHub App to run when the `repository_dispatch`
        event occurs. For an example `repository_dispatch` webhook payload, see
        "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."

        The `client_payload` parameter is available for any extra information that your workflow might need.
        This parameter is a JSON payload that will be passed on when the webhook event is dispatched. For example,
        the `client_payload` can include a message that a user would like to send using a GitHub Actions workflow.
        Or the `client_payload` can be used as a test to debug your workflow.

        This endpoint requires write access to the repository by providing either:

        - Personal access tokens with `repo` scope. For more information, see
        "[Creating a personal access token for the command line](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line)"
        in the GitHub Help documentation.
        - GitHub Apps with both `metadata:read` and `contents:read&write` permissions.

        This input example shows how you can use the `client_payload` as a test to debug your workflow.

        .EXAMPLE
        $params = @{
            EventType = 'on-demand-test'
            ClientPayload = @{
                unit = false
                integration = true
            }
        }
        Start-GitHubRepositoryEvent @params

        Starts a repository event with the name `on-demand-test` and a `client_payload` that includes `unit` and `integration`.

        .NOTES
        [Create a repository dispatch event](https://docs.github.com/rest/repos/repos#create-a-repository-dispatch-event)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Start-GitHubRepositoryEvent
    #>
    [CmdletBinding(SupportsShouldProcess)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Long links')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # A custom webhook event name. Must be 100 characters or fewer.
        [Parameter(Mandatory)]
        [string] $EventType,

        # JSON payload with extra information about the webhook event that your action or workflow may use.
        # The maximum number of top-level properties is 10.
        [Parameter()]
        [object] $ClientPayload,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            event_type     = $EventType
            client_payload = $ClientPayload
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/repos/$Owner/$Name/dispatches"
            Body        = $body
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Start-GitHubRepositoryEvent] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Start-GitHubRepositoryEvent]
#region    [functions] - [public] - [Repositories] - [Repositories] - [Test-GitHubRepositoryVulnerabilityAlert]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Test-GitHubRepositoryVulnerabilityAlert] - Importing"
filter Test-GitHubRepositoryVulnerabilityAlert {
    <#
        .SYNOPSIS
        Check if vulnerability alerts are enabled for a repository

        .DESCRIPTION
        Shows whether dependency alerts are enabled or disabled for a repository.
        The authenticated user must have admin read access to the repository.
        For more information, see
        "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".

        .EXAMPLE
        Test-GitHubRepositoryVulnerabilityAlert -Owner 'PSModule' -Name 'GitHub'

        Checks if vulnerability alerts are enabled for the PSModule/GitHub repository.

        .NOTES
        [Check if vulnerability alerts are enabled for a repository](https://docs.github.com/rest/repos/repos#list-repository-tags)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/Repositories/Test-GitHubRepositoryVulnerabilityAlert
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    [Alias('Test-GitHubRepositoryVulnerabilityAlerts')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [Alias('Organization')]
        [Alias('User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Name/vulnerability-alerts"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - [Test-GitHubRepositoryVulnerabilityAlert] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories] - [Test-GitHubRepositoryVulnerabilityAlert]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [Repositories] - Done"
#endregion [functions] - [public] - [Repositories] - [Repositories]
#region    [functions] - [public] - [Repositories] - [RuleSuite]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [RuleSuite] - Processing folder"
#region    [functions] - [public] - [Repositories] - [RuleSuite] - [Get-GitHubRepositoryRuleSuite]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [RuleSuite] - [Get-GitHubRepositoryRuleSuite] - Importing"
filter Get-GitHubRepositoryRuleSuite {
    <#
        .SYNOPSIS
        List repository rule suites or a rule suite by ID.

        .DESCRIPTION
        Lists suites of rule evaluations at the repository level.
        If an ID is specified, gets information about a suite of rule evaluations from within a repository.
        For more information, see"[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets)."

        .EXAMPLE
        $params = @{
            Owner           = 'octocat'
            Repo            = 'hello-world'
            Ref             = 'main'
            TimePeriod      = 'day'
            ActorName       = 'octocat'
            RuleSuiteResult = 'all'
        }
        Get-GitHubRepositoryRuleSuite @params

        Gets a list of rule suites for the main branch of the hello-world repository owned by octocat.

        .EXAMPLE
        Get-GitHubRepositoryRuleSuite -Owner 'octocat' -Repository 'hello-world' -RuleSuiteId 123456789

        Gets information about a suite of rule evaluations with ID 123456789 from within the octocat/hello-world repository.

        .NOTES
        [List repository rule suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)
        [Get a repository rule suite](https://docs.github.com/rest/repos/rule-suites#get-a-repository-rule-suite)

        .LINK
        https://psmodule.io/GitHub/Functions/Repositories/RuleSuite/Get-GitHubRepositoryRuleSuite
    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Long links')]
    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter()]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Repository,

        # The name of the ref. Cannot contain wildcard characters.
        # When specified, only rule evaluations triggered for this ref will be returned.
        [Parameter()]
        [string] $Ref,

        # The time period to filter by.
        # For example,day will filter for rule suites that occurred in the past 24 hours,
        # and week will filter for insights that occurred in the past 7 days (168 hours).
        [Parameter()]
        [ValidateSet('hour', 'day', 'week', 'month')]
        [string] $TimePeriod = 'day',

        # The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
        [Parameter()]
        [string] $ActorName,

        # The rule results to filter on. When specified, only suites with this result will be returned.
        [Parameter()]
        [ValidateSet('pass', 'fail', 'bypass', 'all')]
        [string] $RuleSuiteResult = 'all',

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The unique identifier of the rule suite result. To get this ID, you can use GET /repos/ { owner }/ { repo }/rulesets/rule-suites for repositories and GET /orgs/ { org }/rulesets/rule-suites for organizations.
        [Parameter(
            Mandatory,
            ParameterSetName = 'ById'
        )]
        [int] $RuleSuiteId,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $params = @{
            Context    = $Context
            Owner      = $Owner
            Repository = $Repository
        }

        switch ($PSCmdlet.ParameterSetName) {
            'ById' {
                $params += @{
                    RuleSuiteId = $RuleSuiteId
                }
                Get-GitHubRepositoryRuleSuiteById @params
            }
            default {
                $params += @{
                    Ref             = $Ref
                    TimePeriod      = $TimePeriod
                    ActorName       = $ActorName
                    RuleSuiteResult = $RuleSuiteResult
                    PerPage         = $PerPage
                }
                Get-GitHubRepositoryRuleSuiteList @params
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [RuleSuite] - [Get-GitHubRepositoryRuleSuite] - Done"
#endregion [functions] - [public] - [Repositories] - [RuleSuite] - [Get-GitHubRepositoryRuleSuite]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - [RuleSuite] - Done"
#endregion [functions] - [public] - [Repositories] - [RuleSuite]
Write-Debug "[$scriptName] - [functions] - [public] - [Repositories] - Done"
#endregion [functions] - [public] - [Repositories]
#region    [functions] - [public] - [Secrets]
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - Processing folder"
#region    [functions] - [public] - [Secrets] - [completers]
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [completers] - Importing"
Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport |
        Where-Object { $_ -like '*GitHubSecret' }) -ParameterName Name -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter

    $params = @{
        Owner       = $fakeBoundParameter.Owner
        Repository  = $fakeBoundParameter.Repository
        Environment = $fakeBoundParameter.Environment
    }
    $params | Remove-HashtableEntry -NullOrEmptyValues
    Get-GitHubSecret @params | Where-Object { $_.Name -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Name)
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [completers] - Done"
#endregion [functions] - [public] - [Secrets] - [completers]
#region    [functions] - [public] - [Secrets] - [Get-GitHubPublicKey]
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [Get-GitHubPublicKey] - Importing"
function Get-GitHubPublicKey {
    <#
        .SYNOPSIS
        Gets a public key.

        .DESCRIPTION
        Gets your public key, which you need to encrypt secrets.

        .EXAMPLE
        Get-GitHubPublicKey

        Gets a public key for the authenticated user.

        .EXAMPLE
        Get-GitHubPublicKey -Organization 'octocat'

        Gets a public key for the 'octocat' organization.

        .EXAMPLE
        Get-GitHubPublicKey -Owner 'octocat' -Repository 'hello-world' -Type 'codespaces'

        Gets a public key for the 'hello-world' repository in the 'octocat' organization for codespaces.

        .OUTPUTS
        GitHubPublicKey

        .LINK
        https://psmodule.io/GitHub/Functions/Secrets/Get-GitHubPublicKey/
    #>
    [OutputType([GitHubPublicKey])]
    [CmdletBinding(DefaultParameterSetName = 'AuthenticatedUser')]
    param (
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Organization', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the repository environment.
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Environment,

        # The context to run the command in. Used to get the details for the API call.
        [Parameter()]
        [ValidateSet('actions', 'codespaces')]
        [string] $Type = 'actions',

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $scope = @{
            Context = $Context
            Owner   = $Owner
        }
        switch ($PSCmdlet.ParameterSetName) {
            'Organization' {
                switch ($Type) {
                    'actions' {
                        Get-GitHubPublicKeyForActionOnOrganization @scope
                    }
                    'codespaces' {
                        Get-GitHubPublicKeyForCodespacesOnOrganization @scope
                    }
                }
                break
            }
            'Repository' {
                $scope['Repository'] = $Repository
                switch ($Type) {
                    'actions' {
                        Get-GitHubPublicKeyForActionOnRepository @scope
                    }
                    'codespaces' {
                        Get-GitHubPublicKeyForCodespacesOnRepository @scope
                    }
                }
                break
            }
            'Environment' {
                $scope['Repository'] = $Repository
                $scope['Environment'] = $Environment
                switch ($Type) {
                    'actions' {
                        Get-GitHubPublicKeyForActionOnEnvironment @scope
                    }
                    'codespaces' {
                        throw 'Environment is not supported for codespaces.'
                    }
                }
                break
            }
            'AuthenticatedUser' {
                switch ($Type) {
                    'actions' {
                        throw "AuthenticatedUser is not supported for actions. Specify -Type 'codespaces'"
                    }
                    'codespaces' {
                        Get-GitHubPublicKeyForCodespacesOnUser -Context $Context
                    }
                }
                break
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [Get-GitHubPublicKey] - Done"
#endregion [functions] - [public] - [Secrets] - [Get-GitHubPublicKey]
#region    [functions] - [public] - [Secrets] - [Get-GitHubSecret]
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [Get-GitHubSecret] - Importing"
function Get-GitHubSecret {
    <#
        .SYNOPSIS
        Retrieve GitHub secret(s) without revealing encrypted value(s).

        .DESCRIPTION
        Retrieves GitHub secrets from a repository, organization, or environment without exposing
        the actual secret values. Supports multiple contexts such as Actions, Codespaces, and
        Organization secrets.

        The function returns an array of PSObjects containing metadata about the secrets.

        .EXAMPLE
        Get-GitHubSecret -Owner PSModule -Repo Demo -Type actions

        Retrieves all Actions secrets from the 'Demo' repository under the 'PSModule' organization.

        .EXAMPLE
        Get-GitHubSecret -Owner PSModule -Type organization

        Retrieves all organization-level secrets under the 'PSModule' organization.

        .EXAMPLE
        Get-GitHubSecret -Owner PSModule -Repo Demo -Environment Staging

        Retrieves all secrets for the 'Staging' environment in the 'Demo' repository under 'PSModule'.

        .OUTPUTS
        GitHubSecret[]

        .LINK
        https://psmodule.io/GitHub/Functions/Secrets/Get-GitHubSecret/
    #>
    [OutputType([GitHubSecret[]])]
    [CmdletBinding(DefaultParameterSetName = 'AuthorizedUser')]
    param (
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Organization', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the environment.
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Environment,

        # The name of the secret.
        [Parameter()]
        [SupportsWildcards()]
        [string] $Name = '*',

        # # The type of secret to retrieve.
        # # Can be either 'actions', 'codespaces'.
        # [Parameter()]
        # [ValidateSet('actions', 'codespaces')]
        # [string] $Type = 'actions',

        # List all secrets that are inherited.
        [Parameter()]
        [switch] $IncludeInherited,

        # List all secrets, including those that are overwritten by inheritance.
        [Parameter()]
        [switch] $All,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $secrets = @()
        $params = @{
            Context = $Context
            Owner   = $Owner
        }

        switch ($PSCmdlet.ParameterSetName) {
            'Organization' {
                if ($Name.Contains('*')) {
                    $secrets += Get-GitHubSecretOwnerList @params |
                        Where-Object { $_.Name -like $Name }
                } else {
                    try {
                        $secrets += Get-GitHubSecretOwnerByName @params -Name $Name
                    } catch { $null }
                }
                break
            }
            'Repository' {
                $params['Repository'] = $Repository
                if ($IncludeInherited) {
                    $secrets += Get-GitHubSecretFromOrganization @params |
                        Where-Object { $_.Name -like $Name }
                }
                if ($Name.Contains('*')) {
                    $secrets += Get-GitHubSecretRepositoryList @params |
                        Where-Object { $_.Name -like $Name }
                } else {
                    try {
                        $secrets += Get-GitHubSecretRepositoryByName @params -Name $Name
                    } catch { $null }
                }
                break
            }
            'Environment' {
                $params['Repository'] = $Repository
                if ($IncludeInherited) {
                    $secrets += Get-GitHubSecretFromOrganization @params |
                        Where-Object { $_.Name -like $Name }
                    if ($Name.Contains('*')) {
                        $secrets += Get-GitHubSecretRepositoryList @params |
                            Where-Object { $_.Name -like $Name }
                    } else {
                        try {
                            $secrets += Get-GitHubSecretRepositoryByName @params -Name $Name
                        } catch { $null }
                    }
                }
                $params['Environment'] = $Environment
                if ($Name.Contains('*')) {
                    $secrets += Get-GitHubSecretEnvironmentList @params |
                        Where-Object { $_.Name -like $Name }
                } else {
                    try {
                        $secrets += Get-GitHubSecretEnvironmentByName @params -Name $Name
                    } catch { $null }
                }
                break
            }
        }
        if ($IncludeInherited -and -not $All) {
            $secrets = $secrets | Group-Object -Property Name | ForEach-Object {
                $group = $_.Group
                $envSecret = $group | Where-Object { $_.Environment }
                if ($envSecret) {
                    $envSecret
                } else {
                    $repoSecret = $group | Where-Object { $_.Repository -and (-not $_.Environment) }
                    if ($repoSecret) {
                        $repoSecret
                    } else {
                        $group | Where-Object { (-not $_.Repository) -and (-not $_.Environment) }
                    }
                }
            }
        }
        $secrets | ForEach-Object { Write-Output $_ }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [Get-GitHubSecret] - Done"
#endregion [functions] - [public] - [Secrets] - [Get-GitHubSecret]
#region    [functions] - [public] - [Secrets] - [Remove-GitHubSecret]
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [Remove-GitHubSecret] - Importing"
function Remove-GitHubSecret {
    <#
        .SYNOPSIS
        Deletes a secret from GitHub.

        .DESCRIPTION
        Removes a secret from a specified GitHub repository, environment, organization, or authenticated user.
        Supports both Actions and Codespaces secrets and requires appropriate authentication.

        .EXAMPLE
        Remove-GitHubSecret -Owner PSModule -Repository Demo -Type actions -Name TEST

        Deletes the secret named 'TEST' from the 'Demo' repository in the 'PSModule' organization.

        .EXAMPLE
        Remove-GitHubSecret -Organization MyOrg -Type actions -Name API_KEY

        Deletes the secret 'API_KEY' from the organization 'MyOrg'.

        .EXAMPLE
        Remove-GitHubSecret -Owner MyUser -Repository MyRepo -Environment Production -Name DB_PASSWORD

        Deletes the 'DB_PASSWORD' secret from the 'Production' environment in the 'MyRepo' repository.

        .NOTES
        Supports authentication using GitHub App tokens (IAT), Personal Access Tokens (PAT), or User Access Tokens (UAT).

        .LINK
        https://psmodule.io/GitHub/Functions/Secrets/Remove-GitHubSecret/
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSShouldProcess', '', Scope = 'Function',
        Justification = 'This check is performed in the private functions.'
    )]
    [CmdletBinding(DefaultParameterSetName = 'AuthenticatedUser', SupportsShouldProcess, ConfirmImpact = 'High')]
    param (
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Organization', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the environment.
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Environment,

        # The name of the secret.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Name,

        # # Specifies whether the secret is for Actions or Codespaces.
        # [ValidateSet('actions', 'codespaces')]
        # [string] $Type = 'actions',

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context,

        [Parameter(Mandatory, ParameterSetName = 'ArrayInput', ValueFromPipeline)]
        [GitHubSecret[]] $InputObject
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'ArrayInput' {
                foreach ($item in $InputObject) {
                    $params = @{
                        Owner       = $item.Owner
                        Repository  = $item.Repository
                        Environment = $item.Environment
                        Name        = $item.Name
                        Context     = $item.Context
                    }
                    $params | Remove-HashtableEntry -NullOrEmptyValues
                    Remove-GitHubSecret @params
                }
                break
            }
            'Organization' {
                $params = @{
                    Owner   = $Owner
                    Name    = $Name
                    Context = $Context
                }
                Remove-GitHubSecretFromOwner @params
                break
            }
            'Repository' {
                $params = @{
                    Owner      = $Owner
                    Repository = $Repository
                    Name       = $Name
                    Context    = $Context
                }
                Remove-GitHubSecretFromRepository @params
                break
            }
            'Environment' {
                $params = @{
                    Owner       = $Owner
                    Repository  = $Repository
                    Environment = $Environment
                    Name        = $Name
                    Context     = $Context
                }
                Remove-GitHubSecretFromEnvironment @params
                break
            }
            'AuthenticatedUser' {
                throw 'Authenticated user: Not supported'
                break
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [Remove-GitHubSecret] - Done"
#endregion [functions] - [public] - [Secrets] - [Remove-GitHubSecret]
#region    [functions] - [public] - [Secrets] - [Set-GitHubSecret]
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [Set-GitHubSecret] - Importing"
function Set-GitHubSecret {
    <#
        .SYNOPSIS
        Updates a GitHub secret for an organization, repository, or user.

        .DESCRIPTION
        This function updates a secret in a GitHub repository, environment, or organization.
        It encrypts the secret value before storing it and supports different visibility levels.

        .EXAMPLE
        $secret = ConvertTo-SecureString "my-secret-value" -AsPlainText -Force
        Set-GitHubSecret -Repository 'MyRepo' -Owner 'MyUser' -Name 'MySecret' -Value $secret

        Updates the secret `MySecret` in the `MyRepo` repository for the owner `MyUser`.

        .EXAMPLE
        $params = @{
            Organization = 'MyOrg'
            Name         = 'MySecret'
            Type         = 'actions'
            Value        = (ConvertTo-SecureString "my-secret-value" -AsPlainText -Force)
            Visibility   = 'Private'
        }
        Set-GitHubSecret @params

        Updates the secret `MySecret` at the organization level for GitHub Actions, setting visibility to private.

        .EXAMPLE
        $params = @{
            Owner       = 'MyUser'
            Repository  = 'MyRepo'
            Environment = 'Production'
            Name        = 'MySecret'
            Value       = (ConvertTo-SecureString "my-secret-value" -AsPlainText -Force)
        }
        Set-GitHubSecret @params

        Updates the secret `MySecret` in the `Production` environment of the `MyRepo` repository for `MyUser`.

        .OUTPUTS
        GitHubSecret

        .LINK
        https://psmodule.io/GitHub/Functions/Secrets/Set-GitHubSecret/
    #>
    [Alias('New-GitHubSecret')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSShouldProcess', '', Scope = 'Function',
        Justification = 'This check is performed in the private functions.'
    )]
    [OutputType([GitHubSecret])]
    [CmdletBinding(DefaultParameterSetName = 'Organization', SupportsShouldProcess, ConfirmImpact = 'Low')]
    param (
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Organization', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the repository environment.
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Environment,

        # The name of the secret to be updated.
        [Parameter(Mandatory)]
        [string] $Name,

        # The secret value to be stored, as a SecureString or a plain string (less secure).
        [Parameter()]
        [object] $Value = (Read-Host -AsSecureString -Prompt 'Enter the secret value'),

        # The visibility of the secret when updating an organization secret.
        # Can be `private`, `selected`, or `all`.
        [Parameter(ParameterSetName = 'Organization')]
        [ValidateSet('Private', 'Selected', 'All')]
        [string] $Visibility = 'Private',

        # The IDs of the repositories to which the secret is available.
        # Used only when the `-Visibility` parameter is set to `selected`.
        [Parameter(ParameterSetName = 'Organization')]
        [UInt64[]] $SelectedRepositories,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $publicKeyParams = @{
            Owner       = $Owner
            Repository  = $Repository
            Environment = $Environment
            Context     = $Context
        }
        $publicKeyParams | Remove-HashtableEntry -NullOrEmptyValues
        $publicKey = Get-GitHubPublicKey @publicKeyParams
        if ($Value -is [securestring]) {
            $Value = $Value | ConvertFrom-SecureString -AsPlainText
        }
        $encryptedValue = ConvertTo-SodiumSealedBox -PublicKey $publicKey.Key -Message $Value

        $params = $publicKeyParams + @{
            Name  = $Name
            Value = $encryptedValue
            KeyID = $publicKey.ID
        }

        switch ($PSCmdlet.ParameterSetName) {
            'Organization' {
                $params['Visibility'] = $Visibility.ToLower()
                $params['SelectedRepositories'] = $SelectedRepositories
                Set-GitHubSecretOnOwner @params
                break
            }
            'Repository' {
                Set-GitHubSecretOnRepository @params
                break
            }
            'Environment' {
                Set-GitHubSecretOnEnvironment @params
                break
            }
        }

        Get-GitHubSecret @publicKeyParams -Name $Name
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
#Requires -Modules @{ ModuleName = 'Sodium'; RequiredVersion = '2.2.0'}
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [Set-GitHubSecret] - Done"
#endregion [functions] - [public] - [Secrets] - [Set-GitHubSecret]
#region    [functions] - [public] - [Secrets] - [SelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [SelectedRepository] - Processing folder"
#region    [functions] - [public] - [Secrets] - [SelectedRepository] - [Add-GitHubSecretSelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [SelectedRepository] - [Add-GitHubSecretSelectedRepository] - Importing"
function Add-GitHubSecretSelectedRepository {
    <#
        .SYNOPSIS
        Add selected repository to an organization secret.

        .DESCRIPTION
        Adds a repository to an organization secret when the `visibility` for repository access is set to `selected`. For more information about
        setting the visibility, see [Create or update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret).
        Authenticated users must have collaborator access to a repository to create, update, or read secrets.
        OAuth tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, OAuth tokens
        and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE
        Add-GitHubSecretSelectedRepository -Owner 'my-org' -Name 'API_KEY' -RepositoryID '654321'

        Adds the repository 'test-repo' to the 'API_KEY' secret in the organization 'my-org'.

        .INPUTS
        [GitHubSecret]

        .LINK
        https://psmodule.io/GitHub/Functions/Secrets/SelectedRepository/Add-GitHubSecretSelectedRepository

        .NOTES
        [Add selected repository to an organization secret](https://docs.github.com/rest/actions/secrets#add-selected-repository-to-an-organization-secret)
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '',
        Justification = 'Long links'
    )]
    [OutputType([void])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the secret.
        [Parameter(Mandatory)]
        [string] $Name,

        # The ID of the repository to add to the secret.
        [Parameter(,
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('DatabaseID', 'ID')]
        [UInt64] $RepositoryID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $existingSelectedRepositories = Get-GitHubSecretSelectedRepository -Owner $Owner -Name $Name -Context $Context
        $repoIsSelected = $existingSelectedRepositories.ID -contains $RepositoryID
        if ($repoIsSelected) {
            Write-Debug 'Repo is already selected, returning'
            return
        }
        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/orgs/$Owner/actions/secrets/$Name/repositories/$RepositoryID"
            Context     = $Context
        }

        $null = Invoke-GitHubAPI @apiParams
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [SelectedRepository] - [Add-GitHubSecretSelectedRepository] - Done"
#endregion [functions] - [public] - [Secrets] - [SelectedRepository] - [Add-GitHubSecretSelectedRepository]
#region    [functions] - [public] - [Secrets] - [SelectedRepository] - [Get-GitHubSecretSelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [SelectedRepository] - [Get-GitHubSecretSelectedRepository] - Importing"
function Get-GitHubSecretSelectedRepository {
    <#
        .SYNOPSIS
        List selected repositories for an organization secret.

        .DESCRIPTION
        Lists all repositories that have been selected when the `visibility`for repository access to a secret is set to `selected`. Authenticated
        users must have collaborator access to a repository to create, update, or read secrets. OAuth app tokens and personal access tokens (classic)
        need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.

        .EXAMPLE
        Get-GitHubSecretSelectedRepository -Owner 'octocat' -Name 'hello-world'

        Outputs:
        ```powershell
        Name        : hello-world
        NodeID      : m_MDXNcwMAwMMA
        ID          : 123456789
        Description : A test repo for hello-world.
        Owner       : octocat
        Url         : https://github.com/octocat/hello-world
        CreatedAt   :
        UpdatedAt   :

        Name        : hello-world2
        NodeID      : n_NEYOdxNBxNNB
        ID          : 987654321
        Description : A test repo for hello-world.
        Owner       : octocat
        Url         : https://github.com/octocat/hello-world2
        CreatedAt   :
        UpdatedAt   :
        ```

        Gets the repositories that have been selected for the secret `hello-world` in the organization `octocat`.

        .OUTPUTS
        GitHubRepository

        .LINK
        https://psmodule.io/GitHub/Functions/Secrets/SelectedRepository/Get-GitHubSecretSelectedRepository

        .NOTES
        [List selected repositories for an organization secret](https://docs.github.com/rest/actions/Secrets#list-selected-repositories-for-an-organization-Secret)
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '',
        Justification = 'Long links'
    )]
    [OutputType([GitHubRepository])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the secret.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Owner/actions/secrets/$Name/repositories"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response.repositories | ForEach-Object {
                [GitHubRepository]::New($_)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [SelectedRepository] - [Get-GitHubSecretSelectedRepository] - Done"
#endregion [functions] - [public] - [Secrets] - [SelectedRepository] - [Get-GitHubSecretSelectedRepository]
#region    [functions] - [public] - [Secrets] - [SelectedRepository] - [Remove-GitHubSecretSelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [SelectedRepository] - [Remove-GitHubSecretSelectedRepository] - Importing"
function Remove-GitHubSecretSelectedRepository {
    <#
        .SYNOPSIS
        Remove selected repository from an organization secret.

        .DESCRIPTION
        Removes a repository from an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when
        you [Create or update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret).
        Authenticated users must have collaborator access to a repository to create, update, or read secrets. OAuth app tokens and personal access
        tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.

        .EXAMPLE
        Remove-GitHubSecretSelectedRepository -Owner 'my-org' -Name 'ENV_SECRET' -RepositoryID 123456

        Removes repository with ID 123456 from the organization secret 'ENV_SECRET' in 'my-org'.

        .OUTPUTS
        void

        .LINK
        https://psmodule.io/GitHub/Functions/Secrets/SelectedRepository/Remove-GitHubSecretSelectedRepository

        .NOTES
        [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret)
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '',
        Justification = 'Long links'
    )]
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the secret.
        [Parameter(Mandatory)]
        [string] $Name,

        # The ID of the repository to remove to the secret.
        [Parameter(,
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('DatabaseID', 'ID')]
        [UInt64] $RepositoryID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $existingSelectedRepositories = Get-GitHubSecretSelectedRepository -Owner $Owner -Name $Name -Context $Context
        $repoIsNotSelected = $existingSelectedRepositories.ID -notcontains $RepositoryID
        if ($repoIsNotSelected) {
            Write-Debug 'Repo is not selected, returning'
            return
        }
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/orgs/$Owner/actions/secrets/$Name/repositories/$RepositoryID"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("access to secret [$Owner/$Name] for repository [$RepositoryID]", 'Remove')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [SelectedRepository] - [Remove-GitHubSecretSelectedRepository] - Done"
#endregion [functions] - [public] - [Secrets] - [SelectedRepository] - [Remove-GitHubSecretSelectedRepository]
#region    [functions] - [public] - [Secrets] - [SelectedRepository] - [Set-GitHubSecretSelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [SelectedRepository] - [Set-GitHubSecretSelectedRepository] - Importing"
function Set-GitHubSecretSelectedRepository {
    <#
        .SYNOPSIS
        Set selected repositories for an organization secret.

        .DESCRIPTION
        Replaces all repositories for an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set
        when you [Create or update an organization secret](https://docs.github.com/rest/actions/secrets#create-or-update-an-organization-secret).
        Authenticated users must have collaborator access to a repository to create, update, or read secrets. OAuth app tokens and personal access
        tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.

        .EXAMPLE
        Set-GitHubSecretSelectedRepository -Owner 'octocat' -Name 'mysecret' -RepositoryID 1234567890

        Sets the selected repositories for the secret `mysecret` in the organization `octocat` to the repository with ID `1234567890`.

        .LINK
        https://psmodule.io/GitHub/Functions/Secrets/SelectedRepository/Set-GitHubSecretSelectedRepository

        .NOTES
        [Set selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#set-selected-repositories-for-an-organization-secret)
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '',
        Justification = 'Long links'
    )]
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the secret.
        [Parameter(Mandatory)]
        [string] $Name,

        # The ID of the repository to set to the secret.
        [Parameter(Mandatory)]
        [UInt64[]] $RepositoryID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            selected_repository_ids = @($RepositoryID)
        }
        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/orgs/$Owner/actions/secrets/$Name/repositories"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("access to secret [$Owner/$Name] for repository [$RepositoryID]", 'Set')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [SelectedRepository] - [Set-GitHubSecretSelectedRepository] - Done"
#endregion [functions] - [public] - [Secrets] - [SelectedRepository] - [Set-GitHubSecretSelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - [SelectedRepository] - Done"
#endregion [functions] - [public] - [Secrets] - [SelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Secrets] - Done"
#endregion [functions] - [public] - [Secrets]
#region    [functions] - [public] - [Status]
Write-Debug "[$scriptName] - [functions] - [public] - [Status] - Processing folder"
#region    [functions] - [public] - [Status] - [Get-GitHubScheduledMaintenance]
Write-Debug "[$scriptName] - [functions] - [public] - [Status] - [Get-GitHubScheduledMaintenance] - Importing"
function Get-GitHubScheduledMaintenance {
    <#
        .SYNOPSIS
        Gets the status of GitHub scheduled maintenance

        .DESCRIPTION
        Scheduled maintenances are planned outages, upgrades, or general notices that you're working
        on infrastructure and disruptions may occurr. A close sibling of Incidents, each usually goes
        through a progression of statuses listed below, with an impact calculated from a blend of
        component statuses (or an optional override).

        Status: Scheduled, In Progress, Verifying, or Completed
        Impact: None (black), Minor (yellow), Major (orange), or Critical (red)

        .EXAMPLE
        Get-GitHubScheduledMaintenance

        Get a list of the 50 most recent scheduled maintenances.
        This includes scheduled maintenances as described in the above two endpoints, as well as those in the Completed state.

        .EXAMPLE
        Get-GitHubScheduledMaintenance -Active

        Get a list of any active maintenances.

        .EXAMPLE
        Get-GitHubScheduledMaintenance -Upcoming

        Get a list of any upcoming maintenances.

        .NOTES
        [Scheduled maintenances](https://www.githubstatus.com/api#scheduled-maintenances)

        .LINK
        https://psmodule.io/GitHub/Functions/Status/Get-GitHubScheduledMaintenance
    #>
    [CmdletBinding()]
    param(
        # Get a list of any active maintenances.
        # This endpoint will only return scheduled maintenances in the In Progress or Verifying state.
        [Parameter()]
        [switch] $Active,

        # Get a list of any upcoming maintenances.
        # This endpoint will only return scheduled maintenances still in the Scheduled state.
        [Parameter()]
        [switch] $Upcoming,

        # The stamp to check status for.
        [Parameter()]
        [ValidateSet('Public', 'Europe', 'Australia', 'US')]
        [string] $Stamp = 'Public'
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $baseURL = $script:StatusBaseURL[$Stamp]

        if ($Active) {
            $APIURI = "$baseURL/api/v2/scheduled-maintenances/active.json"
            $response = Invoke-RestMethod -Uri $APIURI -Method Get
            $response.scheduled_maintenances
            return
        }

        if ($Upcoming) {
            $APIURI = "$baseURL/api/v2/scheduled-maintenances/upcoming.json"
            $response = Invoke-RestMethod -Uri $APIURI -Method Get
            $response.scheduled_maintenances
            return
        }

        $APIURI = "$baseURL/api/v2/scheduled-maintenances.json"
        $response = Invoke-RestMethod -Uri $APIURI -Method Get
        $response.scheduled_maintenances

    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Status] - [Get-GitHubScheduledMaintenance] - Done"
#endregion [functions] - [public] - [Status] - [Get-GitHubScheduledMaintenance]
#region    [functions] - [public] - [Status] - [Get-GitHubStatus]
Write-Debug "[$scriptName] - [functions] - [public] - [Status] - [Get-GitHubStatus] - Importing"
function Get-GitHubStatus {
    <#
        .SYNOPSIS
        Gets the status of GitHub services

        .DESCRIPTION
        Get a summary of the status page, including a status indicator, component statuses, unresolved incidents,
        and any upcoming or in-progress scheduled maintenances. Get the status rollup for the whole page. This endpoint
        includes an indicator - one of none, minor, major, or critical, as well as a human description of the blended
        component status. Examples of the blended status include "All Systems Operational", "Partial System Outage",
        and "Major Service Outage".

        .EXAMPLE
        Get-GitHubStatus

        Gets the status of GitHub services

        .EXAMPLE
        Get-GitHubStatus -Summary

        Gets a summary of the status page, including a status indicator, component statuses, unresolved incidents,
        and any upcoming or in-progress scheduled maintenances.

        .NOTES
        [Summary](https://www.githubstatus.com/api#summary)
        [Status](https://www.githubstatus.com/api#status)

        .LINK
        https://psmodule.io/GitHub/Functions/Status/Get-GitHubStatus
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # Gets a summary of the status page, including a status indicator, component statuses, unresolved incidents,
        # and any upcoming or in-progress scheduled maintenances.
        [Parameter()]
        [switch] $Summary,

        # The stamp to check status for.
        [Parameter()]
        [ValidateSet('Public', 'Europe', 'Australia', 'US')]
        [string] $Stamp = 'Public'
    )
    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $baseURL = $script:StatusBaseURL[$Stamp]

        if ($Summary) {
            $APIURI = "$baseURL/api/v2/summary.json"
            $response = Invoke-RestMethod -Uri $APIURI -Method Get
            $response
            return
        }

        $APIURI = "$baseURL/api/v2/status.json"
        $response = Invoke-RestMethod -Uri $APIURI -Method Get
        $response.status

    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Status] - [Get-GitHubStatus] - Done"
#endregion [functions] - [public] - [Status] - [Get-GitHubStatus]
#region    [functions] - [public] - [Status] - [Get-GitHubStatusComponent]
Write-Debug "[$scriptName] - [functions] - [public] - [Status] - [Get-GitHubStatusComponent] - Importing"
function Get-GitHubStatusComponent {
    <#
        .SYNOPSIS
        Gets the status of GitHub components

        .DESCRIPTION
        Get the components for the page. Each component is listed along with its status - one of operational,
        degraded_performance, partial_outage, or major_outage.

        .EXAMPLE
        Get-GitHubStatusComponent

        Gets the status of GitHub components

        .NOTES
        [Components](https://www.githubstatus.com/api#components)

        .LINK
        https://psmodule.io/GitHub/Functions/Status/Get-GitHubStatusComponent
    #>
    [OutputType([pscustomobject[]])]
    [Alias('Get-GitHubStatusComponents')]
    [CmdletBinding()]
    param(
        # The stamp to check status for.
        [Parameter()]
        [ValidateSet('Public', 'Europe', 'Australia', 'US')]
        [string] $Stamp = 'Public'
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $baseURL = $script:StatusBaseURL[$Stamp]

        $APIURI = "$baseURL/api/v2/components.json"
        $response = Invoke-RestMethod -Uri $APIURI -Method Get
        $response.components
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Status] - [Get-GitHubStatusComponent] - Done"
#endregion [functions] - [public] - [Status] - [Get-GitHubStatusComponent]
#region    [functions] - [public] - [Status] - [Get-GitHubStatusIncident]
Write-Debug "[$scriptName] - [functions] - [public] - [Status] - [Get-GitHubStatusIncident] - Importing"
function Get-GitHubStatusIncident {
    <#
        .SYNOPSIS
        Gets the status of GitHub incidents

        .DESCRIPTION
        Incidents are the cornerstone of any status page, being composed of many incident updates.
        Each incident usually goes through a progression of statuses listed below, with an impact
        calculated from a blend of component statuses (or an optional override).

        Status: Investigating, Identified, Monitoring, Resolved, or Postmortem
        Impact: None (black), Minor (yellow), Major (orange), or Critical (red)

        .EXAMPLE
        Get-GitHubStatusIncident

        Gets the status of GitHub incidents

        .EXAMPLE
        Get-GitHubStatusIncident -Unresolved

        Gets the status of GitHub incidents that are unresolved

        .NOTES
        [Incidents](https://www.githubstatus.com/api#incidents)

        .LINK
        https://psmodule.io/GitHub/Functions/Status/Get-GitHubStatusIncident
    #>
    [OutputType([pscustomobject[]])]
    [Alias('Get-GitHubStatusIncidents')]
    [CmdletBinding()]
    param(
        # Gets the status of GitHub incidents that are unresolved
        [Parameter()]
        [switch] $Unresolved,

        # The stamp to check status for.
        [Parameter()]
        [ValidateSet('Public', 'Europe', 'Australia', 'US')]
        [string] $Stamp = 'Public'
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        $baseURL = $script:StatusBaseURL[$Stamp]

        if ($Unresolved) {
            $APIURI = "$baseURL/api/v2/incidents/unresolved.json"
            $response = Invoke-RestMethod -Uri $APIURI -Method Get
            $response.incidents
            return
        }

        $APIURI = "$baseURL/api/v2/incidents.json"
        $response = Invoke-RestMethod -Uri $APIURI -Method Get
        $response.incidents
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Status] - [Get-GitHubStatusIncident] - Done"
#endregion [functions] - [public] - [Status] - [Get-GitHubStatusIncident]
Write-Debug "[$scriptName] - [functions] - [public] - [Status] - Done"
#endregion [functions] - [public] - [Status]
#region    [functions] - [public] - [Teams]
Write-Debug "[$scriptName] - [functions] - [public] - [Teams] - Processing folder"
#region    [functions] - [public] - [Teams] - [completers]
Write-Debug "[$scriptName] - [functions] - [public] - [Teams] - [completers] - Importing"
Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport |
        Where-Object { $_ -like '*GitHubTeam' }) -ParameterName Name -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter

    Get-GitHubTeam -Organization $fakeBoundParameter.Organization | Where-Object { $_.Name -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Name)
    }
}

Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport) -ParameterName Team -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters

    $context = Resolve-GitHubContext -Context $fakeBoundParameters.Context
    $organization = $fakeBoundParameters.Organization ?? $fakeBoundParameters.Owner
    Get-GitHubTeam -Organization $organization -Context $context | Where-Object { $_.Slug -like "*$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_.Slug, $_.Slug, 'ParameterValue', $_.Slug)
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Teams] - [completers] - Done"
#endregion [functions] - [public] - [Teams] - [completers]
#region    [functions] - [public] - [Teams] - [Get-GitHubTeam]
Write-Debug "[$scriptName] - [functions] - [public] - [Teams] - [Get-GitHubTeam] - Importing"
function Get-GitHubTeam {
    <#
        .SYNOPSIS
        List teams from an org or get a team by name

        .DESCRIPTION
        Lists all teams in an organization that are visible to the authenticated user or gets a team using the team's slug.
        To create the slug, GitHub replaces special characters in the name string, changes all words to lowercase,
        and replaces spaces with a - separator. For example, "My TEam Näme" would become my-team-name.

        .EXAMPLE
        Get-GitHubTeam -Organization 'GitHub'

        Gets all teams in the `github` organization.

        .EXAMPLE
        Get-GitHubTeam -Organization 'github' -Slug 'my-team-name'

        Gets the team with the slug 'my-team-name' in the `github` organization.

        .EXAMPLE
        Get-GitHubTeam -Organization 'github' -Repository 'my-repo'

        Lists all teams that have access to the 'my-repo' repository owned by `github`.

        .LINK
        https://psmodule.io/GitHub/Functions/Teams/Get-GitHubTeam
    #>
    [OutputType([GitHubTeam])]
    [CmdletBinding(DefaultParameterSetName = 'List all teams in an organization')]
    param(
        # The organization name. The name is not case sensitive.
        # If not provided, the owner from the context will be used.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Organization,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'List all teams with access to a repository')]
        [string] $Repository,

        # The slug of the team name.
        [Parameter(Mandatory, ParameterSetName = 'Get a specific team by slug')]
        [string] $Slug,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $params = @{
            Organization = $Organization
            Context      = $Context
        }
        switch ($PSCmdlet.ParameterSetName) {
            'Get a specific team by slug' {
                Get-GitHubTeamBySlug @params -Slug $Slug
            }
            'List all teams with access to a repository' {
                Get-GitHubTeamListByRepo @params -Repository $Repository
            }
            default {
                Get-GitHubTeamListByOrg @params
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Teams] - [Get-GitHubTeam] - Done"
#endregion [functions] - [public] - [Teams] - [Get-GitHubTeam]
#region    [functions] - [public] - [Teams] - [New-GitHubTeam]
Write-Debug "[$scriptName] - [functions] - [public] - [Teams] - [New-GitHubTeam] - Importing"
function New-GitHubTeam {
    <#
        .SYNOPSIS
        Create a team

        .DESCRIPTION
        To create a team, the authenticated user must be a member or owner of `{org}`. By default, organization members can create teams.
        Organization owners can limit team creation to organization owners. For more information, see
        "[Setting team creation permissions](https://docs.github.com/articles/setting-team-creation-permissions-in-your-organization)."

        When you create a new team, you automatically become a team maintainer without explicitly adding yourself to the optional array of
        `maintainers`. For more information, see
        "[About teams](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/about-teams)".

        .EXAMPLE
        $params = @{
            Organization  = 'github'
            Name          = 'team-name'
            Description   = 'A new team'
            Visible       = $true
            Notifications = $true
        }
        New-GitHubTeam @params

        .LINK
        https://psmodule.io/GitHub/Functions/Teams/New-GitHubTeam

        .NOTES
        [Create a team](https://docs.github.com/rest/teams/teams#create-a-team)
    #>
    [OutputType([GitHubTeam])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The organization name. The name is not case sensitive.
        # If not provided, the organization from the context is used.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Organization,

        # The name of the team.
        [Parameter(Mandatory)]
        [string] $Name,

        # The description of the team.
        [Parameter()]
        [string] $Description,

        # List GitHub IDs for organization members who will become team maintainers.
        [Parameter()]
        [string[]] $Maintainers,

        # The level of privacy this team should have. The options are:
        # For a non-nested team:
        # - secret - only visible to organization owners and members of this team.
        # - closed - visible to all members of this organization.
        # Default: secret
        # For a parent or child team:
        # - closed - visible to all members of this organization.
        # Default for child team: closed
        [Parameter()]
        [bool] $Visible = $true,

        # The notification setting the team has chosen. The options are:
        # notifications_enabled - team members receive notifications when the team is @mentioned.
        # notifications_disabled - no one receives notifications.
        # Default: notifications_enabled
        [Parameter()]
        [bool] $Notifications = $true,

        # The ID of a team to set as the parent team.
        [Parameter()]
        [System.Nullable[int]] $ParentTeamID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT

        if (-not $Visible -and $ParentTeamID -gt 0) {
            throw 'A nested team cannot be secret (invisible).'
        }
    }

    process {
        $body = @{
            name                 = $Name
            description          = $Description
            maintainers          = $Maintainers
            privacy              = $Visible ? 'closed' : 'secret'
            notification_setting = $Notifications ? 'notifications_enabled' : 'notifications_disabled'
            parent_team_id       = $ParentTeamID
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/orgs/$Organization/teams"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("team '$Name' in '$Organization'", 'Create')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                foreach ($team in $_.Response) {
                    [GitHubTeam]::new($team, $Organization)
                }
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Teams] - [New-GitHubTeam] - Done"
#endregion [functions] - [public] - [Teams] - [New-GitHubTeam]
#region    [functions] - [public] - [Teams] - [Remove-GitHubTeam]
Write-Debug "[$scriptName] - [functions] - [public] - [Teams] - [Remove-GitHubTeam] - Importing"
function Remove-GitHubTeam {
    <#
        .SYNOPSIS
        Delete a team

        .DESCRIPTION
        To delete a team, the authenticated user must be an organization owner or team maintainer.
        If you are an organization owner, deleting a parent team will delete all of its child teams as well.

        .EXAMPLE
        Remove-GitHubTeam -Organization 'github' -Name 'team-name'

        .NOTES
        [Delete a team](https://docs.github.com/rest/teams/teams#delete-a-team)

        .LINK
        https://psmodule.io/GitHub/Functions/Teams/Remove-GitHubTeam
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        # The organization name. The name is not case sensitive.
        # If not provided, the organization from the context is used.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Organization,

        # The slug of the team name.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Slug,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/orgs/$Organization/teams/$Slug"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("$Organization/$Slug", 'DELETE')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Teams] - [Remove-GitHubTeam] - Done"
#endregion [functions] - [public] - [Teams] - [Remove-GitHubTeam]
#region    [functions] - [public] - [Teams] - [Update-GitHubTeam]
Write-Debug "[$scriptName] - [functions] - [public] - [Teams] - [Update-GitHubTeam] - Importing"
function Update-GitHubTeam {
    <#
        .SYNOPSIS
        Update a team

        .DESCRIPTION
        To edit a team, the authenticated user must either be an organization owner or a team maintainer.

        .EXAMPLE
        $params = @{
            Organization  = 'github'
            Slug          = 'team-name'
            NewName       = 'new team name'
            Description   = 'A new team'
            Visible       = $true
            Notifications = $true
            ParentTeamID  = 123456
        }
        Update-GitHubTeam @params

        Updates the team with the slug 'team-name' in the `github` organization with the new name 'new team name', description 'A new team',
        visibility set to 'closed', notifications enabled, and the parent team ID set to 123456.

        .NOTES
        [Update a team](https://docs.github.com/rest/teams/teams#update-a-team)

        .LINK
        https://psmodule.io/GitHub/Functions/Teams/Update-GitHubTeam
    #>
    [OutputType([GitHubTeam])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The organization name. The name is not case sensitive.
        # If you do not provide this parameter, the command will use the organization from the context.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Organization,

        # The slug of the team name.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Slug,

        # The new team name.
        [Parameter()]
        [Alias()]
        [string] $NewName,

        # The description of the team.
        [Parameter()]
        [string] $Description,

        # The level of privacy this team should have. The options are:
        # For a non-nested team:
        # - secret - only visible to organization owners and members of this team.
        # - closed - visible to all members of this organization.
        # Default: secret
        # For a parent or child team:
        # - closed - visible to all members of this organization.
        # Default for child team: closed
        [Parameter()]
        [bool] $Visible,

        # The notification setting the team has chosen. The options are:
        # notifications_enabled - team members receive notifications when the team is @mentioned.
        # notifications_disabled - no one receives notifications.
        # Default: notifications_enabled
        [Parameter()]
        [bool] $Notifications,

        # The ID of a team to set as the parent team.
        [Parameter()]
        [int] $ParentTeamID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            name                 = $NewName
            description          = $Description
            privacy              = $PSBoundParameters.ContainsKey('Visible') ? ($Visible ? 'closed' : 'secret') : $null
            notification_setting = $PSBoundParameters.ContainsKey('Notifications') ? (
                $Notifications ? 'notifications_enabled' : 'notifications_disabled'
            ) : $null
            parent_team_id       = $ParentTeamID -eq 0 ? $null : $ParentTeamID
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'PATCH'
            APIEndpoint = "/orgs/$Organization/teams/$Slug"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("$Organization/$Slug", 'Update')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                foreach ($team in $_.Response) {
                    [GitHubTeam]::new($team, $Organization)
                }
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Teams] - [Update-GitHubTeam] - Done"
#endregion [functions] - [public] - [Teams] - [Update-GitHubTeam]
Write-Debug "[$scriptName] - [functions] - [public] - [Teams] - Done"
#endregion [functions] - [public] - [Teams]
#region    [functions] - [public] - [Users]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - Processing folder"
#region    [functions] - [public] - [Users] - [Get-GitHubUser]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Get-GitHubUser] - Importing"
function Get-GitHubUser {
    <#
        .SYNOPSIS
        List user(s)

        .DESCRIPTION
        Get the authenticated user - if no parameters are provided.
        Get a given user - if a username is provided.
        Lists all users, in the order that they signed up on GitHub - if '-All' is provided.

        .EXAMPLE
        Get-GitHubUser

        Get the authenticated user.

        .EXAMPLE
        Get-GitHubUser -Name 'octocat'

        Get the 'octocat' user.

        .EXAMPLE
        Get-GitHubUser -All -Since 17722253

        Get a list of users, starting with the user 'MariusStorhaug'.

        .OUTPUTS
        GitHubOwner

        .NOTES
        [Get the authenticated user](https://docs.github.com/rest/users/users)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Get-GitHubUser
    #>
    [OutputType([GitHubOwner])]
    [Alias('Get-GitHubOwner')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSReviewUnusedParameter', 'All',
        Justification = 'Parameter is used in dynamic parameter validation.'
    )]
    [CmdletBinding(DefaultParameterSetName = 'Authenticated user')]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ParameterSetName = 'By name',
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Name,

        # List all users. Use '-Since' to start at a specific user ID.
        [Parameter(
            Mandatory,
            ParameterSetName = 'All users'
        )]
        [switch] $All,

        # A user ID. Only return users with an ID greater than this ID.
        [Parameter(ParameterSetName = 'All users')]
        [int] $Since = 0,

        # The number of results per page (max 100).
        [Parameter(ParameterSetName = 'All users')]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'By name' {
                Get-GitHubUserByName -Name $Name -Context $Context
            }
            'All users' {
                Get-GitHubAllUser -Since $Since -PerPage $PerPage -Context $Context
            }
            default {
                Get-GitHubMyUser -Context $Context
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Get-GitHubUser] - Done"
#endregion [functions] - [public] - [Users] - [Get-GitHubUser]
#region    [functions] - [public] - [Users] - [Update-GitHubUser]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Update-GitHubUser] - Importing"
filter Update-GitHubUser {
    <#
        .SYNOPSIS
        Update the authenticated user

        .DESCRIPTION
        **Note:** If your email is set to private and you send an `email` parameter as part of this request
        to update your profile, your privacy settings are still enforced: the email address will not be
        displayed on your public profile or via the API.

        .EXAMPLE
        Update-GitHubUser -Name 'octocat'

        Update the authenticated user's name to 'octocat'

        .EXAMPLE
        Update-GitHubUser -Location 'San Francisco'

        Update the authenticated user's location to 'San Francisco'

        .EXAMPLE
        Update-GitHubUser -Hireable $true -Description 'I love programming'

        Update the authenticated user's hiring availability to 'true' and their description to 'I love programming'

        .NOTES
        [Update the authenticated user](https://docs.github.com/rest/users/users#update-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Update-GitHubUser
    #>
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The display name of the user.
        [Parameter()]
        [string] $DisplayName,

        # The publicly visible email address of the user.
        [Parameter()]
        [string] $Email,

        # The new site for the user.
        [Parameter()]
        [Alias('Blog')]
        [string] $Website,

        # The new Twitter username of the user.
        [Parameter()]
        [string] $TwitterUsername,

        # The new company of the user.
        [Parameter()]
        [string] $Company,

        # The new location of the user.
        [Parameter()]
        [string] $Location,

        # The new hiring availability of the user.
        [Parameter()]
        [boolean] $Hireable,

        # The new short biography of the user.
        [Parameter()]
        [Alias('Bio')]
        [string] $Description,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            name             = $DisplayName
            email            = $Email
            blog             = $Website
            twitter_username = $TwitterUsername
            company          = $Company
            location         = $Location
            hireable         = $Hireable
            bio              = $Description
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'PATCH'
            APIEndpoint = '/user'
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess('authenticated user', 'Set')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                [GitHubUser]::New($_.Response)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Update-GitHubUser] - Done"
#endregion [functions] - [public] - [Users] - [Update-GitHubUser]
#region    [functions] - [public] - [Users] - [Blocking]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Blocking] - Processing folder"
#region    [functions] - [public] - [Users] - [Blocking] - [Block-GitHubUser]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Blocking] - [Block-GitHubUser] - Importing"
filter Block-GitHubUser {
    <#
        .SYNOPSIS
        Block a user from user or an organization.

        .DESCRIPTION
        Blocks the given user and returns true.
        If the user cannot be blocked false is returned.

        .EXAMPLE
        Block-GitHubUser -Username 'octocat'

        Blocks the user 'octocat' for the authenticated user.
        Returns $true if successful, $false if not.

        .EXAMPLE
        Block-GitHubUser -Organization 'GitHub' -Username 'octocat'

        Blocks the user 'octocat' from the organization 'GitHub'.
        Returns $true if successful, $false if not.

        .NOTES
        [Block a user](https://docs.github.com/rest/users/blocking#block-a-user)
        [Block a user from an organization](https://docs.github.com/rest/orgs/blocking#block-a-user-from-an-organization)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Blocking/Block-GitHubUser
    #>
    [OutputType([bool])]
    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory
        )]
        [Alias('login')]
        [string] $Username,

        # The organization name. The name is not case sensitive.
        [Parameter(
            Mandatory,
            ParameterSetName = 'Organization'
        )]
        [Parameter(
            ParameterSetName = '__AllParameterSets'
        )]
        [string] $Organization,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'Organization' {
                Block-GitHubUserByOrganization -Organization $Organization -Username $Username -Context $Context
            }
            '__AllParameterSets' {
                Block-GitHubUserByUser -Username $Username -Context $Context
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Blocking] - [Block-GitHubUser] - Done"
#endregion [functions] - [public] - [Users] - [Blocking] - [Block-GitHubUser]
#region    [functions] - [public] - [Users] - [Blocking] - [Get-GitHubBlockedUser]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Blocking] - [Get-GitHubBlockedUser] - Importing"
filter Get-GitHubBlockedUser {
    <#
        .SYNOPSIS
        List blocked users.

        .DESCRIPTION
        List the users that are blocked on your personal account or a given organization.

        .EXAMPLE
        Get-GitHubBlockedUser

        Returns a list of users blocked by the authenticated user.

        .EXAMPLE
        Get-GitHubBlockedUser -Organization 'github'

        Lists all users blocked by the organization `github`.

        .NOTES
        [List users blocked by the authenticated user](https://docs.github.com/rest/users/blocking#list-users-blocked-by-the-authenticated-user)
        [List users blocked by an organization](https://docs.github.com/rest/orgs/blocking#list-users-blocked-by-an-organization)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Blocking/Get-GitHubBlockedUser
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The organization name. The name is not case sensitive.
        [Parameter(
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Organization,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT

        if ([string]::IsNullOrEmpty($Organization)) {
            $Organization = $Context.Owner
        }
        Write-Debug "Organization: [$Organization]"
    }

    process {
        if ($Organization) {
            Get-GitHubBlockedUserByOrganization -Organization $Organization -PerPage $PerPage -Context $Context
        } else {
            Get-GitHubBlockedUserByUser -PerPage $PerPage -Context $Context
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Blocking] - [Get-GitHubBlockedUser] - Done"
#endregion [functions] - [public] - [Users] - [Blocking] - [Get-GitHubBlockedUser]
#region    [functions] - [public] - [Users] - [Blocking] - [Test-GitHubBlockedUser]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Blocking] - [Test-GitHubBlockedUser] - Importing"
filter Test-GitHubBlockedUser {
    <#
        .SYNOPSIS
        Check if a user is blocked by the authenticated user or an organization.

        .DESCRIPTION
        Returns a 204 if the given user is blocked by the authenticated user or organization.
        Returns a 404 if the given user is not blocked, or if the given user account has been identified as spam by GitHub.

        .EXAMPLE
        Test-GitHubBlockedUser -Username 'octocat'

        Checks if the user `octocat` is blocked by the authenticated user.
        Returns true if the user is blocked, false if not.

        .EXAMPLE
        Test-GitHubBlockedUser -Organization 'github' -Username 'octocat'

        Checks if the user `octocat` is blocked by the organization `github`.
        Returns true if the user is blocked, false if not.

        .NOTES
        [Check if a user is blocked by the authenticated user](https://docs.github.com/rest/users/blocking#check-if-a-user-is-blocked-by-the-authenticated-user)
        [Check if a user is blocked by an organization](https://docs.github.com/rest/orgs/blocking#check-if-a-user-is-blocked-by-an-organization)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Blocking/Test-GitHubBlockedUser
    #>
    [OutputType([bool])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The organization name. The name is not case sensitive.
        [Parameter(
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Organization,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT

        if ([string]::IsNullOrEmpty($Organization)) {
            $Organization = $Context.Owner
        }
        Write-Debug "Organization: [$Organization]"
    }

    process {
        if ($Organization) {
            Test-GitHubBlockedUserByOrganization -Organization $Organization -Username $Username -PerPage $PerPage -Context $Context
        } else {
            Test-GitHubBlockedUserByUser -Username $Username -PerPage $PerPage -Context $Context
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Blocking] - [Test-GitHubBlockedUser] - Done"
#endregion [functions] - [public] - [Users] - [Blocking] - [Test-GitHubBlockedUser]
#region    [functions] - [public] - [Users] - [Blocking] - [Unblock-GitHubUser]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Blocking] - [Unblock-GitHubUser] - Importing"
filter Unblock-GitHubUser {
    <#
        .SYNOPSIS
        Unblock a user

        .DESCRIPTION
        Unblocks the given user and returns true.

        .EXAMPLE
        Unblock-GitHubUser -Username 'octocat'

        Unblocks the user 'octocat' for the authenticated user.
        Returns $true if successful.

        .EXAMPLE
        Unblock-GitHubUser -Organization 'GitHub' -Username 'octocat'

        Unblocks the user 'octocat' from the organization 'GitHub'.
        Returns $true if successful.

        .NOTES
        [Unblock a user](https://docs.github.com/rest/users/blocking#unblock-a-user)
        [Unblock a user from an organization](https://docs.github.com/rest/orgs/blocking#unblock-a-user-from-an-organization)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Blocking/Unblock-GitHubUser
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The organization name. The name is not case sensitive.
        [Parameter(
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Organization,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT

        if ([string]::IsNullOrEmpty($Organization)) {
            $Organization = $Context.Owner
        }
        Write-Debug "Organization: [$Organization]"
    }

    process {
        if ($Organization) {
            Unblock-GitHubUserByOrganization -Organization $Organization -Username $Username -Context $Context
        } else {
            Unblock-GitHubUserByUser -Username $Username -Context $Context
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Blocking] - [Unblock-GitHubUser] - Done"
#endregion [functions] - [public] - [Users] - [Blocking] - [Unblock-GitHubUser]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Blocking] - Done"
#endregion [functions] - [public] - [Users] - [Blocking]
#region    [functions] - [public] - [Users] - [Emails]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Emails] - Processing folder"
#region    [functions] - [public] - [Users] - [Emails] - [Add-GitHubUserEmail]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Emails] - [Add-GitHubUserEmail] - Importing"
filter Add-GitHubUserEmail {
    <#
        .SYNOPSIS
        Add an email address for the authenticated user

        .DESCRIPTION
        This endpoint is accessible with the `user` scope.

        .EXAMPLE
        Add-GitHubUserEmail -Email 'octocat@github.com','firstname.lastname@work.com'

        Adds the email addresses `octocat@github.com` and `firstname.lastname@work.com` to the authenticated user's account.

        .NOTES
        [Add an email address for the authenticated user](https://docs.github.com/rest/users/emails#add-an-email-address-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Emails/Add-GitHubUserEmail
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # Adds one or more email addresses to your GitHub account.
        # Must contain at least one email address.
        # Note: Alternatively, you can pass a single email address or an array of emails addresses directly,
        # but we recommend that you pass an object using the emails key.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string[]] $Email,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            emails = $Email
        }

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = '/user/emails'
            Body        = $body
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Emails] - [Add-GitHubUserEmail] - Done"
#endregion [functions] - [public] - [Users] - [Emails] - [Add-GitHubUserEmail]
#region    [functions] - [public] - [Users] - [Emails] - [Get-GitHubUserEmail]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Emails] - [Get-GitHubUserEmail] - Importing"
filter Get-GitHubUserEmail {
    <#
        .SYNOPSIS
        List email addresses for the authenticated user

        .DESCRIPTION
        Lists all of your email addresses, and specifies which one is visible to the public. This endpoint is accessible with the `user:email` scope.
        Specifying '-Public' will return only the publicly visible email address, which you can set with the [Set primary email visibility for the
        authenticated user](https://docs.github.com/rest/users/emails#set-primary-email-visibility-for-the-authenticated-user) endpoint.

        .EXAMPLE
        Get-GitHubUserEmail

        Gets all email addresses for the authenticated user.

        .EXAMPLE
        Get-GitHubUserEmail -Public

        Gets the publicly visible email address for the authenticated user.

        .NOTES
        [List email addresses for the authenticated user](https://docs.github.com/rest/users/emails#list-email-addresses-for-the-authenticated-user)
        [List public email addresses for the authenticated user](https://docs.github.com/rest/users/emails#list-public-email-addresses-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Emails/Get-GitHubUserEmail
    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [CmdletBinding()]
    param(
        # Get the publicly visible email address for the authenticated user.
        [Parameter()]
        [switch] $Public,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $params = @{
            PerPage = $PerPage
            Context = $Context
        }
        if ($Public) {
            Get-GitHubUserPublicEmail @params
        } else {
            Get-GitHubUserAllEmail @params
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Emails] - [Get-GitHubUserEmail] - Done"
#endregion [functions] - [public] - [Users] - [Emails] - [Get-GitHubUserEmail]
#region    [functions] - [public] - [Users] - [Emails] - [Remove-GitHubUserEmail]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Emails] - [Remove-GitHubUserEmail] - Importing"
filter Remove-GitHubUserEmail {
    <#
        .SYNOPSIS
        Delete an email address for the authenticated user

        .DESCRIPTION
        This endpoint is accessible with the `user` scope.

        .EXAMPLE
        Remove-GitHubUserEmail -Emails 'octocat@github.com','firstname.lastname@work.com'

        Removes the email addresses `octocat@github.com` and `firstname.lastname@work.com` from the authenticated user's account.

        .NOTES
        [Delete an email address for the authenticated user](https://docs.github.com/rest/users/emails#delete-an-email-address-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Emails/Remove-GitHubUserEmail
    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # Email addresses associated with the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string[]] $Email,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            emails = $Email
        }

        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = '/user/emails'
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Email addresses [$($Email -join ', ')]", 'DELETE')) {
            $null = Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Emails] - [Remove-GitHubUserEmail] - Done"
#endregion [functions] - [public] - [Users] - [Emails] - [Remove-GitHubUserEmail]
#region    [functions] - [public] - [Users] - [Emails] - [Update-GitHubUserEmailVisibility]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Emails] - [Update-GitHubUserEmailVisibility] - Importing"
filter Update-GitHubUserEmailVisibility {
    <#
        .SYNOPSIS
        Set primary email visibility for the authenticated user

        .DESCRIPTION
        Sets the visibility for your primary email addresses.

        .EXAMPLE
        Set-GitHubUserEmailVisibility -Visibility Public

        Sets the visibility for your primary email addresses to public.

        .EXAMPLE
        Set-GitHubUserEmailVisibility -Visibility Private

        Sets the visibility for your primary email addresses to private.

        .NOTES
        [Set primary email visibility for the authenticated user](https://docs.github.com/rest/users/emails#set-primary-email-visibility-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Emails/Update-GitHubUserEmailVisibility
    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # Denotes whether an email is publicly visible.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [ValidateSet('Public', 'Private')]
        [string] $Visibility,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            visibility = $Visibility.ToLower()
        }

        $apiParams = @{
            Method      = 'PATCH'
            APIEndpoint = '/user/email/visibility'
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Email visibility [$Visibility]", 'Set')) {
            $null = Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Emails] - [Update-GitHubUserEmailVisibility] - Done"
#endregion [functions] - [public] - [Users] - [Emails] - [Update-GitHubUserEmailVisibility]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Emails] - Done"
#endregion [functions] - [public] - [Users] - [Emails]
#region    [functions] - [public] - [Users] - [Followers]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Followers] - Processing folder"
#region    [functions] - [public] - [Users] - [Followers] - [Add-GitHubUserFollowing]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Followers] - [Add-GitHubUserFollowing] - Importing"
filter Add-GitHubUserFollowing {
    <#
        .SYNOPSIS
        Follow a user

        .DESCRIPTION
        Note that you'll need to set `Content-Length` to zero when calling out to this endpoint.
        For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
        Following a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.

        .EXAMPLE
        Follow-GitHubUser -Username 'octocat'

        Follows the user with the username 'octocat'.

        .NOTES
        [Follow a user](https://docs.github.com/rest/users/followers#follow-a-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Followers/Add-GitHubUserFollowing
    #>
    [OutputType([pscustomobject])]
    [Alias('Follow-GitHubUser')]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Username,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/user/following/$Username"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Followers] - [Add-GitHubUserFollowing] - Done"
#endregion [functions] - [public] - [Users] - [Followers] - [Add-GitHubUserFollowing]
#region    [functions] - [public] - [Users] - [Followers] - [Get-GitHubUserFollower]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Followers] - [Get-GitHubUserFollower] - Importing"
filter Get-GitHubUserFollower {
    <#
        .SYNOPSIS
        List followers of a given user or the authenticated user

        .DESCRIPTION
        Lists the people following a given user or the authenticated user.

        .EXAMPLE
        Get-GitHubUserFollower

        Gets all followers of the authenticated user.

        .EXAMPLE
        Get-GitHubUserFollower -Username 'octocat'

        Gets all followers of the user 'octocat'.

        .NOTES
        [List followers of the authenticated user](https://docs.github.com/rest/users/followers#list-followers-of-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Followers/Get-GitHubUserFollower
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $params = @{
            PerPage = $PerPage
            Context = $Context
        }
        if ($Username) {
            Get-GitHubUserFollowersOfUser @params -Username $Username
        } else {
            Get-GitHubUserMyFollower @params
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Followers] - [Get-GitHubUserFollower] - Done"
#endregion [functions] - [public] - [Users] - [Followers] - [Get-GitHubUserFollower]
#region    [functions] - [public] - [Users] - [Followers] - [Get-GitHubUserFollowing]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Followers] - [Get-GitHubUserFollowing] - Importing"
filter Get-GitHubUserFollowing {
    <#
        .SYNOPSIS
        List the people a given user or the authenticated user follows

        .DESCRIPTION
        Lists the people who a given user or the authenticated user follows.

        .EXAMPLE
        Get-GitHubUserFollowing

        Gets all people the authenticated user follows.

        .EXAMPLE
        Get-GitHubUserFollowing -Username 'octocat'

        Gets all people that 'octocat' follows.

        .NOTES
        [List the people the authenticated user follows](https://docs.github.com/rest/users/followers#list-the-people-the-authenticated-user-follows)
        [List the people a user follows](https://docs.github.com/rest/users/followers#list-the-people-a-user-follows)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Followers/Get-GitHubUserFollowing
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('login')]
        [string] $Username,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $params = @{
            PerPage = $PerPage
            Context = $Context
        }
        if ($Username) {
            Get-GitHubUserFollowingUser @params -Username $Username
        } else {
            Get-GitHubUserFollowingMe @params
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Followers] - [Get-GitHubUserFollowing] - Done"
#endregion [functions] - [public] - [Users] - [Followers] - [Get-GitHubUserFollowing]
#region    [functions] - [public] - [Users] - [Followers] - [Remove-GitHubUserFollowing]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Followers] - [Remove-GitHubUserFollowing] - Importing"
filter Remove-GitHubUserFollowing {
    <#
        .SYNOPSIS
        Unfollow a user

        .DESCRIPTION
        Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.

        .EXAMPLE
        Unfollow-GitHubUser -Username 'octocat'

        Unfollows the user with the username 'octocat'.

        .NOTES
        [Unfollow a user](https://docs.github.com/rest/users/followers#unfollow-a-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Followers/Remove-GitHubUserFollowing
    #>
    [OutputType([pscustomobject])]
    [Alias('Unfollow-GitHubUser')]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Username,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/user/following/$Username"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("User [$Username]", 'Unfollow')) {
            Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Followers] - [Remove-GitHubUserFollowing] - Done"
#endregion [functions] - [public] - [Users] - [Followers] - [Remove-GitHubUserFollowing]
#region    [functions] - [public] - [Users] - [Followers] - [Test-GitHubUserFollowing]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Followers] - [Test-GitHubUserFollowing] - Importing"
filter Test-GitHubUserFollowing {
    <#
        .SYNOPSIS
        Check if a given user or the authenticated user follows a person

        .DESCRIPTION
        Returns a 204 if the given user or the authenticated user follows another user.
        Returns a 404 if the user is not followed by a given user or the authenticated user.

        .EXAMPLE
        Test-GitHubUserFollowing -Follows 'octocat'
        Test-GitHubUserFollowing 'octocat'

        Checks if the authenticated user follows the user 'octocat'.

        .EXAMPLE
        Test-GitHubUserFollowing -Username 'octocat' -Follows 'ratstallion'

        Checks if the user 'octocat' follows the user 'ratstallion'.

        .NOTES
        [Check if a person is followed by the authenticated user](https://docs.github.com/rest/users/followers#check-if-a-person-is-followed-by-the-authenticated-user)
        [Check if a user follows another user](https://docs.github.com/rest/users/followers#check-if-a-user-follows-another-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Followers/Test-GitHubUserFollowing
    #>
    [OutputType([bool])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [Alias('Test-GitHubUserFollows')]
    [CmdletBinding()]
    param(
        # The handle for the GitHub user account we want to check if is being followed.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Follows,

        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Username,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        if ($Username) {
            Test-GitHubUserFollowedByUser -Username $Username -Follows $Follows -Context $Context
        } else {
            Test-GitHubUserFollowedByMe -Username $Follows -Context $Context
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Followers] - [Test-GitHubUserFollowing] - Done"
#endregion [functions] - [public] - [Users] - [Followers] - [Test-GitHubUserFollowing]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Followers] - Done"
#endregion [functions] - [public] - [Users] - [Followers]
#region    [functions] - [public] - [Users] - [GPG-Keys]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [GPG-Keys] - Processing folder"
#region    [functions] - [public] - [Users] - [GPG-Keys] - [Add-GitHubUserGpgKey]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [GPG-Keys] - [Add-GitHubUserGpgKey] - Importing"
filter Add-GitHubUserGpgKey {
    <#
        .SYNOPSIS
        Create a GPG key for the authenticated user

        .DESCRIPTION
        Adds a GPG key to the authenticated user's GitHub account.
        Requires that you are authenticated via Basic Auth, or OAuth with at least `write:gpg_key`
        [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

        .EXAMPLE
        Add-GitHubUserGpgKey -Name 'GPG key for GitHub' -ArmoredPublicKey @'
        -----BEGIN PGP PUBLIC KEY BLOCK-----
        Version: GnuPG v1

        mQINBFnZ2ZIBEADQ2Z7Z7
        -----END PGP PUBLIC KEY BLOCK-----
        '@

        Adds a GPG key to the authenticated user's GitHub account.

        .NOTES
        [Create a GPG key for the authenticated user](https://docs.github.com/rest/users/gpg-keys#create-a-gpg-key-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/GPG-Keys/Add-GitHubUserGpgKey
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param (
        # A descriptive name for the new key.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [string] $Name,

        # A GPG key in ASCII-armored format.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('armored_public_key')]
        [string] $ArmoredPublicKey,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            name               = $Name
            armored_public_key = $ArmoredPublicKey
        }

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = '/user/gpg_keys'
            Body        = $body
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [GPG-Keys] - [Add-GitHubUserGpgKey] - Done"
#endregion [functions] - [public] - [Users] - [GPG-Keys] - [Add-GitHubUserGpgKey]
#region    [functions] - [public] - [Users] - [GPG-Keys] - [Get-GitHubUserGpgKey]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [GPG-Keys] - [Get-GitHubUserGpgKey] - Importing"
filter Get-GitHubUserGpgKey {
    <#
        .SYNOPSIS
        List GPG keys for a given user or the authenticated user

        .DESCRIPTION
        Lists a given user's or the current user's GPG keys.

        .EXAMPLE
        Get-GitHubUserGpgKey

        Gets all GPG keys for the authenticated user.

        .EXAMPLE
        Get-GitHubUserGpgKey -ID '1234567'

        Gets the GPG key with ID '1234567' for the authenticated user.

        .EXAMPLE
        Get-GitHubUserGpgKey -Username 'octocat'

        Gets all GPG keys for the 'octocat' user.

        .NOTES
        [List GPG keys for the authenticated user](https://docs.github.com/rest/users/gpg-keys#list-gpg-keys-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/GPG-Keys/Get-GitHubUserGpgKey
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName,
            ParameterSetName = 'Username'
        )]
        [string] $Username,

        # The ID of the GPG key.
        [Parameter(
            ParameterSetName = 'Me'
        )]
        [Alias('gpg_key_id')]
        [string] $ID,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'Username' {
                Get-GitHubUserGpgKeyForUser -Username $Username -PerPage $PerPage -Context $Context
            }
            'Me' {
                Get-GitHubUserMyGpgKeyById -ID $ID -Context $Context
            }
            default {
                Get-GitHubUserMyGpgKey -PerPage $PerPage -Context $Context
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [GPG-Keys] - [Get-GitHubUserGpgKey] - Done"
#endregion [functions] - [public] - [Users] - [GPG-Keys] - [Get-GitHubUserGpgKey]
#region    [functions] - [public] - [Users] - [GPG-Keys] - [Remove-GitHubUserGpgKey]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [GPG-Keys] - [Remove-GitHubUserGpgKey] - Importing"
filter Remove-GitHubUserGpgKey {
    <#
        .SYNOPSIS
        Delete a GPG key for the authenticated user

        .DESCRIPTION
        Removes a GPG key from the authenticated user's GitHub account.
        Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:gpg_key`
        [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

        .EXAMPLE
        Remove-GitHubUserGpgKey -ID '1234567'

        Gets the GPG key with ID '1234567' for the authenticated user.

        .NOTES
        [Delete a GPG key for the authenticated user](https://docs.github.com/rest/users/gpg-keys#delete-a-gpg-key-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/GPG-Keys/Remove-GitHubUserGpgKey
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        # The ID of the GPG key.
        [Parameter(
            Mandatory
        )]
        [Alias('gpg_key_id')]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/user/gpg_keys/$ID"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("GPG key with ID [$ID]", 'DELETE')) {
            Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [GPG-Keys] - [Remove-GitHubUserGpgKey] - Done"
#endregion [functions] - [public] - [Users] - [GPG-Keys] - [Remove-GitHubUserGpgKey]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [GPG-Keys] - Done"
#endregion [functions] - [public] - [Users] - [GPG-Keys]
#region    [functions] - [public] - [Users] - [Keys]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Keys] - Processing folder"
#region    [functions] - [public] - [Users] - [Keys] - [Add-GitHubUserKey]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Keys] - [Add-GitHubUserKey] - Importing"
filter Add-GitHubUserKey {
    <#
        .SYNOPSIS
        Create a public SSH key for the authenticated user

        .DESCRIPTION
        Adds a public SSH key to the authenticated user's GitHub account.
        Requires that you are authenticated via Basic Auth, or OAuth with at least `write:public_key`
        [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

        .EXAMPLE
        Add-GitHubUserKey -Title 'ssh-rsa AAAAB3NzaC1yc2EAAA' -Key '2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvv1234'

        Adds a new public SSH key to the authenticated user's GitHub account.

        .NOTES
        [Create a public SSH key for the authenticated user](https://docs.github.com/rest/users/keys#create-a-public-ssh-key-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Keys/Add-GitHubUserKey
    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Long links for documentation.')]
    [CmdletBinding()]
    param(
        # A descriptive name for the new key.
        [Parameter(
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('name')]
        [string] $Title,

        # The public SSH key to add to your GitHub account.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Key,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            title = $Title
            key   = $Key
        }

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = '/user/keys'
            Body        = $body
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Keys] - [Add-GitHubUserKey] - Done"
#endregion [functions] - [public] - [Users] - [Keys] - [Add-GitHubUserKey]
#region    [functions] - [public] - [Users] - [Keys] - [Get-GitHubUserKey]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Keys] - [Get-GitHubUserKey] - Importing"
filter Get-GitHubUserKey {
    <#
        .SYNOPSIS
        List public SSH keys for a given user or the authenticated user.

        .DESCRIPTION
        Lists a given user's or the current user's public SSH keys.
        For the authenticated users keys, it requires that you are authenticated via Basic Auth or via OAuth with
        at least `read:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
        Keys from a given user are accessible by anyone.

        .EXAMPLE
        Get-GitHubUserKey

        Gets all GPG keys for the authenticated user.

        .EXAMPLE
        Get-GitHubUserKey -ID '1234567'

        Gets the public SSH key with the ID '1234567' for the authenticated user.

        .EXAMPLE
        Get-GitHubUserKey -Username 'octocat'

        Gets all GPG keys for the 'octocat' user.

        .NOTES
        [List GPG keys for the authenticated user](https://docs.github.com/rest/users/gpg-keys#list-gpg-keys-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Keys/Get-GitHubUserKey
    #>
    [OutputType([pscustomobject])]
    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName,
            ParameterSetName = 'Username'
        )]
        [string] $Username,

        # The ID of the GPG key.
        [Parameter(
            ParameterSetName = 'Me'
        )]
        [Alias('gpg_key_id')]
        [string] $ID,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'Username' {
                Get-GitHubUserKeyForUser -Username $Username -PerPage $PerPage -Context $Context
            }
            'Me' {
                Get-GitHubUserMyKeyById -ID $ID -Context $Context
            }
            default {
                Get-GitHubUserMyKey -PerPage $PerPage -Context $Context
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Keys] - [Get-GitHubUserKey] - Done"
#endregion [functions] - [public] - [Users] - [Keys] - [Get-GitHubUserKey]
#region    [functions] - [public] - [Users] - [Keys] - [Remove-GitHubUserKey]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Keys] - [Remove-GitHubUserKey] - Importing"
filter Remove-GitHubUserKey {
    <#
        .SYNOPSIS
        Delete a public SSH key for the authenticated user

        .DESCRIPTION
        Removes a public SSH key from the authenticated user's GitHub account.
        Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:public_key`
        [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

        .EXAMPLE
        Remove-GitHubUserKey -ID '1234567'

        Deletes the public SSH key with ID '1234567' from the authenticated user's GitHub account.

        .NOTES
        [Delete a public SSH key for the authenticated user](https://docs.github.com/rest/users/keys#delete-a-public-ssh-key-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Keys/Remove-GitHubUserKey
    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        # The unique identifier of the key.
        [Parameter(
            Mandatory
        )]
        [Alias('key_id')]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/user/keys/$ID"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Key with ID [$ID]", 'DELETE')) {
            Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Keys] - [Remove-GitHubUserKey] - Done"
#endregion [functions] - [public] - [Users] - [Keys] - [Remove-GitHubUserKey]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Keys] - Done"
#endregion [functions] - [public] - [Users] - [Keys]
#region    [functions] - [public] - [Users] - [Social-Accounts]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Social-Accounts] - Processing folder"
#region    [functions] - [public] - [Users] - [Social-Accounts] - [Add-GitHubUserSocial]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Social-Accounts] - [Add-GitHubUserSocial] - Importing"
filter Add-GitHubUserSocial {
    <#
        .SYNOPSIS
        Add social accounts for the authenticated user

        .DESCRIPTION
        Add one or more social accounts to the authenticated user's profile. This endpoint is accessible with the `user` scope.

        .EXAMPLE
        Add-GitHubUserSocial -AccountUrls 'https://twitter.com/MyTwitterAccount', 'https://www.linkedin.com/company/MyCompany'

        Adds the Twitter and LinkedIn accounts to the authenticated user's profile.

        .NOTES
        [Add social accounts for the authenticated user](https://docs.github.com/rest/users/social-accounts#add-social-accounts-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Social-Accounts/Add-GitHubUserSocial
    #>
    [OutputType([void])]
    [Alias('Add-GitHubUserSocials')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Long links for documentation.')]
    [CmdletBinding()]
    param(
        # Full URLs for the social media profiles to add.
        [Parameter(Mandatory)]
        [Alias('account_urls', 'social_accounts', 'AccountUrls')]
        [string[]] $URL,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            account_urls = $URL
        }

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = '/user/social_accounts'
            Body        = $body
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Social-Accounts] - [Add-GitHubUserSocial] - Done"
#endregion [functions] - [public] - [Users] - [Social-Accounts] - [Add-GitHubUserSocial]
#region    [functions] - [public] - [Users] - [Social-Accounts] - [Remove-GitHubUserSocial]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Social-Accounts] - [Remove-GitHubUserSocial] - Importing"
filter Remove-GitHubUserSocial {
    <#
        .SYNOPSIS
        Delete social accounts for the authenticated user

        .DESCRIPTION
        Deletes one or more social accounts from the authenticated user's profile. This endpoint is accessible with the `user` scope.

        .PARAMETER AccountUrls
        Parameter description

        .EXAMPLE
        Remove-GitHubUserSocial -AccountUrls 'https://twitter.com/MyTwitterAccount'

        .NOTES
        [Delete social accounts for the authenticated user](https://docs.github.com/rest/users/social-accounts#delete-social-accounts-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/Social-Accounts/Remove-GitHubUserSocial
    #>
    [OutputType([void])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [Alias('Remove-GitHubUserSocials')]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # Full URLs for the social media profiles to add.
        [Parameter(Mandatory)]
        [Alias('account_urls', 'social_accounts', 'AccountUrls')]
        [string[]] $URL,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            account_urls = $URL
        }

        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = '/user/social_accounts'
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("Social accounts [$($URL -join ', ')]", 'DELETE')) {
            Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Social-Accounts] - [Remove-GitHubUserSocial] - Done"
#endregion [functions] - [public] - [Users] - [Social-Accounts] - [Remove-GitHubUserSocial]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [Social-Accounts] - Done"
#endregion [functions] - [public] - [Users] - [Social-Accounts]
#region    [functions] - [public] - [Users] - [SSH-Signing-Keys]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [SSH-Signing-Keys] - Processing folder"
#region    [functions] - [public] - [Users] - [SSH-Signing-Keys] - [Add-GitHubUserSigningKey]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [SSH-Signing-Keys] - [Add-GitHubUserSigningKey] - Importing"
filter Add-GitHubUserSigningKey {
    <#
        .SYNOPSIS
        Create a SSH signing key for the authenticated user

        .DESCRIPTION
        Creates an SSH signing key for the authenticated user's GitHub account.
        You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `write:ssh_signing_key` scope.
        For more information, see
        "[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/)."

        .EXAMPLE
        Add-GitHubUserSigningKey -Title 'ssh-rsa AAAAB3NzaC1yc2EAAA' -Key '2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvv1234'

        Creates a new SSH signing key for the authenticated user's GitHub account.

        .NOTES
        [Create a SSH signing key for the authenticated user](https://docs.github.com/rest/users/ssh-signing-keys#create-a-ssh-signing-key-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/SSH-Signing-Keys/Add-GitHubUserSigningKey
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Long links for documentation.')]
    [OutputType([pscustomobject])]
    [CmdletBinding()]
    param(
        # A descriptive name for the new key.
        [Parameter(
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [Alias('name')]
        [string] $Title,

        # The public SSH key to add to your GitHub account. For more information, see
        # [Checking for existing SSH keys](https://docs.github.com/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys)."
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $Key,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            title = $Title
            key   = $Key
        }

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = '/user/ssh_signing_keys'
            Body        = $body
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [SSH-Signing-Keys] - [Add-GitHubUserSigningKey] - Done"
#endregion [functions] - [public] - [Users] - [SSH-Signing-Keys] - [Add-GitHubUserSigningKey]
#region    [functions] - [public] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserSigningKey]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserSigningKey] - Importing"
filter Get-GitHubUserSigningKey {
    <#
        .SYNOPSIS
        List SSH signing keys for a given user or the authenticated user.

        .DESCRIPTION
        Lists a given user's or the current user's SSH signing keys.

        .EXAMPLE
        Get-GitHubUserSigningKey

        Gets all SSH signing keys for the authenticated user.

        .EXAMPLE
        Get-GitHubUserSigningKey -ID '1234567'

        Gets the SSH signing key with the ID '1234567' for the authenticated user.

        .EXAMPLE
        Get-GitHubUserSigningKey -Username 'octocat'

        Gets all SSH signing keys for the 'octocat' user.

        .NOTES
        [List SSH signing keys for the authenticated user](https://docs.github.com/rest/users/ssh-signing-keys#list-ssh-signing-keys-for-the-authenticated-user)
        [Get an SSH signing key for the authenticated user](https://docs.github.com/rest/users/ssh-signing-keys#get-an-ssh-signing-key-for-the-authenticated-user)
        [List SSH signing keys for a user](https://docs.github.com/rest/users/ssh-signing-keys#list-ssh-signing-keys-for-a-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/SSH-Signing-Keys/Get-GitHubUserSigningKey
    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]
    param(
        # The handle for the GitHub user account.
        [Parameter(
            Mandatory,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName,
            ParameterSetName = 'Username'
        )]
        [string] $Username,

        # The unique identifier of the SSH signing key.
        [Parameter(
            ParameterSetName = 'Me'
        )]
        [Alias('gpg_key_id')]
        [string] $ID,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'Username' {
                Get-GitHubUserSigningKeyForUser -Username $Username -PerPage $PerPage -Context $Context
            }
            'Me' {
                Get-GitHubUserMySigningKeyById -ID $ID -Context $Context
            }
            default {
                Get-GitHubUserMySigningKey -PerPage $PerPage -Context $Context
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserSigningKey] - Done"
#endregion [functions] - [public] - [Users] - [SSH-Signing-Keys] - [Get-GitHubUserSigningKey]
#region    [functions] - [public] - [Users] - [SSH-Signing-Keys] - [Remove-GitHubUserSigningKey]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [SSH-Signing-Keys] - [Remove-GitHubUserSigningKey] - Importing"
filter Remove-GitHubUserSigningKey {
    <#
        .SYNOPSIS
        Delete an SSH signing key for the authenticated user

        .DESCRIPTION
        Deletes an SSH signing key from the authenticated user's GitHub account.
        You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least
        `admin:ssh_signing_key` scope. For more information, see
        "[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/)."

        .EXAMPLE
        Remove-GitHubUserSigningKey -ID '1234567'

        Removes the SSH signing key with the ID of `1234567` from the authenticated user's GitHub account.

        .NOTES
        [Delete an SSH signing key for the authenticated user](https://docs.github.com/rest/users/ssh-signing-keys#delete-an-ssh-signing-key-for-the-authenticated-user)

        .LINK
        https://psmodule.io/GitHub/Functions/Users/SSH-Signing-Keys/Remove-GitHubUserSigningKey
    #>
    [OutputType([pscustomobject])]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        # The unique identifier of the SSH signing key.
        [Parameter(
            Mandatory
        )]
        [Alias('ssh_signing_key_id')]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/user/ssh_signing_keys/$ID"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("SSH signing key with ID [$ID]", 'DELETE')) {
            Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [SSH-Signing-Keys] - [Remove-GitHubUserSigningKey] - Done"
#endregion [functions] - [public] - [Users] - [SSH-Signing-Keys] - [Remove-GitHubUserSigningKey]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - [SSH-Signing-Keys] - Done"
#endregion [functions] - [public] - [Users] - [SSH-Signing-Keys]
Write-Debug "[$scriptName] - [functions] - [public] - [Users] - Done"
#endregion [functions] - [public] - [Users]
#region    [functions] - [public] - [Variables]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - Processing folder"
#region    [functions] - [public] - [Variables] - [completers]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [completers] - Importing"
Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport |
        Where-Object { $_ -like '*GitHubVariable' }) -ParameterName Name -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter

    $params = @{
        Owner       = $fakeBoundParameter.Owner
        Repository  = $fakeBoundParameter.Repository
        Environment = $fakeBoundParameter.Environment
    }
    $params | Remove-HashtableEntry -NullOrEmptyValues
    Get-GitHubVariable @params | Where-Object { $_.Name -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Name)
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [completers] - Done"
#endregion [functions] - [public] - [Variables] - [completers]
#region    [functions] - [public] - [Variables] - [Export-GitHubVariable]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [Export-GitHubVariable] - Importing"
function Export-GitHubVariable {
    <#
        .SYNOPSIS
        Exports a GitHub variable to the local environment.

        .DESCRIPTION
        This function takes a GitHub variable and sets it as an environment variable.
        The variable can be exported to the Process, User, or Machine environment scope.

        By default, the variable is exported to the Process scope, meaning it will persist only for the current session.

        The function accepts pipeline input, allowing GitHub variables retrieved using `Get-GitHubVariable` to be exported seamlessly.

        .EXAMPLE
        Get-GitHubVariable -Owner 'octocat' -Repository 'Hello-World' -Environment 'staging' | Export-GitHubVariable

        Exports the variables retrieved from the GitHub API to the local environment.

        .INPUTS
        GitHubVariable

        .OUTPUTS
        void

        .LINK
        https://psmodule.io/GitHub/Functions/Variables/Export-GitHubVariable
    #>
    [OutputType([void])]
    [CmdletBinding()]
    param(
        # The name of the variable.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Name,

        # The value of the variable.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Value,

        # The target scope for the environment variable.
        [Parameter()]
        [System.EnvironmentVariableTarget] $Target = [System.EnvironmentVariableTarget]::Process
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
    }

    process {
        Write-Debug "$($_.Name) = $($_.Value)"
        [System.Environment]::SetEnvironmentVariable($Name, $Value, $Target)
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [Export-GitHubVariable] - Done"
#endregion [functions] - [public] - [Variables] - [Export-GitHubVariable]
#region    [functions] - [public] - [Variables] - [Get-GitHubVariable]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [Get-GitHubVariable] - Importing"
function Get-GitHubVariable {
    <#
        .SYNOPSIS
        Retrieves a variable from GitHub based on the specified scope.

        .DESCRIPTION
        Gets a variable from GitHub, which can be at the organization, repository, or environment level.
        This function determines the appropriate API call based on the provided parameters.
        Authenticated users must have the required access rights to read variables.
        OAuth tokens and personal access tokens (classic) need the `repo` scope for repositories,
        `admin:org` for organizations, and collaborator access for environments.

        .EXAMPLE
        Get-GitHubVariable -Owner 'octocat' -Name 'HOST_NAME'

        Output:
        ```powershell
        Name        : HOST_NAME
        Value       : github.com
        Owner       : octocat
        Repository  :
        Environment :
        ```

        Retrieves the specified variable from the organization level.

        .EXAMPLE
        Get-GitHubVariable -Owner 'octocat' -Repository 'Hello-World' -Name 'GUID'

        Output:
        ```powershell
        Name        : GUID
        Value       : 354aa0b0-65b1-46c8-9c3e-1576f4167a41
        Owner       : octocat
        Repository  : Hello-World
        Environment :
        ```

        Retrieves the specified variable from the repository level.

        .EXAMPLE
        Get-GitHubVariable -Owner 'octocat' -Repository 'Hello-World' -Environment 'dev' -Name 'DB_SERVER'

        Output:
        ```powershell
        Name        : DB_SERVER
        Value       : db.example.com
        Owner       : octocat
        Repository  : Hello-World
        Environment : dev
        ```

        Retrieves the specified variable from the environment level within a repository.

        .EXAMPLE
        Get-GitHubVariable -Owner 'octocat'

        Output:
        ```powershell
        Name        : MAX_THREADS
        Value       : 10
        Owner       : octocat
        Repository  :
        Environment :

        Name        : API_TIMEOUT
        Value       : 30
        Owner       : octocat
        Repository  :
        Environment :
        ```

        Retrieves all variables available at the organization level.

        .EXAMPLE
        Get-GitHubVariable -Owner 'octocat' -Repository 'Hello-World'

        Output:
        ```powershell
        Name        : LOG_LEVEL
        Value       : INFO
        Owner       : octocat
        Repository  : Hello-World
        Environment :

        Name        : FEATURE_FLAG
        Value       : Enabled
        Owner       : octocat
        Repository  : Hello-World
        Environment :
        ```

        Retrieves all variables available at the repository level.

        .EXAMPLE
        Get-GitHubVariable -Owner 'octocat' -Repository 'Hello-World' -Environment 'staging'

        Output:
        ```powershell
        Name        : CACHE_DURATION
        Value       : 3600
        Owner       : octocat
        Repository  : Hello-World
        Environment : staging

        Name        : CONNECTION_RETRIES
        Value       : 5
        Owner       : octocat
        Repository  : Hello-World
        Environment : staging
        ```

        Retrieves all variables available in the 'staging' environment within the repository.

        .OUTPUTS
        GitHubVariable[]

        .NOTES
        An object or array of objects representing the GitHub variable, containing Name, Value, Owner,
        Repository, and Environment details.

        .LINK
        https://psmodule.io/GitHub/Functions/Variables/Get-GitHubVariable
    #>
    [OutputType([GitHubVariable[]])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Organization', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the environment.
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Environment,

        # The name of the variable.
        [Parameter()]
        [SupportsWildcards()]
        [string] $Name = '*',

        # List all variables that are inherited.
        [Parameter()]
        [switch] $IncludeInherited,

        # List all variables, including those that are overwritten by inheritance.
        [Parameter()]
        [switch] $All,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $variables = @()
        $params = @{
            Context = $Context
            Owner   = $Owner
        }
        switch ($PSCmdlet.ParameterSetName) {
            'Organization' {
                if ($Name.Contains('*')) {
                    $variables += Get-GitHubVariableOwnerList @params |
                        Where-Object { $_.Name -like $Name }
                } else {
                    try {
                        $variables += Get-GitHubVariableOwnerByName @params -Name $Name
                    } catch { $null }
                }
                break
            }
            'Repository' {
                $params['Repository'] = $Repository
                if ($IncludeInherited) {
                    $variables += Get-GitHubVariableFromOrganization @params |
                        Where-Object { $_.Name -like $Name }
                }
                if ($Name.Contains('*')) {
                    $variables += Get-GitHubVariableRepositoryList @params |
                        Where-Object { $_.Name -like $Name }
                } else {
                    try {
                        $variables += Get-GitHubVariableRepositoryByName @params -Name $Name
                    } catch { $null }
                }
                break
            }
            'Environment' {
                $params['Repository'] = $Repository
                if ($IncludeInherited) {
                    $variables += Get-GitHubVariableFromOrganization @params |
                        Where-Object { $_.Name -like $Name }
                    if ($Name.Contains('*')) {
                        $variables += Get-GitHubVariableRepositoryList @params |
                            Where-Object { $_.Name -like $Name }
                    } else {
                        try {
                            $variables += Get-GitHubVariableRepositoryByName @params -Name $Name
                        } catch { $null }
                    }
                }
                $params['Environment'] = $Environment
                if ($Name.Contains('*')) {
                    $variables += Get-GitHubVariableEnvironmentList @params |
                        Where-Object { $_.Name -like $Name }
                } else {
                    try {
                        $variables += Get-GitHubVariableEnvironmentByName @params -Name $Name
                    } catch { $null }
                }
                break
            }
        }

        if ($IncludeInherited -and -not $All) {
            $variables = $variables | Group-Object -Property Name | ForEach-Object {
                $group = $_.Group
                $envVar = $group | Where-Object { $_.Environment }
                if ($envVar) {
                    $envVar
                } else {
                    $repoVar = $group | Where-Object { $_.Repository -and (-not $_.Environment) }
                    if ($repoVar) {
                        $repoVar
                    } else {
                        $group | Where-Object { (-not $_.Repository) -and (-not $_.Environment) }
                    }
                }
            }
        }

        $variables
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [Get-GitHubVariable] - Done"
#endregion [functions] - [public] - [Variables] - [Get-GitHubVariable]
#region    [functions] - [public] - [Variables] - [New-GitHubVariable]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [New-GitHubVariable] - Importing"
function New-GitHubVariable {
    <#
        .SYNOPSIS
        Creates a GitHub Actions variable at the organization, repository, or environment level.

        .DESCRIPTION
        This function creates a GitHub Actions variable that can be referenced in a workflow. The variable can be scoped to an organization,
        repository, or environment.

        - Organization-level variables require the `admin:org` scope for OAuth tokens and personal access tokens (classic). If the repository is
          private, the `repo` scope is also required.
        - Repository-level variables require the `repo` scope.
        - Environment-level variables require collaborator access to the repository.

        .EXAMPLE
        New-GitHubVariable -Owner 'octocat' -Repository 'Hello-World' -Name 'HOST_NAME' -Value 'github.com' -Context $GitHubContext

        Creates a new repository variable named `HOST_NAME` with the value `github.com` in the specified repository.

        .EXAMPLE
        New-GitHubVariable -Owner 'octocat' -Name 'HOST_NAME' -Value 'github.com' -Visibility 'all' -Context $GitHubContext

        Creates a new organization variable named `HOST_NAME` with the value `github.com` and
        makes it available to all repositories in the organization.

        .EXAMPLE
        New-GitHubVariable -Owner 'octocat' -Repository 'Hello-World' -Environment 'dev' -Name 'HOST_NAME' -Value 'github.com' -Context $GitHubContext

        Creates a new environment variable named `HOST_NAME` with the value `github.com` in the specified environment.

        .OUTPUTS
        GitHubVariable

        .NOTES
        Returns an GitHubVariable object containing details about the environment variable,
        including its name, value, associated repository, and environment details.


        .LINK
        https://psmodule.io/GitHub/Functions/Variables/New-GitHubVariable/
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSShouldProcess', '', Scope = 'Function',
        Justification = 'This check is performed in the private functions.'
    )]
    [OutputType([GitHubVariable])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Organization')]
        [Parameter(Mandatory, ParameterSetName = 'Repository')]
        [Parameter(Mandatory, ParameterSetName = 'Environment')]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Repository')]
        [Parameter(Mandatory, ParameterSetName = 'Environment')]
        [string] $Repository,

        # The name of the repository environment.
        [Parameter(Mandatory, ParameterSetName = 'Environment')]
        [string] $Environment,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The value of the variable.
        [Parameter(Mandatory)]
        [string] $Value,

        # The visibility of the variable. Can be `private`, `selected`, or `all`.
        # `private` - The variable is only available to the organization.
        # `selected` - The variable is available to selected repositories.
        # `all` - The variable is available to all repositories in the organization.
        [Parameter(ParameterSetName = 'Organization')]
        [ValidateSet('Private', 'Selected', 'All')]
        [string] $Visibility = 'Private',

        # The IDs of the repositories to which the variable is available.
        # This parameter is only used when the `-Visibility` parameter is set to `selected`.
        [Parameter(ParameterSetName = 'Organization')]
        [UInt64[]] $SelectedRepositories,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $params = @{
            Owner                = $Owner
            Repository           = $Repository
            Environment          = $Environment
            Name                 = $Name
            Value                = $Value
            SelectedRepositories = $SelectedRepositories
            Context              = $Context
            ErrorAction          = 'Stop'
        }
        $params | Remove-HashtableEntry -NullOrEmptyValues
        $null = switch ($PSCmdlet.ParameterSetName) {
            'Organization' {
                $params.Visibility = $Visibility.ToLower()
                New-GitHubVariableOnOwner @params
                break
            }
            'Repository' {
                New-GitHubVariableOnRepository @params
                break
            }
            'Environment' {
                New-GitHubVariableOnEnvironment @params
                break
            }
        }
        $params = @{
            Owner       = $Owner
            Repository  = $Repository
            Environment = $Environment
            Name        = $Name
            Context     = $Context
        }
        $params | Remove-HashtableEntry -NullOrEmptyValues

        for ($i = 0; $i -le 5; $i++) {
            Start-Sleep -Seconds 1
            $result = Get-GitHubVariable @params
            if ($result) { break }
        }
        $result
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [New-GitHubVariable] - Done"
#endregion [functions] - [public] - [Variables] - [New-GitHubVariable]
#region    [functions] - [public] - [Variables] - [Remove-GitHubVariable]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [Remove-GitHubVariable] - Importing"
function Remove-GitHubVariable {
    <#
        .SYNOPSIS
        Deletes a GitHub variable from an organization, repository, or environment.

        .DESCRIPTION
        Deletes a GitHub variable based on the provided scope (organization, repository, or environment).

        Supports pipeline input from Get-GitHubVariable or direct array input.

        Authenticated users must have collaborator access to a repository to manage variables.
        OAuth tokens and personal access tokens (classic) require specific scopes:
        - `admin:org` for organization-level variables.
        - `repo` for repository and environment-level variables.

        .EXAMPLE
        Get-GitHubVariable -Owner 'octocat' -Repository 'Hello-World' | Remove-GitHubVariable

        Removes all variables retrieved from the specified repository.

        .EXAMPLE
        Remove-GitHubVariable -Owner 'octocat' -Name 'HOST_NAME' -Context $GitHubContext

        Deletes the specified variable from the specified organization.

        .EXAMPLE
        Remove-GitHubVariable -Variable $variablesArray

        Removes all variables provided in the array.

        .INPUTS
        GitHubVariable

        .OUTPUTS
        void

        .LINK
        https://psmodule.io/GitHub/Functions/Variables/Remove-GitHubVariable/
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSShouldProcess', '', Scope = 'Function',
        Justification = 'This check is performed in the private functions.'
    )]
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Organization', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the environment.
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Environment,

        # The name of the variable.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context,

        [Parameter(Mandatory, ParameterSetName = 'ArrayInput', ValueFromPipeline)]
        [GitHubVariable[]] $InputObject
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {
            'ArrayInput' {
                foreach ($item in $InputObject) {
                    $params = @{
                        Owner       = $item.Owner
                        Repository  = $item.Repository
                        Environment = $item.Environment
                        Name        = $item.Name
                        Context     = $item.Context
                    }
                    $params | Remove-HashtableEntry -NullOrEmptyValues
                    Remove-GitHubVariable @params
                }
                break
            }
            'Organization' {
                $params = @{
                    Owner   = $Owner
                    Name    = $Name
                    Context = $Context
                }
                Remove-GitHubVariableFromOwner @params
                break
            }
            'Repository' {
                $params = @{
                    Owner      = $Owner
                    Repository = $Repository
                    Name       = $Name
                    Context    = $Context
                }
                Remove-GitHubVariableFromRepository @params
                break
            }
            'Environment' {
                $params = @{
                    Owner       = $Owner
                    Repository  = $Repository
                    Environment = $Environment
                    Name        = $Name
                    Context     = $Context
                }
                Remove-GitHubVariableFromEnvironment @params
                break
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [Remove-GitHubVariable] - Done"
#endregion [functions] - [public] - [Variables] - [Remove-GitHubVariable]
#region    [functions] - [public] - [Variables] - [Set-GitHubVariable]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [Set-GitHubVariable] - Importing"
function Set-GitHubVariable {
    <#
        .SYNOPSIS
        Creates or updates a GitHub Actions variable at the organization, repository, or environment level.

        .DESCRIPTION
        This function checks if a GitHub Actions variable exists at the specified level (organization, repository, or environment).
        If the variable exists, it updates it with the new value. If it does not exist, it creates a new variable.

        - Organization-level variables require the `admin:org` scope for OAuth tokens and personal access tokens (classic). If the repository is
          private, the `repo` scope is also required.
        - Repository-level variables require the `repo` scope.
        - Environment-level variables require collaborator access to the repository.

        .EXAMPLE
        Set-GitHubVariable -Owner 'octocat' -Repository 'Hello-World' -Name 'HOST_NAME' -Value 'github.com' -Context $GitHubContext

        Creates or updates a repository variable named `HOST_NAME` with the value `github.com` in the specified repository.

        .EXAMPLE
        Set-GitHubVariable -Owner 'octocat' -Name 'HOST_NAME' -Value 'github.com' -Visibility 'all' -Context $GitHubContext

        Creates or updates an organization variable named `HOST_NAME` with the value `github.com` and
        makes it available to all repositories in the organization.

        .EXAMPLE
        Set-GitHubVariable -Owner 'octocat' -Repository 'Hello-World' -Environment 'dev' -Name 'HOST_NAME' -Value 'github.com' -Context $GitHubContext

        Creates or updates an environment variable named `HOST_NAME` with the value `github.com` in the specified environment.

        .OUTPUTS
        GitHubVariable

        .NOTES
        Returns an GitHubVariable object containing details about the environment variable,
        including its name, value, associated repository, and environment details.

        .LINK
        https://psmodule.io/GitHub/Functions/Variables/Set-GitHubVariable/
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSShouldProcess', '', Scope = 'Function',
        Justification = 'This check is performed in the private functions.'
    )]
    [OutputType([GitHubVariable])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Organization', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the repository environment.
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Environment,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The value of the variable.
        [Parameter()]
        [string] $Value,

        # The visibility of the variable when updating an organization variable.
        # Can be `private`, `selected`, or `all`.
        [Parameter(ParameterSetName = 'Organization')]
        [ValidateSet('Private', 'Selected', 'All')]
        [string] $Visibility = 'Private',

        # The IDs of the repositories to which the variable is available.
        # Used only when the `-Visibility` parameter is set to `selected`.
        [Parameter(ParameterSetName = 'Organization')]
        [UInt64[]] $SelectedRepositories,

        # The context to run the command in. Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $getParams = @{
            Owner       = $Owner
            Repository  = $Repository
            Environment = $Environment
            Context     = $Context
        }
        $getParams | Remove-HashtableEntry -NullOrEmptyValues
        $variable = Get-GitHubVariable @getParams | Where-Object { $_.Name -eq $Name }

        $params = @{
            Owner                = $Owner
            Repository           = $Repository
            Environment          = $Environment
            Name                 = $Name
            Value                = $Value
            SelectedRepositories = $SelectedRepositories
            Context              = $Context
            ErrorAction          = 'Stop'
        }
        if ($PSCmdlet.ParameterSetName -eq 'Organization') {
            $params['Visibility'] = $Visibility.ToLower()
        }
        $params | Remove-HashtableEntry -NullOrEmptyValues

        if ($variable) {
            $null = Update-GitHubVariable @params -PassThru
            Get-GitHubVariable @getParams -Name $Name
        } else {
            New-GitHubVariable @params
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [Set-GitHubVariable] - Done"
#endregion [functions] - [public] - [Variables] - [Set-GitHubVariable]
#region    [functions] - [public] - [Variables] - [Update-GitHubVariable]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [Update-GitHubVariable] - Importing"
function Update-GitHubVariable {
    <#
        .SYNOPSIS
        Update a GitHub variable at the organization, repository, or environment level.

        .DESCRIPTION
        Updates a GitHub Actions variable that can be referenced in workflows. This function supports updating variables
        at different levels: organization, repository, or environment. It delegates the update process to the appropriate
        private function based on the specified parameters.

        To modify an organization variable, users must have `admin:org` scope. Repository variables require `repo` scope,
        and environment variables require collaborator access.

        .EXAMPLE
        Update-GitHubVariable -Owner 'octocat' -Repository 'Hello-World' -Name 'HOST_NAME' -Value 'github.com'

        Updates the repository variable named `HOST_NAME` with the value `github.com` in the specified repository.

        .EXAMPLE
        Update-GitHubVariable -Owner 'octocat' -Name 'HOST_NAME' -Value 'github.com' -Visibility 'private'

        Updates the organization variable named `HOST_NAME` with the value `github.com`, making it private.

        .EXAMPLE
        Update-GitHubVariable -Owner 'octocat' -Repository 'Hello-World' -Environment 'dev' -Name 'HOST_NAME' -Value 'github.com'

        Updates the environment variable named `HOST_NAME` with the value `github.com` in the specified environment.

        .OUTPUTS
        GitHubVariable

        .NOTES
        Returns an GitHubVariable object containing details about the environment variable,
        including its name, value, associated repository, and environment details.

        .LINK
        https://psmodule.io/GitHub/Functions/Variables/Update-GitHubVariable/
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSShouldProcess', '', Scope = 'Function',
        Justification = 'This check is performed in the private functions.'
    )]
    [OutputType([GitHubVariable])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Organization', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [Alias('Organization', 'User')]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ParameterSetName = 'Repository', ValueFromPipelineByPropertyName)]
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the repository environment.
        [Parameter(Mandatory, ParameterSetName = 'Environment', ValueFromPipelineByPropertyName)]
        [string] $Environment,

        # The name of the variable.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Name,

        # The new name of the variable.
        [Parameter()]
        [string] $NewName,

        # The value of the variable.
        [Parameter()]
        [string] $Value,

        # The visibility of the variable when updating an organization variable.
        # Can be `private`, `selected`, or `all`.
        [Parameter(ParameterSetName = 'Organization')]
        [ValidateSet('private', 'selected', 'all')]
        [string] $Visibility,

        # The IDs of the repositories to which the variable is available.
        # Used only when the `-Visibility` parameter is set to `selected`.
        [Parameter(ParameterSetName = 'Organization')]
        [UInt64[]] $SelectedRepositories,

        # If specified, the function will return the updated variable object.
        [Parameter()]
        [switch] $PassThru,

        # The context to run the command in. Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $params = @{
            Owner                = $Owner
            Repository           = $Repository
            Environment          = $Environment
            Name                 = $Name
            Context              = $Context
            NewName              = $NewName
            Value                = $Value
            SelectedRepositories = $SelectedRepositories
            ErrorAction          = 'Stop'
        }
        $params | Remove-HashtableEntry -NullOrEmptyValues
        switch ($PSCmdlet.ParameterSetName) {
            'Organization' {
                if ($PSBoundParameters.ContainsKey('Visibility') -and -not [string]::IsNullOrEmpty($Visibility)) {
                    $params.Visibility = $Visibility
                }
                Update-GitHubVariableOnOwner @params
                break
            }
            'Repository' {
                Update-GitHubVariableOnRepository @params
                break
            }
            'Environment' {
                Update-GitHubVariableOnEnvironment @params
                break
            }
        }
        if ($PassThru) {
            $params = @{
                Owner       = $Owner
                Repository  = $Repository
                Environment = $Environment
                Name        = $PSBoundParameters.ContainsKey('NewName') ? $NewName : $Name
                Context     = $Context
            }
            $params | Remove-HashtableEntry -NullOrEmptyValues
            for ($i = 0; $i -le 5; $i++) {
                Start-Sleep -Seconds 1
                $result = Get-GitHubVariable @params
                if ($result) { break }
            }
            $result
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [Update-GitHubVariable] - Done"
#endregion [functions] - [public] - [Variables] - [Update-GitHubVariable]
#region    [functions] - [public] - [Variables] - [SelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [SelectedRepository] - Processing folder"
#region    [functions] - [public] - [Variables] - [SelectedRepository] - [Add-GitHubVariableSelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [SelectedRepository] - [Add-GitHubVariableSelectedRepository] - Importing"
function Add-GitHubVariableSelectedRepository {
    <#
        .SYNOPSIS
        Add selected repository to an organization variable.

        .DESCRIPTION
        Adds a repository to an organization variable that is available to selected repositories.
        Organization variables that are available to selected repositories have their visibility field set to 'selected'.
        Authenticated users must have collaborator access to the repository to create, update, or read secrets.
        OAuth and classic personal access tokens require the 'admin:org' scope. For private repositories, the 'repo' scope is also required.
        Fine-grained tokens must have 'Variables' organization permission (write) and 'Metadata' repository permission (read).

        .EXAMPLE
        Add-GitHubVariableSelectedRepository -Owner 'my-org' -Name 'API_KEY' -RepositoryID '654321'

        Adds the repository 'test-repo' to the 'API_KEY' variable in the organization 'my-org'.

        .LINK
        https://psmodule.io/GitHub/Functions/Variables/SelectedRepository/Add-GitHubVariableSelectedRepository

        .NOTES
        [Add selected repository to an organization variable](https://docs.github.com/rest/actions/variables#add-selected-repository-to-an-organization-variable)

        .LINK
        https://psmodule.io/GitHub/Functions/Variables/SelectedRepository/Add-GitHubVariableSelectedRepository
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '',
        Justification = 'Long links'
    )]
    [OutputType([void])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The ID of the repository to add to the variable.
        [Parameter(,
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('DatabaseID', 'ID')]
        [UInt64] $RepositoryID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $existingSelectedRepositories = Get-GitHubVariableSelectedRepository -Owner $Owner -Name $Name -Context $Context
        $repoIsSelected = $existingSelectedRepositories.ID -contains $RepositoryID
        if ($repoIsSelected) {
            Write-Debug 'Repo is already selected, returning'
            return
        }
        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/orgs/$Owner/actions/variables/$Name/repositories/$RepositoryID"
            Context     = $Context
        }

        $null = Invoke-GitHubAPI @apiParams
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [SelectedRepository] - [Add-GitHubVariableSelectedRepository] - Done"
#endregion [functions] - [public] - [Variables] - [SelectedRepository] - [Add-GitHubVariableSelectedRepository]
#region    [functions] - [public] - [Variables] - [SelectedRepository] - [Get-GitHubVariableSelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [SelectedRepository] - [Get-GitHubVariableSelectedRepository] - Importing"
function Get-GitHubVariableSelectedRepository {
    <#
        .SYNOPSIS
        List selected repositories for an organization variable.

        .DESCRIPTION
        Lists all repositories that can access an organization variable that is available to selected repositories.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private,
        the `repo` scope is also required.

        .EXAMPLE
        Get-GitHubVariableSelectedRepository -Owner 'PSModule' -Name 'SELECTEDVAR'

        .OUTPUTS
        GitHubRepository

        .NOTES
        Returns a list of GitHubRepository objects that represent the repositories that can access the variable.

        .LINK
        https://psmodule.io/GitHub/Functions/Variables/SelectedRepository/Get-GitHubVariableSelectedRepository

        .NOTES
        [List selected repositories for an organization variable](https://docs.github.com/rest/actions/variables#list-selected-repositories-for-an-organization-variable)

        .LINK
        https://psmodule.io/GitHub/Functions/Variables/SelectedRepository/Get-GitHubVariableSelectedRepository
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '',
        Justification = 'Long links'
    )]
    [OutputType([GitHubRepository])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/orgs/$Owner/actions/variables/$Name/repositories"
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            $_.Response.repositories | ForEach-Object {
                [GitHubRepository]::New($_)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [SelectedRepository] - [Get-GitHubVariableSelectedRepository] - Done"
#endregion [functions] - [public] - [Variables] - [SelectedRepository] - [Get-GitHubVariableSelectedRepository]
#region    [functions] - [public] - [Variables] - [SelectedRepository] - [Remove-GitHubVariableSelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [SelectedRepository] - [Remove-GitHubVariableSelectedRepository] - Importing"
function Remove-GitHubVariableSelectedRepository {
    <#
        .SYNOPSIS
        Remove selected repository from an organization variable.

        .DESCRIPTION
        Removes a repository from an organization variable that is
        available to selected repositories. Organization variables that are available to
        selected repositories have their visibility field set to 'selected'.

        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth app tokens and personal access tokens (classic) need the 'admin:org' scope to use this endpoint.
        If the repository is private, the 'repo' scope is also required.

        Fine-grained personal access tokens must have 'Variables' organization permissions (write) and
        'Metadata' repository permissions (read).

        .EXAMPLE
        Remove-GitHubVariableSelectedRepository -Owner 'my-org' -Name 'ENV_SECRET' -RepositoryID 123456

        Removes repository with ID 123456 from the organization variable 'ENV_SECRET' in 'my-org'.

        .OUTPUTS
        void

        .LINK
        https://psmodule.io/GitHub/Functions/Variables/SelectedRepository/Remove-GitHubVariableSelectedRepository

        .NOTES
        [Remove selected repository from an organization variable](https://docs.github.com/rest/actions/variables#remove-selected-repository-from-an-organization-variable)

        .LINK
        https://psmodule.io/GitHub/Functions/Variables/SelectedRepository/Remove-GitHubVariableSelectedRepository
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '',
        Justification = 'Long links'
    )]
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The ID of the repository to remove to the variable.
        [Parameter(,
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [Alias('DatabaseID', 'ID')]
        [UInt64] $RepositoryID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $existingSelectedRepositories = Get-GitHubVariableSelectedRepository -Owner $Owner -Name $Name -Context $Context
        $repoIsNotSelected = $existingSelectedRepositories.ID -notcontains $RepositoryID
        if ($repoIsNotSelected) {
            Write-Debug 'Repo is not selected, returning'
            return
        }
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "/orgs/$Owner/actions/variables/$Name/repositories/$RepositoryID"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("access to variable [$Owner/$Name] for repository [$RepositoryID]", 'Remove')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [SelectedRepository] - [Remove-GitHubVariableSelectedRepository] - Done"
#endregion [functions] - [public] - [Variables] - [SelectedRepository] - [Remove-GitHubVariableSelectedRepository]
#region    [functions] - [public] - [Variables] - [SelectedRepository] - [Set-GitHubVariableSelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [SelectedRepository] - [Set-GitHubVariableSelectedRepository] - Importing"
function Set-GitHubVariableSelectedRepository {
    <#
        .SYNOPSIS
        Set selected repositories for an organization variable.

        .DESCRIPTION
        Sets which repositories has access to an organization variable.
        Organization variables that are available to selected repositories have their `visibility` field set to `selected`.
        Authenticated users must have collaborator access to a repository to create, update, or read variables.
        OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint. If the repository is private, the `repo` scope is also required.

        .EXAMPLE

        .LINK
        https://psmodule.io/GitHub/Functions/Variables/SelectedRepository/Set-GitHubVariableSelectedRepository

        .NOTES
        [Set selected repositories for an organization variable](https://docs.github.com/rest/actions/variables#set-selected-repositories-for-an-organization-variable)

        .LINK
        https://psmodule.io/GitHub/Functions/Variables/SelectedRepository/Set-GitHubVariableSelectedRepository
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSAvoidLongLines', '',
        Justification = 'Long links'
    )]
    [OutputType([void])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory)]
        [string] $Owner,

        # The name of the variable.
        [Parameter(Mandatory)]
        [string] $Name,

        # The ID of the repository to set to the variable.
        [Parameter(Mandatory)]
        [UInt64[]] $RepositoryID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            selected_repository_ids = @($RepositoryID)
        }
        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/orgs/$Owner/actions/variables/$Name/repositories"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("access to variable [$Owner/$Name] for repository [$RepositoryID]", 'Set')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [SelectedRepository] - [Set-GitHubVariableSelectedRepository] - Done"
#endregion [functions] - [public] - [Variables] - [SelectedRepository] - [Set-GitHubVariableSelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - [SelectedRepository] - Done"
#endregion [functions] - [public] - [Variables] - [SelectedRepository]
Write-Debug "[$scriptName] - [functions] - [public] - [Variables] - Done"
#endregion [functions] - [public] - [Variables]
#region    [functions] - [public] - [Webhooks]
Write-Debug "[$scriptName] - [functions] - [public] - [Webhooks] - Processing folder"
#region    [functions] - [public] - [Webhooks] - [Get-GitHubAppWebhookConfiguration]
Write-Debug "[$scriptName] - [functions] - [public] - [Webhooks] - [Get-GitHubAppWebhookConfiguration] - Importing"
function Get-GitHubAppWebhookConfiguration {
    <#
        .SYNOPSIS
        Get a webhook configuration for an app

        .DESCRIPTION
        Returns the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see
        "[Creating a GitHubApp](/developers/apps/creating-a-github-app)."

        You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
        to access this endpoint.

        .EXAMPLE
        Get-GitHubAppWebhookConfiguration

        Returns the webhook configuration for the authenticated app.

        .LINK
        https://psmodule.io/GitHub/Functions/Webhooks/Get-GitHubAppWebhookConfiguration/

        .NOTES
        [Get a webhook configuration for an app](https://docs.github.com/rest/apps/webhooks#get-a-webhook-configuration-for-an-app)
    #>
    [CmdletBinding()]
    param(
        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType APP
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = '/app/hook/config'
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            [GitHubWebhookConfiguration]::new($_.Response)
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Webhooks] - [Get-GitHubAppWebhookConfiguration] - Done"
#endregion [functions] - [public] - [Webhooks] - [Get-GitHubAppWebhookConfiguration]
#region    [functions] - [public] - [Webhooks] - [Get-GitHubAppWebhookDelivery]
Write-Debug "[$scriptName] - [functions] - [public] - [Webhooks] - [Get-GitHubAppWebhookDelivery] - Importing"
function Get-GitHubAppWebhookDelivery {
    <#
        .SYNOPSIS
        List deliveries for an app webhook or get a delivery for an app webhook by ID.

        .DESCRIPTION
        Returns a list of webhook deliveries or a specific delivery for the webhook configured for a GitHub App.

        You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
        to access this endpoint.

        .EXAMPLE
        Get-GitHubAppWebhookDelivery

        Returns a list of webhook deliveries for the webhook for the authenticated app.

        .EXAMPLE
        Get-GitHubAppWebhookDelivery -ID 123456

        Returns the webhook delivery with the ID `123456` for the authenticated app.

        .OUTPUTS
        GitHubWebhookDelivery

        .LINK
        https://psmodule.io/GitHub/Functions/Webhooks/Get-GitHubAppWebhookDelivery/

        .NOTES
        [Get a delivery for an app webhook](https://docs.github.com/rest/apps/webhooks#get-a-delivery-for-an-app-webhook)

        .NOTES
        [Get a webhook configuration for an app](https://docs.github.com/rest/apps/webhooks#get-a-webhook-configuration-for-an-app)
    #>
    [OutputType([GitHubWebhookDelivery[]])]
    [CmdletBinding(DefaultParameterSetName = 'ByList')]
    param(
        # The ID of the delivery.
        [Parameter(
            Mandatory,
            ParameterSetName = 'ByID'
        )]
        [string] $ID,

        # Only the ones to redeliver.
        [Parameter(
            Mandatory,
            ParameterSetName = 'Redelivery')]
        [switch] $NeedingRedelivery,

        # The timespan to check for redeliveries in hours.
        [Parameter(ParameterSetName = 'Redelivery')]
        [int] $TimeSpan = -2,

        # The number of results per page (max 100).
        [Parameter(ParameterSetName = 'ByList')]
        [Parameter(ParameterSetName = 'Redelivery')]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType APP
    }

    process {
        Write-Debug "ParameterSetName: [$($PSCmdlet.ParameterSetName)]"
        switch ($PSCmdlet.ParameterSetName) {
            'ByID' {
                Write-Debug "ByID: [$ID]"
                Get-GitHubAppWebhookDeliveryByID -ID $ID -Context $Context
            }
            'Redelivery' {
                Write-Debug "Redelivery: [$NeedingRedelivery]"
                Get-GitHubAppWebhookDeliveryToRedeliver -Context $Context -PerPage $PerPage -TimeSpan $TimeSpan
            }
            default {
                Write-Debug 'ByList'
                Get-GitHubAppWebhookDeliveryByList -Context $Context -PerPage $PerPage
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Webhooks] - [Get-GitHubAppWebhookDelivery] - Done"
#endregion [functions] - [public] - [Webhooks] - [Get-GitHubAppWebhookDelivery]
#region    [functions] - [public] - [Webhooks] - [Invoke-GitHubAppWebhookReDelivery]
Write-Debug "[$scriptName] - [functions] - [public] - [Webhooks] - [Invoke-GitHubAppWebhookReDelivery] - Importing"
function Invoke-GitHubAppWebhookReDelivery {
    <#
        .SYNOPSIS
        Redeliver a delivery for an app webhook

        .DESCRIPTION
        Redeliver a delivery for the webhook configured for a GitHub App.

        You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
        to access this endpoint.

        .EXAMPLE
        Invoke-GitHubAppWebhookReDelivery -ID 12345

        Redelivers the delivery with the ID `12345`.

        .LINK
        https://psmodule.io/GitHub/Functions/Webhooks/Invoke-GitHubAppWebhookReDelivery

        .NOTES
        [Redeliver a delivery for an app webhook](https://docs.github.com/rest/apps/webhooks#redeliver-a-delivery-for-an-app-webhook)
    #>
    [OutputType([void])]
    [Alias('Redeliver-GitHubAppWebhookDelivery')]
    [CmdletBinding(SupportsShouldProcess)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute(
        'PSUseApprovedVerbs', '', Scope = 'Function',
        Justification = 'Redeliver is the only thing that makes sense when triggering a webhook delivery again.'
    )]
    param(
        # The ID of the delivery.
        [Parameter(
            Mandatory,
            ValueFromPipelineByPropertyName
        )]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType APP
    }

    process {
        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/app/hook/deliveries/$ID/attempts"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("[$ID]", 'Redeliver event')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Webhooks] - [Invoke-GitHubAppWebhookReDelivery] - Done"
#endregion [functions] - [public] - [Webhooks] - [Invoke-GitHubAppWebhookReDelivery]
#region    [functions] - [public] - [Webhooks] - [Test-GitHubWebhookSignature]
Write-Debug "[$scriptName] - [functions] - [public] - [Webhooks] - [Test-GitHubWebhookSignature] - Importing"
function Test-GitHubWebhookSignature {
    <#
        .SYNOPSIS
        Verifies a GitHub webhook signature using a shared secret.

        .DESCRIPTION
        This function validates the integrity and authenticity of a GitHub webhook request by comparing
        the received HMAC SHA-256 signature against a computed hash of the payload using a shared secret.
        It uses a constant-time comparison to mitigate timing attacks and returns a boolean indicating
        whether the signature is valid.

        .EXAMPLE
        Test-GitHubWebhookSignature -Secret $env:WEBHOOK_SECRET -Body $Request.RawBody -Signature $Request.Headers['X-Hub-Signature-256']

        Output:
        ```powershell
        True
        ```

        Validates the provided webhook payload against the HMAC SHA-256 signature using the given secret.

        .OUTPUTS
        bool

        .NOTES
        Returns True if the webhook signature is valid, otherwise False. Indicates whether the signature
        matches the computed value based on the payload and secret.

        .LINK
        https://psmodule.io/GitHub/Functions/Webhooks/Test-GitHubWebhookSignature

        .LINK
        https://docs.github.com/webhooks/using-webhooks/validating-webhook-deliveries
    #>
    [OutputType([bool])]
    [CmdletBinding()]
    param (
        # The secret key used to compute the HMAC hash.
        # Example: 'mysecret'
        [Parameter(Mandatory)]
        [string] $Secret,

        # The JSON body of the GitHub webhook request.
        # This must be the compressed JSON payload received from GitHub.
        # Example: '{"action":"opened"}'
        [Parameter(Mandatory)]
        [string] $Body,

        # The signature received from GitHub to compare against.
        # Example: 'sha256=abc123...'
        [Parameter(Mandatory)]
        [string] $Signature
    )

    $keyBytes = [Text.Encoding]::UTF8.GetBytes($Secret)
    $payloadBytes = [Text.Encoding]::UTF8.GetBytes($Body)

    $hmac = [System.Security.Cryptography.HMACSHA256]::new()
    $hmac.Key = $keyBytes
    $hashBytes = $hmac.ComputeHash($payloadBytes)
    $computedSignature = 'sha256=' + (($hashBytes | ForEach-Object { $_.ToString('x2') }) -join '')

    [System.Security.Cryptography.CryptographicOperations]::FixedTimeEquals(
        [Text.Encoding]::UTF8.GetBytes($computedSignature),
        [Text.Encoding]::UTF8.GetBytes($Signature)
    )
}
Write-Debug "[$scriptName] - [functions] - [public] - [Webhooks] - [Test-GitHubWebhookSignature] - Done"
#endregion [functions] - [public] - [Webhooks] - [Test-GitHubWebhookSignature]
#region    [functions] - [public] - [Webhooks] - [Update-GitHubAppWebhookConfiguration]
Write-Debug "[$scriptName] - [functions] - [public] - [Webhooks] - [Update-GitHubAppWebhookConfiguration] - Importing"
function Update-GitHubAppWebhookConfiguration {
    <#
        .SYNOPSIS
        Update a webhook configuration for an app

        .DESCRIPTION
        Updates the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see
        "[Creating a GitHub App](/developers/apps/creating-a-github-app)."

        You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
        to access this endpoint.

        .EXAMPLE
        Update-GitHubAppWebhookConfiguration -URL 'https://example.com' -ContentType 'json' -Secret 'mysecret' -EnableSsl

        Output:
        ```powershell
        ContentType: json
        UseSsl:      True
        Secret:      mysecret
        Url:         https://example.com
        ```

        Updates the webhook configuration for the authenticated app to deliver payloads to `https://example.com` with a `json` content type
        and a secret of `mysecret` enabling SSL verification when delivering payloads.

        .OUTPUTS
        GitHubWebhookConfiguration

        .LINK
        https://psmodule.io/GitHub/Functions/Webhooks/Update-GitHubAppWebhookConfiguration

        .NOTES
        [Update a webhook configuration for an app](https://docs.github.com/rest/apps/webhooks#update-a-webhook-configuration-for-an-app)
    #>
    [OutputType([GitHubWebhookConfiguration])]
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The URL to which the payloads will be delivered.
        [Parameter()]
        [string] $Url,

        # The media type used to serialize the payloads.
        [Parameter()]
        [ValidateSet('json', 'form')]
        [string] $ContentType,

        # If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for delivery signature headers.
        [Parameter()]
        [string] $Secret,

        # Disable SSL verification when delivering payloads.
        [Parameter()]
        [switch] $DisableSsl,

        # Enables SSL verification when delivering payloads.
        [Parameter()]
        [switch] $EnableSsl,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType APP
    }

    process {
        $body = @{
            url          = $Url
            content_type = $ContentType
            secret       = $Secret
            insecure_ssl = $PSBoundParameters.ContainsKey($InsecureSSL) ? ($InsecureSSL ? 1 : 0) : $null
        }
        $body | Remove-HashtableEntry -NullOrEmptyValues

        $apiParams = @{
            Method      = 'PATCH'
            APIEndpoint = '/app/hook/config'
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess('webhook configuration', 'Update')) {
            Invoke-GitHubAPI @apiParams | ForEach-Object {
                Write-Output $_.Response
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Webhooks] - [Update-GitHubAppWebhookConfiguration] - Done"
#endregion [functions] - [public] - [Webhooks] - [Update-GitHubAppWebhookConfiguration]
Write-Debug "[$scriptName] - [functions] - [public] - [Webhooks] - Done"
#endregion [functions] - [public] - [Webhooks]
#region    [functions] - [public] - [Workflows]
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - Processing folder"
#region    [functions] - [public] - [Workflows] - [completers]
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [completers] - Importing"
Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport |
        Where-Object { $_ -like '*GitHubWorkflow' }) -ParameterName Name -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter

    $params = @{
        Owner      = $fakeBoundParameter.Owner
        Repository = $fakeBoundParameter.Repository
    }
    $params | Remove-HashtableEntry -NullOrEmptyValues
    Get-GitHubWorkflow @params | Where-Object { $_.Name -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Name)
    }
}
Register-ArgumentCompleter -CommandName ($script:PSModuleInfo.FunctionsToExport |
        Where-Object { $_ -like '*GitHubWorkflow' }) -ParameterName ID -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)
    $null = $commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter

    $params = @{
        Owner      = $fakeBoundParameter.Owner
        Repository = $fakeBoundParameter.Repository
    }
    $params | Remove-HashtableEntry -NullOrEmptyValues
    Get-GitHubWorkflow @params | Where-Object { $_.ID -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_.ID, "$($_.Name) ($($_.ID))", 'ParameterValue', "$($_.Name) ($($_.ID))"  )
    }
}
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [completers] - Done"
#endregion [functions] - [public] - [Workflows] - [completers]
#region    [functions] - [public] - [Workflows] - [Disable-GitHubWorkflow]
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Disable-GitHubWorkflow] - Importing"
filter Disable-GitHubWorkflow {
    <#
        .SYNOPSIS
        Disable a workflow.

        .DESCRIPTION
        Disables a workflow and sets the `state` of the workflow to `disabled_manually`. You can replace `workflow_id` with the workflow filename.
        For example, you could use `main.yaml`. OAuth tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.

        .EXAMPLE

        .INPUTS
        GitHubWorkflow

        .LINK
        https://psmodule.io/GitHub/Functions/Workflows/Disable-GitHubWorkflow/

        .NOTES
        [Disable a workflow](https://docs.github.com/rest/actions/workflows#disable-a-workflow)
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The ID of the workflow. You can also pass the workflow filename as a string.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/repos/$Owner/$Repository/actions/workflows/$ID/disable"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("$Owner/$Repository/$ID", 'Disable workflow')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Disable-GitHubWorkflow] - Done"
#endregion [functions] - [public] - [Workflows] - [Disable-GitHubWorkflow]
#region    [functions] - [public] - [Workflows] - [Enable-GitHubWorkflow]
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Enable-GitHubWorkflow] - Importing"
filter Enable-GitHubWorkflow {
    <#
        .SYNOPSIS

        .DESCRIPTION

        .EXAMPLE

        .INPUTS
        GitHubWorkflow

        .LINK
        https://psmodule.io/GitHub/Functions/Workflows/Enable-GitHubWorkflow/

        .NOTES
        [Enable a workflow](https://docs.github.com/rest/actions/workflows#enable-a-workflow)
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The ID of the workflow. You can also pass the workflow filename as a string.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'PUT'
            APIEndpoint = "/repos/$Owner/$Repository/actions/workflows/$ID/enable"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("$Owner/$Repository/$ID", 'Enable workflow')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Enable-GitHubWorkflow] - Done"
#endregion [functions] - [public] - [Workflows] - [Enable-GitHubWorkflow]
#region    [functions] - [public] - [Workflows] - [Get-GitHubWorkflow]
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Get-GitHubWorkflow] - Importing"
filter Get-GitHubWorkflow {
    <#
        .SYNOPSIS
        Lists the workflows in a repository.

        .DESCRIPTION
        Anyone with read access to the repository can use this endpoint.
        If the repository is private you must use an access token with the repo scope.
        GitHub Apps must have the actions:read permission to use this endpoint.

        .EXAMPLE
        Get-GitHubWorkflow -Owner 'octocat' -Repository 'hello-world'

        Gets all workflows in the 'octocat/hello-world' repository.

        .EXAMPLE
        Get-GitHubWorkflow -Owner 'octocat' -Repository 'hello-world' -Name 'hello-world.yml'

        Gets the 'hello-world.yml' workflow in the 'octocat/hello-world' repository.

        .OUTPUTS
        GitHubWorkflow

        .LINK
        https://psmodule.io/GitHub/Functions/Workflows/Get-GitHubWorkflow/

        .NOTES
        [List repository workflows](https://docs.github.com/rest/actions/workflows#list-repository-workflows)
    #>
    [OutputType([GitHubWorkflow])]
    [CmdletBinding()]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The name of the workflow to get.
        [Parameter()]
        [SupportsWildcards()]
        [string] $Name = '*',

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'GET'
            APIEndpoint = "/repos/$Owner/$Repository/actions/workflows"
            Body        = $body
            PerPage     = $PerPage
            Context     = $Context
        }

        Invoke-GitHubAPI @apiParams | ForEach-Object {
            Write-Output $_.Response.workflows | Where-Object { $_.name -like $Name } | ForEach-Object {
                [GitHubWorkflow]::new($_, $Owner, $Repository)
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Get-GitHubWorkflow] - Done"
#endregion [functions] - [public] - [Workflows] - [Get-GitHubWorkflow]
#region    [functions] - [public] - [Workflows] - [Start-GitHubWorkflow]
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Start-GitHubWorkflow] - Importing"
filter Start-GitHubWorkflow {
    <#
        .SYNOPSIS
        Start a workflow run using the workflow's ID.

        .DESCRIPTION
        Start a workflow run using the workflow's ID.

        .EXAMPLE
        Get-GitHubWorkflow | Where-Object name -NotLike '.*' | Start-GitHubWorkflow -Inputs @{
            staticValidation = $true
            deploymentValidation = $false
            removeDeployment = $true
            prerelease = $false
        }

        .LINK
        https://psmodule.io/GitHub/Functions/Workflows/Start-GitHubWorkflow/

        .NOTES
        [Create a workflow dispatch event](https://docs.github.com/rest/actions/workflows#create-a-workflow-dispatch-event)
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The ID of the workflow. You can also pass the workflow filename as a string.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $ID,

        # The reference of the workflow run. The reference can be a branch, tag, or a commit SHA.
        [Parameter()]
        [Alias('Branch', 'Tag')]
        [string] $Ref = 'main',

        # Input parameters for the workflow run. You can use the inputs and payload keys to pass custom data to your workflow.
        [Parameter()]
        [hashtable] $Inputs = @{},

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $body = @{
            ref    = $Ref
            inputs = $Inputs
        }

        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/repos/$Owner/$Repository/actions/workflows/$ID/dispatches"
            Body        = $body
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("$Owner/$Repository/$ID", 'Start workflow')) {
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Start-GitHubWorkflow] - Done"
#endregion [functions] - [public] - [Workflows] - [Start-GitHubWorkflow]
#region    [functions] - [public] - [Workflows] - [Runs]
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Runs] - Processing folder"
#region    [functions] - [public] - [Workflows] - [Runs] - [Get-GitHubWorkflowRun]
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Runs] - [Get-GitHubWorkflowRun] - Importing"
filter Get-GitHubWorkflowRun {
    <#
        .SYNOPSIS
        List workflow runs for a repository or a workflow

        .DESCRIPTION
        Lists all workflow runs for a repository or a workflow. You can use parameters to narrow the list of results. For more information about using
        parameters, see [Parameters](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#parameters).
        Anyone with read access to the repository can use this endpoint.
        OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
        This endpoint will return up to 1,000 results for each search when using the following parameters: `actor`, `branch`, `check_suite_id`, `created`,
        `event`, `head_sha`, `status`.

        .EXAMPLE
        Get-GitHubWorkflowRun -Owner 'owner' -Repository 'repo'

        Lists all workflow runs for a repository.

        .EXAMPLE
        Get-GitHubWorkflowRun -Owner 'owner' -Repository 'repo' -Actor 'octocat' -Branch 'main' -Event 'push' -Status 'success'

        Lists all workflow runs for a repository with the specified actor, branch, event, and status.

        .EXAMPLE
        Get-GitHubWorkflowRun -Owner 'octocat' -Repository 'Hello-World' -ID '42'

        Gets all workflow runs for the workflow with the ID `42` in the repository `Hello-World` owned by `octocat`.

        .EXAMPLE
        Get-GitHubWorkflowRun -Owner 'octocat' -Repository 'Hello-World' -Name 'nightly.yml' -Actor 'octocat' -Branch 'main' -Event 'push' -Status 'success'

        Gets all workflow runs for the workflow with the name `nightly.yml` in the repository `Hello-World` owned by `octocat` that were triggered by
        the user `octocat` on the branch `main` and have the status `success`.

        .INPUTS
        GitHubWorkflow

        .OUTPUTS
        GitHubWorkflowRun

        .LINK
        https://psmodule.io/GitHub/Functions/Workflows/Runs/Get-GitHubWorkflowRun/

        .NOTES
        [List workflow runs for a workflow](https://docs.github.com/rest/actions/workflow-runs#list-workflow-runs-for-a-workflow)
        [List workflow runs for a repository](https://docs.github.com/rest/actions/workflow-runs#list-workflow-runs-for-a-repository)
    #>
    [OutputType([GitHubWorkflowRun])]
    [CmdletBinding(DefaultParameterSetName = '__AllParameterSets')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidLongLines', '', Justification = 'Contains a long link.')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidAssignmentToAutomaticVariable', 'Event',
        Justification = 'A parameter that is used in the api call.')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The ID of the workflow. You can also pass the workflow filename as a string.
        [Parameter(Mandatory, ParameterSetName = 'ByID', ValueFromPipelineByPropertyName)]
        [string] $ID,

        # The name of the workflow.
        [Parameter(Mandatory, ParameterSetName = 'ByName')]
        [string] $Name,

        # Returns someone's workflow runs. Use the login for the user who created the push associated with the check suite or workflow run.
        [Parameter()]
        [string] $Actor,

        # Returns workflow runs associated with a branch. Use the name of the branch of the `push`.
        [Parameter()]
        [string] $Branch,

        # Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see
        # "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
        [Parameter()]
        [string] $Event,

        # Returns workflow runs with the check run status or conclusion that you specify. For example, a conclusion can be success or a status can be
        # `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.
        # Can be one of: `completed`, `action_required`, `cancelled`, `failure`, `neutral`, `skipped`, `stale`, `success`, `timed_out`, `in_progress`,
        # `queued`, `requested`, `waiting`, `pending`.
        [Parameter()]
        # [ValidateSet('completed', 'action_required', 'cancelled', 'failure', 'neutral', 'skipped', 'stale', 'success', 'timed_out', 'in_progress',
        #     'queued', 'requested', 'waiting', 'pending')]
        [string] $Status,

        # Returns workflow runs created within the given date-time range. For more information on the syntax, see
        # "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
        [Parameter()]
        [datetime] $Created,

        # If `true` pull requests are omitted from the response (empty array).
        [Parameter()]
        [switch] $ExcludePullRequests,

        # Returns workflow runs with the check_suite_id that you specify.
        [Parameter()]
        [System.Nullable[UInt64]] $CheckSuiteID,

        # Only returns workflow runs that are associated with the specified head_sha.
        [Parameter()]
        [string] $HeadSHA,

        # The number of results per page (max 100).
        [Parameter()]
        [System.Nullable[int]] $PerPage,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $params = @{
            Owner               = $Owner
            Repository          = $Repository
            Actor               = $Actor
            Branch              = $Branch
            Event               = $Event
            Status              = $Status
            Created             = $Created
            ExcludePullRequests = [bool] $ExcludePullRequests
            CheckSuiteID        = $CheckSuiteID
            HeadSHA             = $HeadSHA
            PerPage             = $PerPage
            Context             = $Context
        }
        $params | Remove-HashtableEntry -NullOrEmptyValues

        Write-Debug "ParameterSet: $($PSCmdlet.ParameterSetName)"
        switch ($PSCmdlet.ParameterSetName) {
            'ByID' {
                $params['ID'] = $ID
                Get-GitHubWorkflowRunByWorkflow @params
            }

            'ByName' {
                $params['ID'] = (Get-GitHubWorkflow -Owner $Owner -Repository $Repository -Name $Name -Context $Context).ID
                Get-GitHubWorkflowRunByWorkflow @params
            }

            default {
                Get-GitHubWorkflowRunByRepo @params
            }
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Runs] - [Get-GitHubWorkflowRun] - Done"
#endregion [functions] - [public] - [Workflows] - [Runs] - [Get-GitHubWorkflowRun]
#region    [functions] - [public] - [Workflows] - [Runs] - [Remove-GitHubWorkflowRun]
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Runs] - [Remove-GitHubWorkflowRun] - Importing"
filter Remove-GitHubWorkflowRun {
    <#
        .SYNOPSIS
        Delete a workflow run

        .DESCRIPTION
        Delete a specific workflow run. Anyone with write access to the repository can use this endpoint. If the repository is
        private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:write` permission to use
        this endpoint.

        .EXAMPLE
        Remove-GitHubWorkflowRun -Owner 'octocat' -Repository 'Hello-World' -ID 123456789

        Deletes the workflow run with the ID 123456789 from the 'Hello-World' repository owned by 'octocat'

        .INPUTS
        GitHubWorkflowRun

        .LINK
        https://psmodule.io/GitHub/Functions/Workflows/Runs/Remove-GitHubWorkflowRun/

        .NOTES
        [Delete a workflow run](https://docs.github.com/rest/actions/workflow-runs#delete-a-workflow-run)
    #>
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The unique identifier of the workflow run.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'DELETE'
            APIEndpoint = "repos/$Owner/$Repository/actions/runs/$ID"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("$Owner/$Repository/$ID", 'Delete workflow run')) {
            Write-Verbose "Deleted workflow run [$ID] in [$Owner/$Repository]"
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Runs] - [Remove-GitHubWorkflowRun] - Done"
#endregion [functions] - [public] - [Workflows] - [Runs] - [Remove-GitHubWorkflowRun]
#region    [functions] - [public] - [Workflows] - [Runs] - [Restart-GitHubWorkflowRun]
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Runs] - [Restart-GitHubWorkflowRun] - Importing"
filter Restart-GitHubWorkflowRun {
    <#
        .SYNOPSIS
        Re-run a workflow

        .DESCRIPTION
        Re-runs your workflow run using its `run_id`. You can also specify a branch or tag name to re-run a workflow run from a branch

        .EXAMPLE
        Start-GitHubWorkflowReRun -Owner 'octocat' -Repository 'Hello-World' -ID 123456789

        .INPUTS
        GitHubWorkflowRun

        .LINK
        https://psmodule.io/GitHub/Functions/Workflows/Runs/Restart-GitHubWorkflowRun/

        .NOTES
        [Re-run a workflow](https://docs.github.com/rest/actions/workflow-runs#re-run-a-workflow)
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The unique identifier of the workflow run.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/repos/$Owner/$Repository/actions/runs/$ID/rerun"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("workflow with ID [$ID] in [$Owner/$Repository]", 'Re-run')) {
            Write-Verbose "Re-run workflow [$ID] in [$Owner/$Repository]"
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Runs] - [Restart-GitHubWorkflowRun] - Done"
#endregion [functions] - [public] - [Workflows] - [Runs] - [Restart-GitHubWorkflowRun]
#region    [functions] - [public] - [Workflows] - [Runs] - [Stop-GitHubWorkflowRun]
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Runs] - [Stop-GitHubWorkflowRun] - Importing"
filter Stop-GitHubWorkflowRun {
    <#
        .SYNOPSIS
        Cancel a workflow run

        .DESCRIPTION
        Cancels a workflow run using its `run_id`. You can use this endpoint to cancel a workflow run that is in progress or waiting

        .EXAMPLE
        Stop-GitHubWorkflowRun -Owner 'octocat' -Repository 'Hello-World' -ID 123456789

        Cancels the workflow run with the ID 123456789 from the 'Hello-World' repository owned by 'octocat'.

        .INPUTS
        GitHubWorkflowRun

        .LINK
        https://psmodule.io/GitHub/Functions/Workflows/Runs/Stop-GitHubWorkflowRun/

        .NOTES
        [Cancel a workflow run](https://docs.github.com/rest/actions/workflow-runs#cancel-a-workflow-run)
    #>
    [CmdletBinding(SupportsShouldProcess)]
    [alias('Cancel-GitHubWorkflowRun')]
    param(
        # The account owner of the repository. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Owner,

        # The name of the repository without the .git extension. The name is not case sensitive.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $Repository,

        # The unique identifier of the workflow run.
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [string] $ID,

        # The context to run the command in. Used to get the details for the API call.
        # Can be either a string or a GitHubContext object.
        [Parameter()]
        [object] $Context
    )

    begin {
        $stackPath = Get-PSCallStackPath
        Write-Debug "[$stackPath] - Start"
        $Context = Resolve-GitHubContext -Context $Context
        Assert-GitHubContext -Context $Context -AuthType IAT, PAT, UAT
    }

    process {
        $apiParams = @{
            Method      = 'POST'
            APIEndpoint = "/repos/$Owner/$Repository/actions/runs/$ID/cancel"
            Context     = $Context
        }

        if ($PSCmdlet.ShouldProcess("$Owner/$Repository/$ID", 'Cancel/Stop workflow run')) {
            Write-Verbose "Cancelled workflow run [$ID] in [$Owner/$Repository]"
            $null = Invoke-GitHubAPI @apiParams
        }
    }

    end {
        Write-Debug "[$stackPath] - End"
    }
}

#SkipTest:FunctionTest:Will add a test for this function in a future PR
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Runs] - [Stop-GitHubWorkflowRun] - Done"
#endregion [functions] - [public] - [Workflows] - [Runs] - [Stop-GitHubWorkflowRun]
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - [Runs] - Done"
#endregion [functions] - [public] - [Workflows] - [Runs]
Write-Debug "[$scriptName] - [functions] - [public] - [Workflows] - Done"
#endregion [functions] - [public] - [Workflows]
Write-Debug "[$scriptName] - [functions] - [public] - Done"
#endregion [functions] - [public]
#region    [variables] - [private]
Write-Debug "[$scriptName] - [variables] - [private] - Processing folder"
#region    [variables] - [private] - [GitHub]
Write-Debug "[$scriptName] - [variables] - [private] - [GitHub] - Importing"
$script:IsGitHubActions = $env:GITHUB_ACTIONS -eq 'true'
$script:IsFunctionApp = -not [string]::IsNullOrEmpty($env:WEBSITE_PLATFORM_VERSION)
$script:IsLocal = -not ($script:IsGitHubActions -or $script:IsFunctionApp)
$script:GitHub = [pscustomobject]@{
    ContextVault       = 'PSModule.GitHub'
    TokenPrefixPattern = '(?<=^(ghu|gho|ghs|github_pat|ghp)).*'
    EnvironmentType    = Get-GitHubEnvironmentType
    DefaultConfig      = [GitHubConfig]@{
        ID                            = 'Module'
        HostName                      = ($env:GITHUB_SERVER_URL ?? 'github.com') -replace '^https?://'
        ApiBaseUri                    = "https://api.$(($env:GITHUB_SERVER_URL ?? 'github.com') -replace '^https?://')"
        AccessTokenGracePeriodInHours = 4.0
        GitHubAppClientID             = 'Iv1.f26b61bc99e69405'
        OAuthAppClientID              = '7204ae9b0580f2cb8288'
        DefaultContext                = ''
        ApiVersion                    = '2022-11-28'
        HttpVersion                   = '2.0'
        PerPage                       = 100
        RetryCount                    = 0
        RetryInterval                 = 1
        JwtTimeTolerance              = 300
        EnvironmentType               = Get-GitHubEnvironmentType
    }
    Config             = $null
    Event              = $null
    Runner             = $null
}
Write-Debug "[$scriptName] - [variables] - [private] - [GitHub] - Done"
#endregion [variables] - [private] - [GitHub]
#region    [variables] - [private] - [StatusBaseURL]
Write-Debug "[$scriptName] - [variables] - [private] - [StatusBaseURL] - Importing"
$script:StatusBaseURL = @{
    Public    = 'https://www.githubstatus.com'
    Europe    = 'https://eu.githubstatus.com'
    Australia = 'https://au.githubstatus.com'
    US        = 'https://us.githubstatus.com'
}
Write-Debug "[$scriptName] - [variables] - [private] - [StatusBaseURL] - Done"
#endregion [variables] - [private] - [StatusBaseURL]
#region    [variables] - [private] - [UserAgent]
Write-Debug "[$scriptName] - [variables] - [private] - [UserAgent] - Importing"
$script:Prerelease = $script:PSModuleInfo.PrivateData.PSData.Prerelease
$script:UserAgent = "PSModule.GitHub $($script:PSModuleInfo.ModuleVersion)"
if ($script:Prerelease) {
    $script:UserAgent += "-$script:Prerelease"
}
Write-Debug "[$scriptName] - [variables] - [private] - [UserAgent] - Done"
#endregion [variables] - [private] - [UserAgent]
Write-Debug "[$scriptName] - [variables] - [private] - Done"
#endregion [variables] - [private]
#region    [loader]
Write-Debug "[$scriptName] - [loader] - Importing"
$scriptFilePath = $MyInvocation.MyCommand.Path
Write-Verbose 'Initializing GitHub PowerShell module...'
Write-Verbose "Path: $scriptFilePath"

if ($Host.UI.SupportsVirtualTerminal) {
    $PSStyle.OutputRendering = 'Ansi'
}

if ($script:IsGitHubActions) {
    Write-Verbose 'Detected running on a GitHub Actions runner, preparing environment...'
    $env:GITHUB_REPOSITORY_NAME = $env:GITHUB_REPOSITORY -replace '.+/'
    Set-GitHubEnvironmentVariable -Name 'GITHUB_REPOSITORY_NAME' -Value $env:GITHUB_REPOSITORY_NAME
    $env:GITHUB_HOST_NAME = ($env:GITHUB_SERVER_URL ?? 'github.com') -replace '^https?://'
    Set-GitHubEnvironmentVariable -Name 'GITHUB_HOST_NAME' -Value $env:GITHUB_HOST_NAME
    Import-GitHubEventData
    Import-GitHubRunnerData
}
Write-Debug "[$scriptName] - [loader] - Done"
#endregion [loader]
#region    Class exporter
# Get the internal TypeAccelerators class to use its static methods.
$TypeAcceleratorsClass = [psobject].Assembly.GetType(
    'System.Management.Automation.TypeAccelerators'
)
# Ensure none of the types would clobber an existing type accelerator.
# If a type accelerator with the same name exists, throw an exception.
$ExistingTypeAccelerators = $TypeAcceleratorsClass::Get
# Define the types to export with type accelerators.
$ExportableEnums = @(
)
$ExportableEnums | Foreach-Object { Write-Verbose "Exporting enum '$($_.FullName)'." }
foreach ($Type in $ExportableEnums) {
    if ($Type.FullName -in $ExistingTypeAccelerators.Keys) {
        Write-Verbose "Enum already exists [$($Type.FullName)]. Skipping."
    } else {
        Write-Verbose "Importing enum '$Type'."
        $TypeAcceleratorsClass::Add($Type.FullName, $Type)
    }
}
$ExportableClasses = @(
    [GitHubApp]
    [GitHubAppInstallation]
    [GitHubAppInstallationRequest]
    [GitHubArtifact]
    [GitHubConfig]
    [GitHubContext]
    [GitHubAppContext]
    [GitHubAppInstallationContext]
    [GitHubUserContext]
    [GitHubEnvironment]
    [GitHubBillingInfo]
    [GitHubFormatter]
    [GitHubJWTComponent]
    [GitHubLicenseRule]
    [GitHubLicense]
    [GitHubNode]
    [GitHubPlan]
    [GitHubOwner]
    [GitHubEnterprise]
    [GitHubOrganization]
    [GitHubUser]
    [GitHubRateLimitResource]
    [GitHubRelease]
    [GitHubReleaseAsset]
    [GitHubRepository]
    [GitHubRepositoryLanguage]
    [GitHubRepositoryPermission]
    [GitHubPublicKey]
    [GitHubSecret]
    [GitHubTeam]
    [GitHubVariable]
    [GitHubWebhookConfiguration]
    [GitHubWebhookDelivery]
    [GitHubWorkflow]
    [GitHubWorkflowRun]
)
$ExportableClasses | Foreach-Object { Write-Verbose "Exporting class '$($_.FullName)'." }
foreach ($Type in $ExportableClasses) {
    if ($Type.FullName -in $ExistingTypeAccelerators.Keys) {
        Write-Verbose "Class already exists [$($Type.FullName)]. Skipping."
    } else {
        Write-Verbose "Importing class '$Type'."
        $TypeAcceleratorsClass::Add($Type.FullName, $Type)
    }
}

# Remove type accelerators when the module is removed.
$MyInvocation.MyCommand.ScriptBlock.Module.OnRemove = {
    foreach ($Type in ($ExportableEnums + $ExportableClasses)) {
        $null = $TypeAcceleratorsClass::Remove($Type.FullName)
    }
}.GetNewClosure()
#endregion Class exporter
#region    Member exporter
$exports = @{
    Alias    = '*'
    Cmdlet   = ''
    Function = @(
        'Get-GitHubEventData'
        'Get-GitHubRunnerData'
        'Invoke-GitHubAPI'
        'Invoke-GitHubGraphQLQuery'
        'Get-GitHubApp'
        'Get-GitHubAppInstallationRequest'
        'Install-GitHubApp'
        'Uninstall-GitHubApp'
        'Add-GitHubAppInstallationRepositoryAccess'
        'Get-GitHubAppAccessibleRepository'
        'Get-GitHubAppInstallation'
        'Get-GitHubAppInstallationRepositoryAccess'
        'Remove-GitHubAppInstallationRepositoryAccess'
        'Update-GitHubAppInstallationRepositoryAccess'
        'Get-GitHubArtifact'
        'Remove-GitHubArtifact'
        'Save-GitHubArtifact'
        'Get-GitHubContext'
        'Switch-GitHubContext'
        'Connect-GitHubAccount'
        'Connect-GitHubApp'
        'Disconnect-GitHubAccount'
        'Get-GitHubAccessToken'
        'Get-GitHubViewer'
        'Revoke-GitHubAccessToken'
        'Add-GitHubMask'
        'Add-GitHubSystemPath'
        'Disable-GitHubCommand'
        'Enable-GitHubCommand'
        'Get-GitHubOutput'
        'Reset-GitHubOutput'
        'Set-GitHubEnvironmentVariable'
        'Set-GitHubLogGroup'
        'Set-GitHubNoCommandGroup'
        'Set-GitHubOutput'
        'Set-GitHubStepSummary'
        'Start-GitHubLogGroup'
        'Stop-GitHubLogGroup'
        'Write-GitHubDebug'
        'Write-GitHubError'
        'Write-GitHubLog'
        'Write-GitHubNotice'
        'Write-GitHubWarning'
        'Get-GitHubConfig'
        'Remove-GitHubConfig'
        'Reset-GitHubConfig'
        'Set-GitHubConfig'
        'Get-GitHubEmoji'
        'Get-GitHubEnterprise'
        'Get-GitHubEnterpriseOrganization'
        'Get-GitHubEnvironment'
        'Remove-GitHubEnvironment'
        'Set-GitHubEnvironment'
        'Get-GitHubGitConfig'
        'Set-GitHubGitConfig'
        'Get-GitHubGitignore'
        'ConvertFrom-IssueForm'
        'Get-GitHubLicense'
        'Get-GitHubMarkdown'
        'Get-GitHubMarkdownRaw'
        'Get-GitHubApiVersion'
        'Get-GitHubMeta'
        'Get-GitHubOctocat'
        'Get-GitHubRoot'
        'Get-GitHubZen'
        'Get-GitHubOrganizationMember'
        'Get-GitHubOrganizationPendingInvitation'
        'New-GitHubOrganizationInvitation'
        'Remove-GitHubOrganizationInvitation'
        'Get-GitHubOrganization'
        'New-GitHubOrganization'
        'Remove-GitHubOrganization'
        'Update-GitHubOrganization'
        'Get-GitHubRateLimit'
        'Add-GitHubReleaseAsset'
        'Get-GitHubReleaseAsset'
        'Remove-GitHubReleaseAsset'
        'Save-GitHubReleaseAsset'
        'Update-GitHubReleaseAsset'
        'Get-GitHubRelease'
        'New-GitHubRelease'
        'New-GitHubReleaseNote'
        'Remove-GitHubRelease'
        'Set-GitHubRelease'
        'Update-GitHubRelease'
        'Get-GitHubRepositoryAutolink'
        'New-GitHubRepositoryAutolink'
        'Remove-GitHubRepositoryAutolink'
        'Get-GitHubRepositoryCustomProperty'
        'Get-GitHubRepositoryPermission'
        'Remove-GitHubRepositoryPermission'
        'Set-GitHubRepositoryPermission'
        'Disable-GitHubRepositoryPrivateVulnerabilityReporting'
        'Disable-GitHubRepositorySecurityFix'
        'Disable-GitHubRepositoryVulnerabilityAlert'
        'Enable-GitHubRepositoryPrivateVulnerabilityReporting'
        'Enable-GitHubRepositorySecurityFix'
        'Enable-GitHubRepositoryVulnerabilityAlert'
        'Get-GitHubRepositoryActivity'
        'Get-GitHubRepositoryCodeownersError'
        'Get-GitHubRepositoryContributor'
        'Get-GitHubRepositoryFork'
        'Get-GitHubRepositoryLanguage'
        'Get-GitHubRepositorySecurityFix'
        'Get-GitHubRepositoryTag'
        'Get-GitHubRepositoryTeam'
        'Get-GitHubRepositoryTopic'
        'Set-GitHubRepositoryTopic'
        'Start-GitHubRepositoryEvent'
        'Test-GitHubRepositoryVulnerabilityAlert'
        'Get-GitHubRepositoryRuleSuite'
        'Get-GitHubRepository'
        'Move-GitHubRepository'
        'New-GitHubRepository'
        'Remove-GitHubRepository'
        'Set-GitHubRepository'
        'Update-GitHubRepository'
        'Add-GitHubSecretSelectedRepository'
        'Get-GitHubSecretSelectedRepository'
        'Remove-GitHubSecretSelectedRepository'
        'Set-GitHubSecretSelectedRepository'
        'Get-GitHubPublicKey'
        'Get-GitHubSecret'
        'Remove-GitHubSecret'
        'Set-GitHubSecret'
        'Get-GitHubScheduledMaintenance'
        'Get-GitHubStatus'
        'Get-GitHubStatusComponent'
        'Get-GitHubStatusIncident'
        'Get-GitHubTeam'
        'New-GitHubTeam'
        'Remove-GitHubTeam'
        'Update-GitHubTeam'
        'Block-GitHubUser'
        'Get-GitHubBlockedUser'
        'Test-GitHubBlockedUser'
        'Unblock-GitHubUser'
        'Add-GitHubUserEmail'
        'Get-GitHubUserEmail'
        'Remove-GitHubUserEmail'
        'Update-GitHubUserEmailVisibility'
        'Add-GitHubUserFollowing'
        'Get-GitHubUserFollower'
        'Get-GitHubUserFollowing'
        'Remove-GitHubUserFollowing'
        'Test-GitHubUserFollowing'
        'Add-GitHubUserGpgKey'
        'Get-GitHubUserGpgKey'
        'Remove-GitHubUserGpgKey'
        'Add-GitHubUserKey'
        'Get-GitHubUserKey'
        'Remove-GitHubUserKey'
        'Add-GitHubUserSocial'
        'Remove-GitHubUserSocial'
        'Add-GitHubUserSigningKey'
        'Get-GitHubUserSigningKey'
        'Remove-GitHubUserSigningKey'
        'Get-GitHubUser'
        'Update-GitHubUser'
        'Add-GitHubVariableSelectedRepository'
        'Get-GitHubVariableSelectedRepository'
        'Remove-GitHubVariableSelectedRepository'
        'Set-GitHubVariableSelectedRepository'
        'Export-GitHubVariable'
        'Get-GitHubVariable'
        'New-GitHubVariable'
        'Remove-GitHubVariable'
        'Set-GitHubVariable'
        'Update-GitHubVariable'
        'Get-GitHubAppWebhookConfiguration'
        'Get-GitHubAppWebhookDelivery'
        'Invoke-GitHubAppWebhookReDelivery'
        'Test-GitHubWebhookSignature'
        'Update-GitHubAppWebhookConfiguration'
        'Get-GitHubWorkflowRun'
        'Remove-GitHubWorkflowRun'
        'Restart-GitHubWorkflowRun'
        'Stop-GitHubWorkflowRun'
        'Disable-GitHubWorkflow'
        'Enable-GitHubWorkflow'
        'Get-GitHubWorkflow'
        'Start-GitHubWorkflow'
    )
    Variable = ''
}
Export-ModuleMember @exports
#endregion Member exporter

